{"file_contents":{"inline_handler.py":{"content":"\"\"\"\nCentral Inline Button Router\nHandles all inline keyboard callbacks and routes them to appropriate handlers\n\"\"\"\n\nimport logging\nfrom typing import Dict, Any, Optional\n\nfrom aiogram import Bot\nfrom aiogram.types import CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton\nfrom aiogram.fsm.context import FSMContext\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\n\nlogger = logging.getLogger(__name__)\n\n\nclass InlineHandler:\n    \"\"\"Central router for all inline button callbacks\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config):\n        self.bot = bot\n        self.db_manager = db_manager\n        self.config = config\n        self.handlers: Dict[str, Any] = {}\n        \n    def register_handler(self, prefix: str, handler: Any):\n        \"\"\"Register a handler for a specific callback prefix\"\"\"\n        self.handlers[prefix] = handler\n        logger.info(f\"‚úÖ Registered inline handler for prefix: {prefix}\")\n    \n    async def handle_callback(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Route callback to appropriate handler based on prefix\"\"\"\n        try:\n            if callback.data is None:\n                logger.warning(\"Received callback without data\")\n                return\n                \n            callback_data = callback.data\n            user_id = callback.from_user.id\n            username = callback.from_user.username or \"Unknown\"\n            \n            # Enhanced logging with user details\n            logger.info(f\"üîò BUTTON PRESSED: User {user_id} (@{username}) clicked '{callback_data}'\")\n            \n            # Handle main menu callbacks\n            if callback_data in self._get_main_menu_callbacks():\n                logger.info(f\"üè† MAIN MENU: Routing '{callback_data}' to main menu handler\")\n                await self._handle_main_menu_callback(callback)\n                return\n            \n            # Route to specific handlers based on prefix\n            # Account Management callbacks\n            if callback_data.startswith(\"am_\"):\n                if \"account_manager\" in self.handlers:\n                    logger.info(f\"üîÑ ROUTING: Account Manager callback '{callback_data}'\")\n                    await self.handlers[\"account_manager\"].handle_callback(callback, state)\n                    return\n            \n            # Channel Management callbacks\n            if callback_data.startswith(\"cm_\"):\n                if \"channel_manager\" in self.handlers:\n                    logger.info(f\"üîÑ ROUTING: Channel Manager callback '{callback_data}'\")\n                    await self.handlers[\"channel_manager\"].handle_callback(callback, state)\n                    return\n            \n            # View Manager callbacks\n            if callback_data.startswith(\"vm_\"):\n                if \"views_manager\" in self.handlers:\n                    logger.info(f\"üîÑ ROUTING: Views Manager callback '{callback_data}'\")\n                    await self.handlers[\"views_manager\"].handle_callback(callback, state)\n                    return\n            \n            # Live Management callbacks\n            if (callback_data.startswith(\"lm_\") or callback_data.startswith(\"aj_\") or \n                callback_data.startswith(\"mj_\") or callback_data.startswith(\"vs_\") or \n                callback_data.startswith(\"ls_\")):\n                if \"live_manager\" in self.handlers:\n                    logger.info(f\"üîÑ ROUTING: Live Manager callback '{callback_data}'\")\n                    await self.handlers[\"live_manager\"].handle_callback(callback, state)\n                    return\n            \n            # Analytics callbacks\n            if callback_data.startswith(\"an_\"):\n                if \"analytics\" in self.handlers:\n                    logger.info(f\"üîÑ ROUTING: Analytics callback '{callback_data}'\")\n                    await self.handlers[\"analytics\"].handle_callback(callback, state)\n                    return\n            \n            # Emoji Reactions callbacks\n            if callback_data.startswith(\"er_\"):\n                if \"emoji_reaction\" in self.handlers:\n                    logger.info(f\"üîÑ ROUTING: Emoji Reactions callback '{callback_data}'\")\n                    await self.handlers[\"emoji_reaction\"].handle_callback(callback, state)\n                    return\n            \n            # System Health callbacks\n            if callback_data.startswith(\"sh_\"):\n                if \"system_health\" in self.handlers:\n                    logger.info(f\"üîÑ ROUTING: System Health callback '{callback_data}'\")\n                    await self.handlers[\"system_health\"].handle_callback(callback, state)\n                    return\n            \n            # Poll Manager callbacks\n            if callback_data.startswith(\"pm_\"):\n                if \"poll_manager\" in self.handlers:\n                    logger.info(f\"üîÑ ROUTING: Poll Manager callback '{callback_data}'\")\n                    await self.handlers[\"poll_manager\"].handle_callback(callback, state)\n                    return\n            \n            # Auto Boost specific callbacks\n            if callback_data.startswith(\"ab_\"):\n                if \"views_manager\" in self.handlers:\n                    logger.info(f\"üîÑ ROUTING: Auto Boost callback '{callback_data}'\")\n                    await self.handlers[\"views_manager\"].handle_callback(callback, state)\n                    return\n            \n            # Handle unknown callbacks\n            logger.warning(f\"‚ùì UNKNOWN CALLBACK: '{callback_data}' from user {user_id}\")\n            await self._handle_unknown_callback(callback)\n            \n        except Exception as e:\n            logger.error(f\"‚ùå CALLBACK ERROR: Error handling callback '{callback.data}' from user {callback.from_user.id}: {e}\")\n            try:\n                # Check if it's a timeout error and handle gracefully\n                if \"query is too old\" in str(e) or \"timeout expired\" in str(e):\n                    logger.info(\"‚è∞ EXPIRED CALLBACK: Ignoring expired callback query\")\n                    return\n                logger.info(f\"ü§ñ ERROR RESPONSE: Sending error message to user {callback.from_user.id}\")\n                await callback.answer(\"‚ùå An error occurred. Please try again.\", show_alert=True)\n            except Exception as answer_error:\n                # If we can't answer the callback (e.g., expired), just log it\n                logger.info(f\"‚ö†Ô∏è CALLBACK ANSWER FAILED: Could not answer callback (likely expired): {answer_error}\")\n    \n    def _get_main_menu_callbacks(self) -> set:\n        \"\"\"Get set of main menu callback data\"\"\"\n        return {\n            \"account_manager\", \"channel_manager\", \"views_manager\", \n            \"poll_manager\", \"live_manager\", \"analytics\", \n            \"emoji_reaction\", \"help\", \"refresh_main\"\n        }\n    \n    async def _handle_main_menu_callback(self, callback: CallbackQuery):\n        \"\"\"Handle main menu callbacks\"\"\"\n        try:\n            callback_data = callback.data\n            user_id = callback.from_user.id\n            username = callback.from_user.username or \"User\"\n            \n            logger.info(f\"üìã MAIN MENU ACTION: User {user_id} (@{username}) selected '{callback_data}'\")\n            \n            # Check admin status for restricted features\n            is_admin = user_id in self.config.ADMIN_IDS\n            \n            if callback_data == \"refresh_main\":\n                # Import the method from telegram_bot.py\n                from telegram_bot import TelegramBot\n                temp_bot = TelegramBot(self.config, self.db_manager)\n                welcome_text = temp_bot._get_welcome_message(is_admin, username)\n                keyboard = temp_bot._get_main_keyboard(is_admin)\n                \n                if (callback.message is not None and \n                    hasattr(callback.message, 'edit_text') and \n                    not isinstance(callback.message, type(None))):\n                    try:\n                        await callback.message.edit_text(welcome_text, reply_markup=keyboard)\n                    except Exception as e:\n                        logger.warning(f\"Failed to edit message: {e}\")\n                await callback.answer(\"üîÑ Menu refreshed!\")\n                logger.info(f\"ü§ñ RESPONSE: Main menu refreshed for user {user_id}\")\n                \n            elif callback_data == \"help\":\n                # Show help information\n                logger.info(f\"‚ùì HELP REQUEST: User {user_id} requested help menu\")\n                await self._show_help_menu(callback)\n                \n            else:\n                # Route to feature handlers\n                if callback_data is not None:\n                    logger.info(f\"üéØ FEATURE ACCESS: User {user_id} accessing '{callback_data}' feature\")\n                    await self._route_to_feature(callback, callback_data)\n                \n        except Exception as e:\n            logger.error(f\"‚ùå MAIN MENU ERROR: Error in main menu callback for user {callback.from_user.id}: {e}\")\n            await callback.answer(\"‚ùå An error occurred.\", show_alert=True)\n    \n    async def _route_to_feature(self, callback: CallbackQuery, feature: str):\n        \"\"\"Route callback to specific feature handler\"\"\"\n        try:\n            user_id = callback.from_user.id\n            is_admin = user_id in self.config.ADMIN_IDS\n            \n            # Check admin access for restricted features\n            if not is_admin:\n                await callback.answer(\"üö´ Access restricted to authorized users only!\", show_alert=True)\n                return\n                \n            feature_name = feature.replace('_', ' ').title()\n            \n            logger.info(f\"üéØ FEATURE ROUTING: Loading '{feature_name}' for user {user_id}\")\n            \n            # Create feature menu text and keyboard\n            menu_text, menu_keyboard = await self._get_feature_menu(feature)\n            \n            logger.info(f\"ü§ñ FEATURE RESPONSE: Sending '{feature_name}' menu to user {user_id}\")\n            if (callback.message is not None and \n                hasattr(callback.message, 'edit_text') and \n                not isinstance(callback.message, type(None))):\n                try:\n                    await callback.message.edit_text(menu_text, reply_markup=menu_keyboard)\n                except Exception as e:\n                    logger.warning(f\"Failed to edit feature menu: {e}\")\n            await callback.answer(f\"üìã {feature_name} loaded\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå FEATURE ERROR: Error routing to feature '{feature}' for user {callback.from_user.id}: {e}\")\n            await callback.answer(\"‚ùå Feature temporarily unavailable\", show_alert=True)\n    \n    async def _get_feature_menu(self, feature: str) -> tuple[str, InlineKeyboardMarkup]:\n        \"\"\"Generate menu text and keyboard for specific feature\"\"\"\n        menus = {\n            \"account_manager\": (\n                \"üî• <b>ArcX | Account Manager</b>\\\\n\\\\n\"\n                \"Manage your Telegram accounts for operations:\\\\n\\\\n\",\n                InlineKeyboardMarkup(inline_keyboard=[\n                    [InlineKeyboardButton(text=\"[‚ûï Add Account]\", callback_data=\"am_add_account\")],\n                    [InlineKeyboardButton(text=\"[üóëÔ∏è Remove Account]\", callback_data=\"am_remove_account\")],\n                    [InlineKeyboardButton(text=\"[üìã List Accounts]\", callback_data=\"am_list_accounts\")],\n                    [InlineKeyboardButton(text=\"[üîÑ Refresh Accounts]\", callback_data=\"am_refresh\")],\n                    [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"refresh_main\")],\n                    [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n                ])\n            ),\n            \"channel_manager\": (\n                \"üî• <b>ArcX | Channel Manager</b>\\\\n\\\\n\"\n                \"Universal channel management system:\\\\n\\\\n\",\n                InlineKeyboardMarkup(inline_keyboard=[\n                    [InlineKeyboardButton(text=\"[‚ûï Add Channel]\", callback_data=\"cm_add_channel\")],\n                    [InlineKeyboardButton(text=\"[üóëÔ∏è Remove Channel]\", callback_data=\"cm_remove_channel\")],\n                    [InlineKeyboardButton(text=\"[üìã List Channels]\", callback_data=\"cm_list_channels\")],\n                    [InlineKeyboardButton(text=\"[üîÑ Refresh Channels]\", callback_data=\"cm_refresh\")],\n                    [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"refresh_main\")],\n                    [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n                ])\n            ),\n            \"views_manager\": (\n                \"üî• <b>ArcX | Views Manager</b>\\\\n\\\\n\"\n                \"Advanced view boosting system:\\\\n\\\\n\",\n                InlineKeyboardMarkup(inline_keyboard=[\n                    [InlineKeyboardButton(text=\"[ü§ñ Auto Boost]\", callback_data=\"vm_auto_boost\")],\n                    [InlineKeyboardButton(text=\"[üëÜ Manual Boost]\", callback_data=\"vm_manual_boost\")],\n                    [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"refresh_main\")],\n                    [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n                ])\n            ),\n            \"poll_manager\": (\n                \"üî• <b>ArcX | Poll Manager</b>\\\\n\\\\n\"\n                \"Automated poll voting system:\\\\n\\\\n\",\n                InlineKeyboardMarkup(inline_keyboard=[\n                    [InlineKeyboardButton(text=\"[üó≥Ô∏è Vote on Poll]\", callback_data=\"pm_vote_poll\")],\n                    [InlineKeyboardButton(text=\"[üìä Poll Stats]\", callback_data=\"pm_stats\")],\n                    [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"refresh_main\")],\n                    [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n                ])\n            ),\n            \"live_manager\": (\n                \"üî• <b>ArcX | Live Manager</b>\\\\n\\\\n\"\n                \"Live stream automation system:\\\\n\\\\n\",\n                InlineKeyboardMarkup(inline_keyboard=[\n                    [InlineKeyboardButton(text=\"[‚ñ∂Ô∏è Start Monitoring]\", callback_data=\"lm_start_monitoring\")],\n                    [InlineKeyboardButton(text=\"[‚èπÔ∏è Stop Monitoring]\", callback_data=\"lm_stop_monitoring\")],\n                    [InlineKeyboardButton(text=\"[‚öôÔ∏è Select Channels]\", callback_data=\"lm_select_channels\")],\n                    [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"refresh_main\")],\n                    [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n                ])\n            ),\n            \"analytics\": (\n                \"üî• <b>ArcX | Analytics</b>\\\\n\\\\n\"\n                \"Comprehensive performance monitoring:\\\\n\\\\n\",\n                InlineKeyboardMarkup(inline_keyboard=[\n                    [InlineKeyboardButton(text=\"[üìä Channel Data]\", callback_data=\"an_channel_data\")],\n                    [InlineKeyboardButton(text=\"[üíæ System Info]\", callback_data=\"an_system_info\")],\n                    [InlineKeyboardButton(text=\"[‚ö° Engine Status]\", callback_data=\"an_engine_status\")],\n                    [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"refresh_main\")],\n                    [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n                ])\n            ),\n            \"emoji_reaction\": (\n                \"üî• <b>ArcX | Emoji Reaction</b>\\\\n\\\\n\"\n                \"Automated emoji reaction system:\\\\n\\\\n\",\n                InlineKeyboardMarkup(inline_keyboard=[\n                    [InlineKeyboardButton(text=\"[üòÄ React to Messages]\", callback_data=\"er_react_messages\")],\n                    [InlineKeyboardButton(text=\"[‚öôÔ∏è Reaction Settings]\", callback_data=\"er_settings\")],\n                    [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"refresh_main\")],\n                    [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n                ])\n            ),\n        }\n        \n        return menus.get(feature, (\"‚ùå Feature not found\", InlineKeyboardMarkup(inline_keyboard=[])))\n    \n    async def _show_help_menu(self, callback: CallbackQuery):\n        \"\"\"Show detailed help menu\"\"\"\n        help_text = \"\"\"\nüî• <b>ArcX Bot - Help Documentation</b>\n\n<b>üìã Feature Guide:</b>\n\nüì± <b>[Account Manager]</b>\n‚Ä¢ Add accounts with default/custom API\n‚Ä¢ Remove accounts and session cleanup\n‚Ä¢ List accounts with detailed info\n‚Ä¢ Refresh account status\n\nüì∫ <b>[Channel Manager]</b> \n‚Ä¢ Universal link handler for any channel type\n‚Ä¢ Add/remove channels from all accounts\n‚Ä¢ View channel statistics and member count\n‚Ä¢ Generate unique channel IDs for operations\n\nüöÄ <b>[Views Manager]</b>\n‚Ä¢ Auto Boost: Configure timing, cooldown, view counts\n‚Ä¢ Manual Boost: Instant view boosting\n‚Ä¢ Advanced scheduling with custom time formats\n‚Ä¢ Per-channel configuration settings\n\nüó≥Ô∏è <b>[Poll Manager]</b>\n‚Ä¢ Universal poll link handler\n‚Ä¢ Vote with multiple accounts\n‚Ä¢ Select voting options and distribution\n‚Ä¢ Real-time voting progress tracking\n\nüéôÔ∏è <b>[Live Manager]</b>\n‚Ä¢ Auto-join live streams and voice chats\n‚Ä¢ WebRTC audio streaming (silent audio)\n‚Ä¢ Random hand raising and interactions\n‚Ä¢ Configurable participation settings\n\nüìä <b>[Analytics]</b>\n‚Ä¢ Per-channel performance metrics\n‚Ä¢ System health and resource monitoring\n‚Ä¢ Engine status tracking\n‚Ä¢ Database connection statistics\n\nüòÄ <b>[Emoji Reaction]</b>\n‚Ä¢ React to latest messages automatically\n‚Ä¢ Random emoji distribution strategies\n‚Ä¢ Custom reaction counts per message\n‚Ä¢ Multi-account reaction coordination\n\n<b>üë®‚Äçüíª Developer:</b> @damn_itd_ravan\n        \"\"\"\n        \n        keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"[üîô Back to Main]\", callback_data=\"refresh_main\")]\n        ])\n        \n        if (callback.message is not None and \n            hasattr(callback.message, 'edit_text') and \n            not isinstance(callback.message, type(None))):\n            try:\n                await callback.message.edit_text(help_text, reply_markup=keyboard)\n            except Exception as e:\n                logger.warning(f\"Failed to edit help menu: {e}\")\n        await callback.answer(\"üìö Help documentation loaded\")\n\n    async def _handle_unknown_callback(self, callback: CallbackQuery):\n        \"\"\"Handle unknown or unregistered callbacks\"\"\"\n        logger.warning(f\"Unknown callback received: {callback.data}\")\n        try:\n            await callback.answer(\"‚ùå Unknown command. Please use the menu buttons.\", show_alert=True)\n        except Exception as e:\n            if \"query is too old\" in str(e) or \"timeout expired\" in str(e):\n                logger.info(\"Ignoring expired unknown callback query\")\n            else:\n                logger.error(f\"Error answering unknown callback: {e}\")","size_bytes":18960},"main.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTelegram Channel Management Bot - Main Entry Point\nComprehensive bot for channel management, view boosting, and live stream operations\n\"\"\"\n\nimport asyncio\nimport logging\nimport os\nimport sys\nfrom pathlib import Path\n\n# Add project root to Python path\nproject_root = Path(__file__).parent\nsys.path.insert(0, str(project_root))\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\nfrom telegram_bot import TelegramBot\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('bot.log'),\n        logging.StreamHandler(sys.stdout)\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n\n\nasync def main():\n    \"\"\"Main application entry point\"\"\"\n    db_manager = None\n    bot = None\n    try:\n        logger.info(\"üöÄ Starting Telegram Channel Management Bot...\")\n        \n        # Initialize configuration\n        config = Config()\n        logger.info(\"‚úÖ Configuration loaded successfully\")\n        \n        # Initialize database\n        db_manager = DatabaseManager()\n        await db_manager.initialize()\n        logger.info(\"‚úÖ Database initialized successfully\")\n        \n        # Initialize and start the bot\n        bot = TelegramBot(config, db_manager)\n        await bot.initialize()\n        logger.info(\"‚úÖ Bot initialized successfully\")\n        \n        # Start the bot\n        logger.info(\"üéØ Bot is running and ready to serve!\")\n        await bot.start()\n        \n    except KeyboardInterrupt:\n        logger.info(\"‚èπÔ∏è Bot stopped by user\")\n    except Exception as e:\n        logger.error(f\"üí• Fatal error: {e}\", exc_info=True)\n        sys.exit(1)\n    finally:\n        # Cleanup resources\n        try:\n            if db_manager is not None:\n                await db_manager.close()\n            if bot is not None:\n                await bot.shutdown()\n        except Exception as e:\n            logger.error(f\"Error during cleanup: {e}\")\n\n\nif __name__ == \"__main__\":\n    # Set event loop policy for Windows compatibility\n    if sys.platform.startswith('win'):\n        try:\n            if hasattr(asyncio, 'WindowsProactorEventLoopPolicy'):\n                asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())\n        except (AttributeError, ImportError):\n            # WindowsProactorEventLoopPolicy not available in all Python versions\n            pass\n    \n    # Run the bot\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        logger.info(\"Bot stopped\")\n    except Exception as e:\n        logger.error(f\"Failed to start bot: {e}\")\n        sys.exit(1)\n","size_bytes":2696},"pyproject.toml":{"content":"[project]\nname = \"telegram-channel-management-bot\"\nversion = \"1.0.0\"\ndescription = \"Comprehensive Telegram Channel Management Bot with view boosting and live stream features\"\nauthors = [{name = \"Channel Bot Team\", email = \"admin@channelbot.com\"}]\nlicense = {text = \"MIT\"}\nreadme = \"README.md\"\nrequires-python = \">=3.11\"\n\ndependencies = [\n    \"aiogram>=3.22.0\", # Telegram Bot Framework\n    \"telethon>=1.40.0\", # Telegram Client Library\n    \"psycopg2-binary>=2.9.10\", # PostgreSQL Database Adapter\n    \"python-dotenv>=1.1.1\", # Environment Variables\n    \"psutil>=7.0.0\", # System Monitoring\n    \"pytz>=2025.2\", # Timezone Handling\n    \"py-tgcalls>=2.2.6\", # Voice Call Handling (for audio loops)\n    \"asyncpg>=0.29.0\", # Async PostgreSQL driver\n    \"aiofiles>=24.1.0\", # Async file operations\n    \"cryptography>=42.0.0\", # Cryptographic operations\n    \"pydantic>=2.5.0\", # Data validation\n    \"httpx>=0.26.0\", # HTTP client for API calls\n    \"features>=0.5.12\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest>=7.4.0\",\n    \"pytest-asyncio>=0.21.0\",\n    \"black>=23.0.0\",\n    \"flake8>=6.0.0\",\n    \"mypy>=1.5.0\",\n]\n\n[build-system]\nrequires = [\"setuptools>=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools.packages.find]\ninclude = [\"*\"]\nexclude = [\"tests*\", \"docs*\"]\n\n[tool.black]\nline-length = 88\ntarget-version = ['py311']\ninclude = '\\.pyi?$'\nextend-exclude = '''\n/(\n  # directories\n  \\.eggs\n  | \\.git\n  | \\.hg\n  | \\.mypy_cache\n  | \\.tox\n  | \\.venv\n  | build\n  | dist\n)/\n'''\n\n[tool.mypy]\npython_version = \"3.11\"\nwarn_return_any = true\nwarn_unused_configs = true\ndisallow_untyped_defs = true\ndisallow_incomplete_defs = true\ncheck_untyped_defs = true\ndisallow_untyped_decorators = true\nno_implicit_optional = true\nwarn_redundant_casts = true\nwarn_unused_ignores = true\nwarn_no_return = true\nwarn_unreachable = true\nstrict_equality = true\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\", \"*_test.py\"]\npython_classes = [\"Test*\"]\npython_functions = [\"test_*\"]\naddopts = [\n    \"--strict-markers\",\n    \"--disable-warnings\",\n    \"-v\"\n]\nasyncio_mode = \"auto\"\n","size_bytes":2108},"replit.md":{"content":"# Telegram Channel Management Bot\n\nA comprehensive Telegram bot for channel management, view boosting, and live stream automation using Python, aiogram, and Telethon.\n\n## üî• CRITICAL DATABASE RULES - READ FIRST! üî•\n\n**MANDATORY RULE BOOK FOR ALL AGENTS:**\n\n1. **üö® NEVER USE REPLIT DATABASE** - This project MUST use external telethon_db only\n2. **‚úÖ ALWAYS USE TELETHON_DB** - Located at 18.234.56.13, database name: telethon_db\n3. **‚ö†Ô∏è DELETE ANY REPLIT DATABASE** - If created accidentally, delete it immediately\n4. **üìã DATABASE CONFIG SOURCE** - All database settings come from `data.env` file ONLY\n5. **üîí NO EXCEPTIONS** - External telethon_db is the ONLY allowed database\n\n### Database Configuration:\n- **Host:** 18.234.56.13 (from data.env)\n- **Database:** telethon_db (from data.env) \n- **User:** arcx (from data.env)\n- **Port:** 5432 (from data.env)\n- **Password:** From data.env file\n\n### What to do if Replit database exists:\n1. Delete it immediately\n2. Restart the bot workflow\n3. Verify logs show connection to 18.234.56.13/telethon_db\n4. Never create or provision Replit databases\n\n## üöÄ Features\n\n### Core Features\n- **Channel Management** - Add, configure, and manage multiple Telegram channels with universal link support\n- **View Boosting** - Automatic and manual view boosting with intelligent scheduling and rate limiting\n- **Live Stream Management** - Auto-join live streams and voice chats with monitoring capabilities\n- **Multi-Account Support** - Manage up to 100 Telegram accounts simultaneously with session recovery\n- **Emoji Reactions** - Automated emoji reactions with smart patterns and timing\n- **Real-time Analytics** - Comprehensive performance monitoring and reporting with export capabilities\n- **System Health** - Bot performance, database health, and resource monitoring with alerts\n\n### Advanced Features\n- **Smart Rate Limiting** - Intelligent API throttling to prevent flood errors\n- **Session Recovery** - Automatic recovery of orphaned session files\n- **Circuit Breakers** - Prevent cascade failures with automatic recovery\n- **Performance Monitoring** - Real-time system metrics and optimization\n- **Request Batching** - Optimize API calls through intelligent batching\n- **Caching Layer** - High-performance caching for faster responses\n- **Account Rotation** - Smart rotation of accounts to avoid detection\n\n### Technical Features\n- **External PostgreSQL** - Mandatory external database integration with connection pooling\n- **Async Architecture** - Full async/await implementation for high performance\n- **Modular Design** - Clean separation with feature-based modules\n- **Comprehensive Logging** - Detailed logging with structured format\n- **Error Recovery** - Robust error handling and automatic recovery\n- **Resource Management** - Automatic cleanup and optimization\n\n## üèóÔ∏è Architecture\n\n### Core Components\n\n#### Main Entry Point\n- **`main.py`** - Application entry point with initialization sequence\n- **`telegram_bot.py`** - Main bot controller and feature coordination\n\n#### Core System (`core/`)\n- **`config/config.py`** - Configuration management with database override\n- **`database/`**\n  - `unified_database.py` - Main database interface\n  - `coordinator.py` - Connection pooling and schema management\n  - `universal_access.py` - High-level database operations\n- **`bot/telegram_bot.py`** - Telegram client management and session handling\n- **`utils/`**\n  - `performance_monitor.py` - Real-time performance tracking\n  - `cache_manager.py` - High-performance caching system\n  - `circuit_breaker.py` - API reliability and failure prevention\n  - `request_batcher.py` - API call optimization\n  - `http_client.py` - HTTP client utilities\n\n#### Feature Modules (`features/`)\n\n##### Channel Management\n- **`handler.py`** - Main channel management logic\n- **`keyboards.py`** - UI keyboard layouts\n- **`utils.py`** - Channel validation and processing\n- **`core/channel_processor.py`** - Channel data processing\n- **`handlers/`** - Specialized handlers for add/list operations\n\n##### View Manager\n- **`handler.py`** - View boosting coordination\n- **`handlers/auto_boost.py`** - Automatic view boosting engine\n- **`handlers/manual_boost.py`** - Manual boost operations\n- **`utils/scheduler.py`** - Campaign scheduling system\n- **`utils/time_parse.py`** - Time parsing utilities\n\n##### Account Management\n- **`handler.py`** - Telegram account management with API support\n\n##### Analytics\n- **`handler.py`** - Comprehensive analytics and reporting system\n\n##### Emoji Reactions\n- **`handler.py`** - Automated emoji reaction system with pattern intelligence\n\n##### Live Management\n- **`handler.py`** - Live stream monitoring and auto-join functionality\n- **`keyboards.py`** - Live management UI components\n- **`states.py`** - FSM states for live operations\n- **`utils.py`** - Live stream utilities\n\n##### System Health\n- **`handler.py`** - System monitoring and health checks\n\n#### Central Routing\n- **`inline_handler.py`** - Central callback router for all features\n\n### Database Schema\n\nThe bot uses PostgreSQL with the following key tables:\n- **users** - User profiles and admin settings\n- **telegram_accounts** - Telegram account sessions and credentials\n- **channels** - Channel information and configuration\n- **view_boost_campaigns** - View boosting campaigns and progress\n- **emoji_reactions** - Emoji reaction configurations and history\n- **live_stream_participants** - Live stream participation tracking\n- **analytics_data** - Performance metrics and analytics\n- **system_logs** - System events and error logging\n\n### File Structure\n\n```\ntelegram-channel-management-bot/\n‚îú‚îÄ‚îÄ main.py                          # Application entry point\n‚îú‚îÄ‚îÄ telegram_bot.py                  # Main bot controller\n‚îú‚îÄ‚îÄ inline_handler.py               # Central callback router\n‚îú‚îÄ‚îÄ pyproject.toml                  # Project configuration & dependencies\n‚îú‚îÄ‚îÄ env                             # Bot tokens and API credentials  \n‚îú‚îÄ‚îÄ data.env                        # External database configuration\n‚îú‚îÄ‚îÄ sessions/                       # Telegram session files\n‚îÇ   ‚îî‚îÄ‚îÄ account_1.session          # Account session data\n‚îú‚îÄ‚îÄ core/                           # Core system components\n‚îÇ   ‚îú‚îÄ‚îÄ config/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.py              # Configuration manager\n‚îÇ   ‚îú‚îÄ‚îÄ database/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ unified_database.py    # Main database interface\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ coordinator.py         # Connection pooling\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ universal_access.py    # High-level operations\n‚îÇ   ‚îú‚îÄ‚îÄ bot/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ telegram_bot.py        # Client session management\n‚îÇ   ‚îî‚îÄ‚îÄ utils/\n‚îÇ       ‚îú‚îÄ‚îÄ performance_monitor.py  # System metrics\n‚îÇ       ‚îú‚îÄ‚îÄ cache_manager.py       # Caching layer\n‚îÇ       ‚îú‚îÄ‚îÄ circuit_breaker.py     # API reliability\n‚îÇ       ‚îú‚îÄ‚îÄ request_batcher.py     # Request optimization\n‚îÇ       ‚îî‚îÄ‚îÄ http_client.py         # HTTP utilities\n‚îî‚îÄ‚îÄ features/                       # Feature modules\n    ‚îú‚îÄ‚îÄ channel_management/\n    ‚îÇ   ‚îú‚îÄ‚îÄ handler.py             # Channel operations\n    ‚îÇ   ‚îú‚îÄ‚îÄ keyboards.py           # UI components\n    ‚îÇ   ‚îú‚îÄ‚îÄ utils.py               # Channel validation\n    ‚îÇ   ‚îú‚îÄ‚îÄ core/\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ channel_processor.py\n    ‚îÇ   ‚îî‚îÄ‚îÄ handlers/\n    ‚îÇ       ‚îú‚îÄ‚îÄ add_channel.py\n    ‚îÇ       ‚îî‚îÄ‚îÄ list_channels.py\n    ‚îú‚îÄ‚îÄ view_manager/\n    ‚îÇ   ‚îú‚îÄ‚îÄ handler.py             # View boost coordination\n    ‚îÇ   ‚îú‚îÄ‚îÄ handlers/\n    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auto_boost.py      # Auto boost engine\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ manual_boost.py    # Manual operations\n    ‚îÇ   ‚îî‚îÄ‚îÄ utils/\n    ‚îÇ       ‚îú‚îÄ‚îÄ scheduler.py       # Campaign scheduling\n    ‚îÇ       ‚îî‚îÄ‚îÄ time_parse.py      # Time utilities\n    ‚îú‚îÄ‚îÄ account_management/\n    ‚îÇ   ‚îî‚îÄ‚îÄ handler.py             # Account management\n    ‚îú‚îÄ‚îÄ analytics/\n    ‚îÇ   ‚îî‚îÄ‚îÄ handler.py             # Analytics & reporting\n    ‚îú‚îÄ‚îÄ emoji_reactions/\n    ‚îÇ   ‚îî‚îÄ‚îÄ handler.py             # Emoji automation\n    ‚îú‚îÄ‚îÄ live_management/\n    ‚îÇ   ‚îú‚îÄ‚îÄ handler.py             # Live stream management\n    ‚îÇ   ‚îú‚îÄ‚îÄ keyboards.py           # Live UI components\n    ‚îÇ   ‚îú‚îÄ‚îÄ states.py              # FSM states\n    ‚îÇ   ‚îî‚îÄ‚îÄ utils.py               # Live utilities\n    ‚îî‚îÄ‚îÄ system_health/\n        ‚îî‚îÄ‚îÄ handler.py             # Health monitoring\n```\n\n## üîß Technical Implementation\n\n### Dependencies (pyproject.toml)\n- **aiogram 3.22.0+** - Modern Telegram Bot framework\n- **telethon 1.40.0+** - Telegram client library for advanced operations\n- **asyncpg 0.29.0+** - High-performance async PostgreSQL driver\n- **psycopg2-binary 2.9.10+** - PostgreSQL adapter\n- **python-dotenv 1.1.1+** - Environment variable management\n- **psutil 7.0.0+** - System monitoring\n- **pytz 2025.2** - Timezone handling\n- **py-tgcalls 2.2.6+** - Voice call handling\n- **aiofiles 24.1.0+** - Async file operations\n- **cryptography 42.0.0+** - Cryptographic operations\n- **pydantic 2.5.0+** - Data validation\n- **httpx 0.26.0+** - HTTP client for API calls\n\n### Configuration Files\n\n#### Environment Variables (`env`)\n- BOT_TOKEN - Telegram bot token\n- DEFAULT_API_ID - Telegram API ID\n- DEFAULT_API_HASH - Telegram API hash\n- ADMIN_IDS - Comma-separated admin user IDs\n\n#### Database Configuration (`data.env`)\n- DB_HOST=18.234.56.13 - External PostgreSQL host\n- DB_NAME=telethon_db - Database name\n- DB_USER=arcx - Database user\n- DB_PASSWORD - Database password\n- Performance optimization settings for pools, timeouts, and rate limits\n\n### Performance Optimizations\n\n#### Rate Limiting\n- 30 calls per minute per account (optimized from 20)\n- 750 calls per hour per account (optimized from 500)\n- Intelligent throttling to prevent API floods\n\n#### Database Optimizations\n- Connection pooling (10-50 connections)\n- Async query execution\n- Schema optimization with proper indexes\n- Connection health monitoring\n\n#### Request Optimization\n- Request batching for efficiency\n- Circuit breakers for reliability\n- Smart caching layer (5-minute TTL)\n- HTTP/2 support with keepalive\n\n#### System Performance\n- Reduced delays (0.5-2s vs 1-5s default)\n- Parallel handler initialization\n- Async task management\n- Resource cleanup automation\n\n## üö® Current Status\n\n### Active Features\n- Channel management with universal link support ‚úÖ\n- Account management with session recovery ‚úÖ  \n- View boosting with auto/manual modes ‚úÖ\n- Analytics with comprehensive reporting ‚úÖ\n- Emoji reactions with smart patterns ‚úÖ\n- Live stream monitoring and auto-join ‚úÖ\n- System health monitoring ‚úÖ\n\n### Known Issues (from logs)\n- Missing 'lm_select_channels' callback handler in live management\n- Some callback routing warnings in inline_handler.py\n\n### Performance Metrics\n- Bot startup time: ~20-30 seconds\n- Database connection: External PostgreSQL at 18.234.56.13\n- Active workflow: \"Telegram Bot Server\" running on port 5000\n- Session files: 1 active account session\n\n## üîÑ Recent Changes (Last Updated: September 2, 2025)\n\n### Architecture Improvements\n- Implemented central inline callback routing system\n- Added comprehensive database schema with proper relationships\n- Enhanced error handling and logging throughout all modules\n- Implemented performance monitoring and optimization layers\n\n### Feature Enhancements  \n- Channel management with universal link parsing\n- Advanced view boosting with scheduling capabilities\n- Live stream auto-join with intelligent monitoring\n- Comprehensive analytics with export functionality\n- Smart emoji reaction system with natural patterns\n\n### Performance Optimizations\n- Reduced API call delays for faster operations\n- Implemented connection pooling for database efficiency\n- Added caching layer for frequently accessed data\n- Enhanced rate limiting to maximize API usage\n\n## üë§ User Preferences\n\n### Development Style\n- Modular architecture with clear separation of concerns\n- Comprehensive logging with emoji indicators for easy debugging\n- Async/await patterns throughout for performance\n- Type hints and validation using Pydantic\n- External database integration (mandatory requirement)\n\n### Code Conventions\n- Snake_case for functions and variables\n- PascalCase for classes\n- Descriptive docstrings for all modules\n- Structured error handling with specific exceptions\n- Performance-focused implementation with monitoring\n","size_bytes":12550},"telegram_bot.py":{"content":"\"\"\"\nTelegram Bot Core Implementation\nMain bot controller with feature routing and session management\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, Any, Optional\n\nfrom aiogram import Bot, Dispatcher, types\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.enums import ParseMode\nfrom aiogram.filters import Command, CommandStart\nfrom aiogram.fsm.storage.memory import MemoryStorage\nfrom aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\nfrom core.bot.telegram_bot import TelegramBotCore\nfrom inline_handler import InlineHandler\n\n# Import all feature handlers\nfrom features.channel_management.handler import ChannelManagementHandler\nfrom features.view_manager.handler import ViewManagerHandler\nfrom features.emoji_reactions.handler import EmojiReactionsHandler\nfrom features.analytics.handler import AnalyticsHandler\nfrom features.account_management.handler import AccountManagementHandler\nfrom features.system_health.handler import SystemHealthHandler\nfrom features.live_management.handler import LiveManagementHandler\nfrom features.poll_manager.handler import PollManagerHandler\n\nlogger = logging.getLogger(__name__)\n\n\nclass TelegramBot:\n    \"\"\"Main Telegram Bot Controller\"\"\"\n    \n    def __init__(self, config: Config, db_manager: DatabaseManager):\n        self.config = config\n        self.db_manager = db_manager\n        self.bot: Optional[Bot] = None\n        self.dp: Optional[Dispatcher] = None\n        self.handlers: Dict[str, Any] = {}\n        self.bot_core: Optional[TelegramBotCore] = None\n        \n    async def initialize(self):\n        \"\"\"Initialize bot and all handlers\"\"\"\n        try:\n            # Initialize bot instance\n            self.bot = Bot(\n                token=self.config.BOT_TOKEN,\n                default=DefaultBotProperties(parse_mode=ParseMode.HTML)\n            )\n            \n            # Initialize dispatcher with memory storage\n            storage = MemoryStorage()\n            self.dp = Dispatcher(storage=storage)\n            \n            # Initialize bot core for Telethon clients\n            self.bot_core = TelegramBotCore(self.config, self.db_manager)\n            # Mark as shared instance using setattr to avoid type checker issues\n            setattr(self.bot_core, '_shared', True)\n            await self.bot_core.initialize()\n            \n            # Initialize inline handler\n            self.inline_handler = InlineHandler(self.bot, self.db_manager, self.config)\n            \n            # Initialize feature handlers\n            await self._initialize_handlers()\n            \n            # Register routes\n            self._register_routes()\n            \n            logger.info(\"‚úÖ Bot initialization completed\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize bot: {e}\")\n            raise\n    \n    async def _initialize_handlers(self):\n        \"\"\"Initialize all feature handlers in parallel for faster startup\"\"\"\n        try:\n            # Ensure bot instance is available\n            if self.bot is None:\n                raise RuntimeError(\"Bot instance not initialized\")\n                \n            # Create all handler instances first (fast) - pass bot_core to handlers that need it\n            self.handlers['channel_management'] = ChannelManagementHandler(\n                self.bot, self.db_manager, self.config, self.bot_core\n            )\n            self.handlers['view_manager'] = ViewManagerHandler(\n                self.bot, self.db_manager, self.config, self.bot_core\n            )\n            self.handlers['emoji_reactions'] = EmojiReactionsHandler(\n                self.bot, self.db_manager, self.config, self.bot_core\n            )\n            self.handlers['analytics'] = AnalyticsHandler(\n                self.bot, self.db_manager, self.config\n            )\n            self.handlers['account_management'] = AccountManagementHandler(\n                self.bot, self.db_manager, self.config, self.bot_core\n            )\n            self.handlers['system_health'] = SystemHealthHandler(\n                self.bot, self.db_manager, self.config\n            )\n            self.handlers['live_management'] = LiveManagementHandler(\n                self.bot, self.db_manager, self.config, self.bot_core\n            )\n            self.handlers['poll_manager'] = PollManagerHandler(\n                self.bot, self.db_manager, self.config, self.bot_core\n            )\n            \n            # Initialize all handlers in parallel (much faster)\n            initialization_tasks = []\n            for handler_name, handler in self.handlers.items():\n                if hasattr(handler, 'initialize'):\n                    initialization_tasks.append(self._initialize_single_handler(handler_name, handler))\n            \n            # Wait for all initializations to complete simultaneously\n            if initialization_tasks:\n                await asyncio.gather(*initialization_tasks)\n                \n        except Exception as e:\n            logger.error(f\"Failed to initialize handlers: {e}\")\n            raise\n    \n    async def _initialize_single_handler(self, handler_name: str, handler):\n        \"\"\"Initialize a single handler with logging\"\"\"\n        try:\n            await handler.initialize()\n            logger.info(f\"‚úÖ {handler_name} handler initialized\")\n        except Exception as e:\n            logger.error(f\"‚ùå Failed to initialize {handler_name}: {e}\")\n            raise\n    \n    def _register_routes(self):\n        \"\"\"Register all bot routes and handlers\"\"\"\n        try:\n            # Ensure dispatcher is available\n            if self.dp is None:\n                raise RuntimeError(\"Dispatcher not initialized\")\n                \n            # Register start command\n            self.dp.message.register(self._start_command, CommandStart())\n            self.dp.message.register(self._help_command, Command(\"help\"))\n            \n            # Register feature handlers with dispatcher (for non-callback handlers like message handlers)\n            for handler_name, handler in self.handlers.items():\n                if hasattr(handler, 'register_handlers'):\n                    handler.register_handlers(self.dp)\n                    logger.info(f\"‚úÖ {handler_name} routes registered\")\n            \n            # Register inline callback handler AFTER feature handlers to avoid conflicts\n            self.dp.callback_query.register(\n                self.inline_handler.handle_callback,\n                lambda c: True\n            )\n            \n            # Register callback prefixes with inline handler for proper routing\n            self.inline_handler.register_handler(\"account_manager\", self.handlers['account_management'])\n            self.inline_handler.register_handler(\"channel_manager\", self.handlers['channel_management'])\n            self.inline_handler.register_handler(\"views_manager\", self.handlers['view_manager']) \n            self.inline_handler.register_handler(\"poll_manager\", self.handlers['poll_manager'])\n            self.inline_handler.register_handler(\"live_manager\", self.handlers['live_management'])\n            self.inline_handler.register_handler(\"analytics\", self.handlers['analytics'])\n            self.inline_handler.register_handler(\"emoji_reaction\", self.handlers['emoji_reactions'])\n            \n            logger.info(\"‚úÖ All routes registered successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to register routes: {e}\")\n            raise\n    \n    async def _start_command(self, message: Message):\n        \"\"\"Handle /start command\"\"\"\n        try:\n            if message.from_user is None:\n                logger.warning(\"Received message without user information\")\n                return\n                \n            user_id = message.from_user.id\n            username = message.from_user.username or \"Unknown\"\n            \n            # Log user interaction\n            logger.info(f\"üë§ USER INTERACTION: User {user_id} (@{username}) sent /start command\")\n            \n            # Check if user is admin\n            is_admin = user_id in self.config.ADMIN_IDS\n            \n            # Store user info in database\n            await self.db_manager.execute_query(\n                \"\"\"\n                INSERT INTO users (user_id, username, is_admin, first_seen, last_seen)\n                VALUES ($1, $2, $3, NOW(), NOW())\n                ON CONFLICT (user_id) \n                DO UPDATE SET username = $2, last_seen = NOW()\n                \"\"\",\n                user_id, username, is_admin\n            )\n            \n            # Create welcome message\n            welcome_text = self._get_welcome_message(is_admin, username)\n            keyboard = self._get_main_keyboard(is_admin)\n            \n            logger.info(f\"ü§ñ BOT RESPONSE: Sending welcome message to user {user_id}\")\n            await message.answer(welcome_text, reply_markup=keyboard)\n            \n        except Exception as e:\n            logger.error(f\"Error in start command: {e}\")\n            await message.answer(\"‚ùå An error occurred. Please try again later.\")\n    \n    async def _help_command(self, message: Message):\n        \"\"\"Handle /help command\"\"\"\n        if message.from_user is None:\n            logger.warning(\"Received help command without user information\")\n            return\n            \n        user_id = message.from_user.id\n        username = message.from_user.username or \"Unknown\"\n        \n        logger.info(f\"üë§ USER INTERACTION: User {user_id} (@{username}) sent /help command\")\n        \n        help_text = \"\"\"\nüî• <b>ArcX Bot - Help Documentation</b>\n\n<b>üìã Feature Guide:</b>\n\nüì± <b>[Account Manager]</b>\n‚Ä¢ Add accounts with default/custom API\n‚Ä¢ Remove accounts and session cleanup\n‚Ä¢ List accounts with detailed info\n‚Ä¢ Refresh account status\n\nüì∫ <b>[Channel Manager]</b> \n‚Ä¢ Universal link handler for any channel type\n‚Ä¢ Add/remove channels from all accounts\n‚Ä¢ View channel statistics and member count\n‚Ä¢ Generate unique channel IDs for operations\n\nüöÄ <b>[Views Manager]</b>\n‚Ä¢ Auto Boost: Configure timing, cooldown, view counts\n‚Ä¢ Manual Boost: Instant view boosting\n‚Ä¢ Advanced scheduling with custom time formats\n‚Ä¢ Per-channel configuration settings\n\nüó≥Ô∏è <b>[Poll Manager]</b>\n‚Ä¢ Universal poll link handler\n‚Ä¢ Vote with multiple accounts\n‚Ä¢ Select voting options and distribution\n‚Ä¢ Real-time voting progress tracking\n\nüéôÔ∏è <b>[Live Manager]</b>\n‚Ä¢ Auto-join live streams and voice chats\n‚Ä¢ WebRTC audio streaming (silent audio)\n‚Ä¢ Random hand raising and interactions\n‚Ä¢ Configurable participation settings\n\nüìä <b>[Analytics]</b>\n‚Ä¢ Per-channel performance metrics\n‚Ä¢ System health and resource monitoring\n‚Ä¢ Engine status tracking\n‚Ä¢ Database connection statistics\n\nüòÄ <b>[Emoji Reaction]</b>\n‚Ä¢ React to latest messages automatically\n‚Ä¢ Random emoji distribution strategies\n‚Ä¢ Custom reaction counts per message\n‚Ä¢ Multi-account reaction coordination\n\n<b>üë®‚Äçüíª Developer:</b> @damn_itd_ravan\n        \"\"\"\n        \n        logger.info(f\"ü§ñ BOT RESPONSE: Sending help message to user {user_id}\")\n        await message.answer(help_text)\n    \n    def _get_welcome_message(self, is_admin: bool, username: str) -> str:\n        \"\"\"Generate welcome message based on user type\"\"\"\n        if is_admin:\n            return f\"\"\"\nüî• <b>Welcome to ArcX Bot, {username}!</b>\n\nüöÄ <b>Advanced Telegram Channel Management System</b>\n\n‚ú® You have full access to all premium features. \nIf you need help with any feature, use /help for detailed documentation.\n\nSelect a feature below:\n            \"\"\"\n        else:\n            return f\"\"\"\nüö´ <b>Access Restricted</b>\n\nHi {username}! This is a premium Telegram channel management bot.\n\nü§ñ <b>ArcX Bot</b> - Advanced Channel Management\n‚Ä¢ Multi-account automation\n‚Ä¢ View boosting systems  \n‚Ä¢ Live stream management\n‚Ä¢ Advanced analytics\n\nThis bot is for authorized users only.\n\nüë®‚Äçüíª Developer: @damn_itd_ravan\n            \"\"\"\n    \n    def _get_main_keyboard(self, is_admin: bool) -> InlineKeyboardMarkup:\n        \"\"\"Generate main menu keyboard based on user type\"\"\"\n        if not is_admin:\n            # Non-admin gets restricted access - only show contact info\n            return InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"üë®‚Äçüíª Contact Developer\", url=\"https://t.me/damn_itd_ravan\")]\n            ])\n        \n        # Admin gets full access with ArcX branded layout\n        buttons = []\n        \n        # First row - Account & Channel management\n        buttons.append([\n            InlineKeyboardButton(text=\"[üì± Account Manager]\", callback_data=\"account_manager\"),\n            InlineKeyboardButton(text=\"[üì∫ Channel Manager]\", callback_data=\"channel_manager\")\n        ])\n        \n        # Second row - Views & Poll management  \n        buttons.append([\n            InlineKeyboardButton(text=\"[üöÄ Views Manager]\", callback_data=\"views_manager\"),\n            InlineKeyboardButton(text=\"[üó≥Ô∏è Poll Manager]\", callback_data=\"poll_manager\")\n        ])\n        \n        # Third row - Live & Analytics\n        buttons.append([\n            InlineKeyboardButton(text=\"[üéôÔ∏è Live Manager]\", callback_data=\"live_manager\"),\n            InlineKeyboardButton(text=\"[üìä Analytics]\", callback_data=\"analytics\")\n        ])\n        \n        # Fourth row - Emoji reactions (full width)\n        buttons.append([\n            InlineKeyboardButton(text=\"[üòÄ Emoji Reaction]\", callback_data=\"emoji_reaction\")\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    async def start(self):\n        \"\"\"Start the bot\"\"\"\n        try:\n            if self.dp is None or self.bot is None:\n                raise RuntimeError(\"Bot or dispatcher not initialized\")\n                \n            logger.info(\"üéØ Starting bot polling...\")\n            await self.dp.start_polling(self.bot)\n        except Exception as e:\n            logger.error(f\"Error during polling: {e}\")\n            raise\n    \n    async def shutdown(self):\n        \"\"\"Shutdown the bot gracefully\"\"\"\n        try:\n            logger.info(\"‚èπÔ∏è Shutting down bot...\")\n            \n            # Close all handlers\n            for handler_name, handler in self.handlers.items():\n                if hasattr(handler, 'shutdown'):\n                    await handler.shutdown()\n            \n            # Shutdown bot core (Telethon clients)\n            if self.bot_core:\n                await self.bot_core.shutdown()\n            \n            # Close bot session\n            if self.bot:\n                await self.bot.session.close()\n            \n            logger.info(\"‚úÖ Bot shutdown completed\")\n            \n        except Exception as e:\n            logger.error(f\"Error during shutdown: {e}\")\n","size_bytes":14933},"core/__init__.py":{"content":"\"\"\"\nCore system components for Telegram Channel Management Bot\n\"\"\"\n\n__version__ = \"1.0.0\"\n__author__ = \"Channel Bot Team\"\n","size_bytes":122},"features/__init__.py":{"content":"\"\"\"\nBot features module\nContains all modular bot features\n\"\"\"\n\n__version__ = \"1.0.0\"\n","size_bytes":85},"core/bot/__init__.py":{"content":"\"\"\"\nBot core module\n\"\"\"\n\nfrom .telegram_bot import TelegramBotCore\n\n__all__ = ['TelegramBotCore']\n","size_bytes":98},"core/bot/telegram_bot.py":{"content":"\"\"\"\nTelegram Bot Core\nCore bot functionality and session management\n\"\"\"\n\nimport asyncio\nimport logging\nimport os\nfrom typing import Dict, Any, Optional, List\nfrom datetime import datetime\n\nfrom telethon import TelegramClient, events\nfrom telethon.errors import SessionPasswordNeededError, PhoneCodeInvalidError\nfrom telethon.tl import types, functions\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\n\nlogger = logging.getLogger(__name__)\n\n\nclass TelegramBotCore:\n    \"\"\"Core Telegram bot functionality for client management\"\"\"\n    \n    def __init__(self, config: Config, db_manager: DatabaseManager):\n        self.config = config\n        self.db = db_manager\n        self.clients: Dict[int, TelegramClient] = {}\n        self.client_sessions: Dict[int, str] = {}\n        self._rate_limiters: Dict[int, Dict[str, Any]] = {}\n        \n    async def initialize(self):\n        \"\"\"Initialize bot core\"\"\"\n        try:\n            logger.info(\"üîß Initializing Telegram bot core...\")\n            \n            # Ensure sessions directory exists\n            sessions_dir = \"sessions\"\n            if not os.path.exists(sessions_dir):\n                os.makedirs(sessions_dir)\n                logger.info(f\"‚úÖ Created sessions directory: {sessions_dir}\")\n            \n            # Load existing sessions\n            await self._load_existing_sessions()\n            \n            logger.info(\"‚úÖ Telegram bot core initialized\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize bot core: {e}\")\n            raise\n    \n    async def _load_existing_sessions(self):\n        \"\"\"Load existing Telegram sessions\"\"\"\n        try:\n            # First, check for orphaned session files and recover them\n            await self._recover_orphaned_sessions()\n            \n            # Get all verified accounts from database\n            accounts = await self.db.fetch_all(\n                \"SELECT * FROM telegram_accounts WHERE is_verified = TRUE AND is_active = TRUE\"\n            )\n            \n            loaded_count = 0\n            for account in accounts:\n                try:\n                    success = await self._create_client_session(account)\n                    if success:\n                        loaded_count += 1\n                except Exception as e:\n                    logger.error(f\"Failed to load session for account {account['id']}: {e}\")\n            \n            logger.info(f\"‚úÖ Loaded {loaded_count} existing sessions\")\n            \n        except Exception as e:\n            logger.error(f\"Error loading existing sessions: {e}\")\n    \n    async def _recover_orphaned_sessions(self):\n        \"\"\"Recover session files that exist but aren't in the database\"\"\"\n        try:\n            import glob\n            # Get all .session files (including temp sessions)\n            session_files = glob.glob(\"sessions/*.session\")\n            \n            for session_file in session_files:\n                try:\n                    # Handle different session file name patterns\n                    filename = session_file.split('/')[-1].replace('.session', '')\n                    \n                    if filename.startswith('account_'):\n                        # Standard account session\n                        account_id = int(filename.split('account_')[1])\n                    elif filename.startswith('temp_'):\n                        # Temporary session - extract phone from session if possible\n                        account_id = None  # Will be assigned during recovery\n                    else:\n                        logger.warning(f\"Unknown session file format: {session_file}\")\n                        continue\n                    \n                    # Check if this session is already in database (only for known account_id)\n                    if account_id:\n                        existing = await self.db.fetch_one(\n                            \"SELECT id FROM telegram_accounts WHERE id = $1\", account_id\n                        )\n                        if existing:\n                            continue  # Already in database\n                    \n                    # Session file exists but no database record - recover it\n                    await self._recover_session_from_file(session_file)\n                        \n                except Exception as e:\n                    logger.error(f\"Error checking session file {session_file}: {e}\")\n                    \n        except Exception as e:\n            logger.error(f\"Error recovering orphaned sessions: {e}\")\n    \n    async def _recover_session_from_file(self, session_file: str):\n        \"\"\"Recover account data from existing session file\"\"\"\n        try:\n            # Try to connect with the session file to get account info\n            temp_client = TelegramClient(\n                session_file.replace('.session', ''),\n                self.config.DEFAULT_API_ID,\n                self.config.DEFAULT_API_HASH\n            )\n            \n            await temp_client.connect()\n            \n            if await temp_client.is_user_authorized():\n                # Get user info from the session\n                me = await temp_client.get_me()\n                \n                # Re-add the account to the database with username and unique_id\n                # Note: user_id will be NULL initially and set when user first interacts\n                username = me.username if me.username else None\n                import uuid\n                unique_id = str(uuid.uuid4())\n                \n                # Insert or update the account in database\n                await self.db.execute_query(\n                    \"\"\"\n                    INSERT INTO telegram_accounts \n                    (phone_number, api_id, api_hash, username, unique_id, is_verified, is_active, session_data, created_at, updated_at)\n                    VALUES ($1, $2, $3, $4, $5, TRUE, TRUE, '', NOW(), NOW())\n                    ON CONFLICT (phone_number) DO UPDATE SET\n                    username = $4, unique_id = $5, is_verified = TRUE, is_active = TRUE, updated_at = NOW()\n                    \"\"\",\n                    me.phone, self.config.DEFAULT_API_ID, self.config.DEFAULT_API_HASH, username, unique_id\n                )\n                \n                logger.info(f\"üîÑ RECOVERED: Session for account {me.phone}\")\n                \n            await temp_client.disconnect()\n            \n        except Exception as e:\n            logger.error(f\"Failed to recover session from {session_file}: {e}\")\n    \n    async def _create_client_session(self, account: Dict[str, Any]) -> bool:\n        \"\"\"Create Telegram client session for account\"\"\"\n        try:\n            account_id = account['id']\n            \n            # Create client\n            client = TelegramClient(\n                f\"sessions/account_{account_id}\",\n                account['api_id'],\n                account['api_hash']\n            )\n            \n            # Connect and verify session\n            await client.connect()\n            \n            if await client.is_user_authorized():\n                self.clients[account_id] = client\n                self.client_sessions[account_id] = account['session_data']\n                \n                # Initialize rate limiter for this account\n                self._rate_limiters[account_id] = {\n                    'calls_this_minute': 0,\n                    'calls_this_hour': 0,\n                    'last_minute_reset': datetime.now(),\n                    'last_hour_reset': datetime.now()\n                }\n                \n                logger.info(f\"‚úÖ Session loaded for account {account['phone_number']}\")\n                return True\n            else:\n                await client.disconnect()\n                logger.warning(f\"‚ö†Ô∏è Session not authorized for account {account['phone_number']}\")\n                return False\n                \n        except Exception as e:\n            logger.error(f\"Error creating client session: {e}\")\n            return False\n    \n    async def add_new_account(self, user_id: int, phone_number: str, \n                            api_id: int = None, api_hash: str = None) -> Dict[str, Any]:\n        \"\"\"Add new Telegram account\"\"\"\n        try:\n            # Use default API credentials if not provided\n            if not api_id:\n                api_id = self.config.DEFAULT_API_ID\n            if not api_hash:\n                api_hash = self.config.DEFAULT_API_HASH\n            \n            # Add account to database\n            result = await self.db.add_telegram_account(user_id, phone_number, api_id, api_hash)\n            if not result:\n                return {'success': False, 'error': 'Failed to add account to database'}\n            \n            account_id = result\n            \n            # Create Telegram client\n            client = TelegramClient(\n                f\"sessions/account_{account_id}\",\n                api_id,\n                api_hash\n            )\n            \n            # Connect and send verification code\n            await client.connect()\n            \n            if not await client.is_user_authorized():\n                # Request verification code\n                sent_code = await client.send_code_request(phone_number)\n                \n                return {\n                    'success': True,\n                    'account_id': account_id,\n                    'phone_code_hash': sent_code.phone_code_hash,\n                    'message': 'Verification code sent. Please provide the code to complete setup.'\n                }\n            else:\n                # Already authorized - save session\n                session_data = client.session.save()\n                await self.db.update_account_session(account_id, session_data)\n                \n                self.clients[account_id] = client\n                self.client_sessions[account_id] = session_data\n                \n                return {\n                    'success': True,\n                    'account_id': account_id,\n                    'message': 'Account added and authorized successfully'\n                }\n                \n        except Exception as e:\n            logger.error(f\"Error adding new account: {e}\")\n            return {'success': False, 'error': str(e)}\n    \n    async def verify_account_code(self, account_id: int, code: str, \n                                phone_code_hash: str, password: str = None) -> Dict[str, Any]:\n        \"\"\"Verify account with code and optional 2FA password\"\"\"\n        try:\n            # Get account info\n            account = await self.db.get_account_by_id(account_id)\n            if not account:\n                return {'success': False, 'error': 'Account not found'}\n            \n            # Get or create client\n            client = self.clients.get(account_id)\n            if not client:\n                client = TelegramClient(\n                    f\"sessions/account_{account_id}\",\n                    account['api_id'],\n                    account['api_hash']\n                )\n                await client.connect()\n            \n            try:\n                # Sign in with code\n                user = await client.sign_in(account['phone_number'], code, phone_code_hash=phone_code_hash)\n                \n            except SessionPasswordNeededError:\n                # 2FA is enabled\n                if not password:\n                    return {\n                        'success': False,\n                        'requires_password': True,\n                        'error': 'Two-factor authentication is enabled. Please provide your password.'\n                    }\n                \n                # Sign in with password\n                user = await client.sign_in(password=password)\n            \n            except PhoneCodeInvalidError:\n                return {'success': False, 'error': 'Invalid verification code'}\n            \n            # Save session data\n            session_data = client.session.save()\n            await self.db.update_account_session(account_id, session_data)\n            \n            # Store client\n            self.clients[account_id] = client\n            self.client_sessions[account_id] = session_data\n            \n            # Initialize rate limiter\n            self._rate_limiters[account_id] = {\n                'calls_this_minute': 0,\n                'calls_this_hour': 0,\n                'last_minute_reset': datetime.now(),\n                'last_hour_reset': datetime.now()\n            }\n            \n            logger.info(f\"‚úÖ Account {account['phone_number']} verified successfully\")\n            \n            return {\n                'success': True,\n                'user_info': {\n                    'id': user.id,\n                    'username': user.username,\n                    'first_name': user.first_name,\n                    'last_name': user.last_name\n                },\n                'message': 'Account verified and ready to use'\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error verifying account code: {e}\")\n            return {'success': False, 'error': str(e)}\n    \n    async def get_client(self, account_id: int) -> Optional[TelegramClient]:\n        \"\"\"Get Telegram client for account\"\"\"\n        client = self.clients.get(account_id)\n        if client and await client.is_user_authorized():\n            return client\n        return None\n    \n    async def check_rate_limit(self, account_id: int) -> bool:\n        \"\"\"Check if account has exceeded rate limits\"\"\"\n        if account_id not in self._rate_limiters:\n            return True\n        \n        limiter = self._rate_limiters[account_id]\n        now = datetime.now()\n        \n        # Reset minute counter if needed\n        if (now - limiter['last_minute_reset']).total_seconds() >= 60:\n            limiter['calls_this_minute'] = 0\n            limiter['last_minute_reset'] = now\n        \n        # Reset hour counter if needed\n        if (now - limiter['last_hour_reset']).total_seconds() >= 3600:\n            limiter['calls_this_hour'] = 0\n            limiter['last_hour_reset'] = now\n        \n        # Check limits\n        if limiter['calls_this_minute'] >= self.config.CALLS_PER_MINUTE_PER_ACCOUNT:\n            return False\n        \n        if limiter['calls_this_hour'] >= self.config.CALLS_PER_HOUR_PER_ACCOUNT:\n            return False\n        \n        return True\n    \n    async def increment_rate_limit(self, account_id: int):\n        \"\"\"Increment rate limit counters for account\"\"\"\n        if account_id in self._rate_limiters:\n            self._rate_limiters[account_id]['calls_this_minute'] += 1\n            self._rate_limiters[account_id]['calls_this_hour'] += 1\n    \n    async def get_account_info(self, account_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get account information\"\"\"\n        try:\n            client = await self.get_client(account_id)\n            if not client:\n                return None\n            \n            # Get user info from Telegram\n            me = await client.get_me()\n            \n            # Get database info\n            db_account = await self.db.get_account_by_id(account_id)\n            \n            return {\n                'account_id': account_id,\n                'phone_number': db_account['phone_number'],\n                'telegram_id': me.id,\n                'username': me.username,\n                'first_name': me.first_name,\n                'last_name': me.last_name,\n                'is_verified': db_account['is_verified'],\n                'is_active': db_account['is_active'],\n                'last_login': db_account['last_login'],\n                'rate_limit_status': self._rate_limiters.get(account_id, {})\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting account info: {e}\")\n            return None\n    \n    async def get_all_active_clients(self) -> List[Dict[str, Any]]:\n        \"\"\"Get all active client information\"\"\"\n        active_clients = []\n        \n        for account_id, client in self.clients.items():\n            try:\n                if await client.is_user_authorized():\n                    info = await self.get_account_info(account_id)\n                    if info:\n                        active_clients.append(info)\n            except Exception as e:\n                logger.error(f\"Error checking client {account_id}: {e}\")\n        \n        return active_clients\n    \n    async def disconnect_account(self, account_id: int) -> bool:\n        \"\"\"Disconnect and remove account session\"\"\"\n        try:\n            if account_id in self.clients:\n                client = self.clients[account_id]\n                await client.disconnect()\n                del self.clients[account_id]\n            \n            if account_id in self.client_sessions:\n                del self.client_sessions[account_id]\n            \n            if account_id in self._rate_limiters:\n                del self._rate_limiters[account_id]\n            \n            # Deactivate in database\n            await self.db.deactivate_account(account_id)\n            \n            logger.info(f\"‚úÖ Account {account_id} disconnected\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error disconnecting account {account_id}: {e}\")\n            return False\n    \n    async def shutdown(self):\n        \"\"\"Shutdown all clients\"\"\"\n        try:\n            logger.info(\"‚èπÔ∏è Shutting down all Telegram clients...\")\n            \n            # Disconnect all clients with proper task cleanup\n            for account_id, client in self.clients.items():\n                try:\n                    if client.is_connected():\n                        await client.disconnect()\n                        # Give a small delay to allow proper cleanup\n                        await asyncio.sleep(0.1)\n                except Exception as e:\n                    logger.error(f\"Error disconnecting client {account_id}: {e}\")\n            \n            # Clear all data\n            self.clients.clear()\n            self.client_sessions.clear()\n            self._rate_limiters.clear()\n            \n            logger.info(\"‚úÖ All Telegram clients shut down\")\n            \n        except Exception as e:\n            logger.error(f\"Error during bot core shutdown: {e}\")\n","size_bytes":18316},"core/config/__init__.py":{"content":"\"\"\"\nConfiguration management module\n\"\"\"\n\nfrom .config import Config\n\n__all__ = ['Config']\n","size_bytes":90},"core/config/config.py":{"content":"\"\"\"\nConfiguration Management and Database Override\nHandles environment variables and forces external PostgreSQL usage\n\"\"\"\n\nimport os\nimport sys\nimport logging\nfrom typing import List, Optional\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\nlogger = logging.getLogger(__name__)\n\n\nclass Config:\n    \"\"\"Configuration manager with mandatory external database override\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize configuration and override Replit database\"\"\"\n        self._load_environment_files()\n        self._override_replit_database()\n        self._validate_configuration()\n        \n    def _load_environment_files(self):\n        \"\"\"Load environment files in priority order\"\"\"\n        # Load env file first (bot configuration)\n        env_file = Path(\"env\")\n        if env_file.exists():\n            load_dotenv(env_file)\n            logger.info(\"‚úÖ Loaded env configuration\")\n        else:\n            logger.warning(\"‚ö†Ô∏è env file not found\")\n        \n        # Load data.env file (external database - MANDATORY)\n        data_env_file = Path(\"data.env\")\n        if data_env_file.exists():\n            load_dotenv(data_env_file, override=True)\n            logger.info(\"‚úÖ Loaded data.env configuration\")\n        else:\n            logger.error(\"‚ùå data.env file not found - External database required!\")\n            raise FileNotFoundError(\"data.env file is mandatory for external database\")\n    \n    def _override_replit_database(self):\n        \"\"\"Force removal of Replit database variables and ensure external PostgreSQL\"\"\"\n        # Remove Replit database environment variables\n        replit_db_vars = [\n            'REPLIT_DB_URL', 'REPLIT_DATABASE_URL', 'DATABASE_URL',\n            'PGHOST', 'PGPORT', 'PGDATABASE', 'PGUSER', 'PGPASSWORD'\n        ]\n        \n        for var in replit_db_vars:\n            if var in os.environ:\n                del os.environ[var]\n                logger.info(f\"üóëÔ∏è Removed Replit database variable: {var}\")\n        \n        # Verify external database configuration\n        required_db_vars = ['DB_HOST', 'DB_PORT', 'DB_NAME', 'DB_USER', 'DB_PASSWORD']\n        missing_vars = [var for var in required_db_vars if not os.getenv(var)]\n        \n        if missing_vars:\n            logger.error(f\"‚ùå Missing external database configuration: {missing_vars}\")\n            raise ValueError(f\"External database configuration incomplete: {missing_vars}\")\n        \n        logger.info(\"‚úÖ External PostgreSQL configuration verified\")\n    \n    def _validate_configuration(self):\n        \"\"\"Validate all required configuration values\"\"\"\n        required_vars = {\n            'BOT_TOKEN': 'Telegram bot token',\n            'DEFAULT_API_ID': 'Telegram API ID', \n            'DEFAULT_API_HASH': 'Telegram API hash',\n            'ADMIN_IDS': 'Admin user IDs'\n        }\n        \n        missing_vars = []\n        for var, description in required_vars.items():\n            if not os.getenv(var):\n                missing_vars.append(f\"{var} ({description})\")\n        \n        if missing_vars:\n            logger.error(f\"‚ùå Missing required configuration: {missing_vars}\")\n            raise ValueError(f\"Required configuration missing: {missing_vars}\")\n        \n        logger.info(\"‚úÖ Configuration validation completed\")\n    \n    # Bot Configuration\n    @property\n    def BOT_TOKEN(self) -> str:\n        \"\"\"Telegram bot token\"\"\"\n        return os.getenv('BOT_TOKEN', '')\n    \n    @property\n    def DEFAULT_API_ID(self) -> int:\n        \"\"\"Default Telegram API ID\"\"\"\n        return int(os.getenv('DEFAULT_API_ID', '0'))\n    \n    @property\n    def DEFAULT_API_HASH(self) -> str:\n        \"\"\"Default Telegram API hash\"\"\"\n        return os.getenv('DEFAULT_API_HASH', '')\n    \n    @property\n    def ADMIN_IDS(self) -> List[int]:\n        \"\"\"List of admin user IDs\"\"\"\n        admin_ids_str = os.getenv('ADMIN_IDS', '')\n        if not admin_ids_str:\n            return []\n        try:\n            return [int(uid.strip()) for uid in admin_ids_str.split(',') if uid.strip()]\n        except ValueError:\n            logger.error(\"Invalid ADMIN_IDS format\")\n            return []\n    \n    # External Database Configuration (MANDATORY)\n    @property\n    def DB_HOST(self) -> str:\n        \"\"\"External PostgreSQL host\"\"\"\n        return os.getenv('DB_HOST', '')\n    \n    @property\n    def DB_PORT(self) -> int:\n        \"\"\"External PostgreSQL port\"\"\"\n        return int(os.getenv('DB_PORT', '5432'))\n    \n    @property\n    def DB_NAME(self) -> str:\n        \"\"\"External PostgreSQL database name\"\"\"\n        return os.getenv('DB_NAME', '')\n    \n    @property\n    def DB_USER(self) -> str:\n        \"\"\"External PostgreSQL username\"\"\"\n        return os.getenv('DB_USER', '')\n    \n    @property\n    def DB_PASSWORD(self) -> str:\n        \"\"\"External PostgreSQL password\"\"\"\n        return os.getenv('DB_PASSWORD', '')\n    \n    @property\n    def DATABASE_URL(self) -> str:\n        \"\"\"Complete external database URL\"\"\"\n        return f\"postgresql://{self.DB_USER}:{self.DB_PASSWORD}@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}\"\n    \n    # Performance Settings\n    @property\n    def MAX_ACTIVE_CLIENTS(self) -> int:\n        \"\"\"Maximum number of active Telegram clients\"\"\"\n        return int(os.getenv('MAX_ACTIVE_CLIENTS', '100'))\n    \n    @property\n    def DB_POOL_SIZE(self) -> int:\n        \"\"\"Database connection pool size\"\"\"\n        return int(os.getenv('DB_POOL_SIZE', '5'))\n    \n    @property\n    def DB_MAX_POOL_SIZE(self) -> int:\n        \"\"\"Maximum database connection pool size\"\"\"\n        return int(os.getenv('DB_MAX_POOL_SIZE', '20'))\n    \n    @property\n    def DB_TIMEOUT(self) -> int:\n        \"\"\"Database connection timeout\"\"\"\n        return int(os.getenv('DB_TIMEOUT', '30'))\n    \n    # Rate Limiting\n    @property\n    def CALLS_PER_MINUTE_PER_ACCOUNT(self) -> int:\n        \"\"\"API calls per minute per account\"\"\"\n        return int(os.getenv('CALLS_PER_MINUTE_PER_ACCOUNT', '20'))\n    \n    @property\n    def CALLS_PER_HOUR_PER_ACCOUNT(self) -> int:\n        \"\"\"API calls per hour per account\"\"\"\n        return int(os.getenv('CALLS_PER_HOUR_PER_ACCOUNT', '500'))\n    \n    # Processing Settings\n    @property\n    def BATCH_SIZE(self) -> int:\n        \"\"\"Batch processing size\"\"\"\n        return int(os.getenv('BATCH_SIZE', '10'))\n    \n    @property\n    def MAX_ACCOUNTS_PER_OPERATION(self) -> int:\n        \"\"\"Maximum accounts per operation\"\"\"\n        return int(os.getenv('MAX_ACCOUNTS_PER_OPERATION', '50'))\n    \n    @property\n    def DEFAULT_DELAY_MIN(self) -> int:\n        \"\"\"Minimum delay between operations (seconds)\"\"\"\n        return int(os.getenv('DEFAULT_DELAY_MIN', '1'))\n    \n    @property\n    def DEFAULT_DELAY_MAX(self) -> int:\n        \"\"\"Maximum delay between operations (seconds)\"\"\"\n        return int(os.getenv('DEFAULT_DELAY_MAX', '5'))\n    \n    @property\n    def MAX_RETRY_ATTEMPTS(self) -> int:\n        \"\"\"Maximum retry attempts for failed operations\"\"\"\n        return int(os.getenv('MAX_RETRY_ATTEMPTS', '3'))\n    \n    # Session Management\n    @property\n    def SESSION_DIR(self) -> str:\n        \"\"\"Directory for session files\"\"\"\n        return os.getenv('SESSION_DIR', 'sessions')\n    \n    @property\n    def SESSION_TIMEOUT(self) -> int:\n        \"\"\"Session timeout in seconds\"\"\"\n        return int(os.getenv('SESSION_TIMEOUT', '3600'))\n    \n    # Resource Management\n    @property\n    def LOG_CLEANUP_DAYS(self) -> int:\n        \"\"\"Days to keep log files\"\"\"\n        return int(os.getenv('LOG_CLEANUP_DAYS', '30'))\n    \n    # Monitoring Settings\n    @property\n    def HEALTH_CHECK_INTERVAL(self) -> int:\n        \"\"\"Health check interval in seconds\"\"\"\n        return int(os.getenv('HEALTH_CHECK_INTERVAL', '300'))\n    \n    @property\n    def PERFORMANCE_LOG_INTERVAL(self) -> int:\n        \"\"\"Performance logging interval in seconds\"\"\"\n        return int(os.getenv('PERFORMANCE_LOG_INTERVAL', '600'))\n    \n    # Feature-specific Settings\n    @property\n    def AUTO_JOIN_DELAY_MIN(self) -> int:\n        \"\"\"Minimum delay for auto-joining live streams\"\"\"\n        return int(os.getenv('AUTO_JOIN_DELAY_MIN', '5'))\n    \n    @property\n    def AUTO_JOIN_DELAY_MAX(self) -> int:\n        \"\"\"Maximum delay for auto-joining live streams\"\"\"\n        return int(os.getenv('AUTO_JOIN_DELAY_MAX', '15'))\n    \n    @property\n    def VIEW_BOOST_DELAY_MIN(self) -> int:\n        \"\"\"Minimum delay for view boosting\"\"\"\n        return int(os.getenv('VIEW_BOOST_DELAY_MIN', '2'))\n    \n    @property\n    def VIEW_BOOST_DELAY_MAX(self) -> int:\n        \"\"\"Maximum delay for view boosting\"\"\"\n        return int(os.getenv('VIEW_BOOST_DELAY_MAX', '8'))\n    \n    @property\n    def MAX_VIEWS_PER_ACCOUNT_DAILY(self) -> int:\n        \"\"\"Maximum views per account per day\"\"\"\n        return int(os.getenv('MAX_VIEWS_PER_ACCOUNT_DAILY', '1000'))\n    \n    @property\n    def REACTION_DELAY_MIN(self) -> int:\n        \"\"\"Minimum delay for emoji reactions\"\"\"\n        return int(os.getenv('REACTION_DELAY_MIN', '3'))\n    \n    @property\n    def REACTION_DELAY_MAX(self) -> int:\n        \"\"\"Maximum delay for emoji reactions\"\"\"\n        return int(os.getenv('REACTION_DELAY_MAX', '10'))\n    \n    @property\n    def MAX_REACTIONS_PER_ACCOUNT_DAILY(self) -> int:\n        \"\"\"Maximum reactions per account per day\"\"\"\n        return int(os.getenv('MAX_REACTIONS_PER_ACCOUNT_DAILY', '500'))\n    \n    def get_database_config(self) -> dict:\n        \"\"\"Get database configuration dictionary\"\"\"\n        return {\n            'host': self.DB_HOST,\n            'port': self.DB_PORT,\n            'database': self.DB_NAME,\n            'user': self.DB_USER,\n            'password': self.DB_PASSWORD,\n            'min_size': self.DB_POOL_SIZE,\n            'max_size': self.DB_MAX_POOL_SIZE,\n            'command_timeout': self.DB_TIMEOUT\n        }\n    \n    def validate_telegram_config(self) -> bool:\n        \"\"\"Validate Telegram API configuration\"\"\"\n        return bool(\n            self.BOT_TOKEN and \n            self.DEFAULT_API_ID and \n            self.DEFAULT_API_HASH and \n            self.ADMIN_IDS\n        )\n    \n    def __str__(self) -> str:\n        \"\"\"String representation of configuration (safe for logging)\"\"\"\n        return f\"Config(db_host={self.DB_HOST}, api_id={self.DEFAULT_API_ID}, admins={len(self.ADMIN_IDS)})\"\n","size_bytes":10212},"core/database/__init__.py":{"content":"\"\"\"\nDatabase management module\n\"\"\"\n\nfrom .unified_database import DatabaseManager\nfrom .coordinator import DatabaseCoordinator\nfrom .universal_access import UniversalDatabaseAccess\n\n__all__ = ['DatabaseManager', 'DatabaseCoordinator', 'UniversalDatabaseAccess']\n","size_bytes":262},"core/database/coordinator.py":{"content":"\"\"\"\nDatabase Coordinator\nManages database operations coordination and connection pooling\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, Any, Optional, List\nfrom datetime import datetime, timedelta\nimport asyncpg\nfrom contextlib import asynccontextmanager\n\nfrom core.config.config import Config\n\nlogger = logging.getLogger(__name__)\n\n\nclass DatabaseCoordinator:\n    \"\"\"Coordinates database operations and manages connection pools\"\"\"\n    \n    def __init__(self, config: Config):\n        self.config = config\n        self.pool: Optional[asyncpg.Pool] = None\n        self.connection_stats = {\n            'total_connections': 0,\n            'active_connections': 0,\n            'failed_connections': 0,\n            'last_health_check': None\n        }\n        self._health_check_task: Optional[asyncio.Task] = None\n        \n    async def initialize(self):\n        \"\"\"Initialize database connection pool\"\"\"\n        try:\n            logger.info(\"üîó Initializing database connection pool...\")\n            logger.info(f\"üìç Connecting to external database:\")\n            logger.info(f\"   Host: {self.config.DB_HOST}\")\n            logger.info(f\"   Port: {self.config.DB_PORT}\")\n            logger.info(f\"   Database: {self.config.DB_NAME}\")\n            logger.info(f\"   User: {self.config.DB_USER}\")\n            \n            # Create connection pool\n            self.pool = await asyncpg.create_pool(\n                host=self.config.DB_HOST,\n                port=self.config.DB_PORT,\n                database=self.config.DB_NAME,\n                user=self.config.DB_USER,\n                password=self.config.DB_PASSWORD,\n                min_size=self.config.DB_POOL_SIZE,\n                max_size=self.config.DB_MAX_POOL_SIZE,\n                command_timeout=self.config.DB_TIMEOUT,\n                server_settings={\n                    'application_name': 'telegram_channel_bot',\n                    'timezone': 'UTC'\n                }\n            )\n            \n            # Test connection\n            logger.info(\"üîç Testing database connection...\")\n            await self._test_connection()\n            \n            # Initialize database schema\n            logger.info(\"üõ†Ô∏è Initializing database schema...\")\n            await self._initialize_schema()\n            \n            # Start health monitoring\n            logger.info(\"üíì Starting health monitoring...\")\n            self._start_health_monitoring()\n            \n            logger.info(\"‚úÖ Database coordinator initialized successfully\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Failed to initialize database coordinator: {e}\")\n            raise\n    \n    async def _test_connection(self):\n        \"\"\"Test database connection\"\"\"\n        try:\n            if self.pool is None:\n                raise RuntimeError(\"Database pool not initialized\")\n            async with self.pool.acquire() as conn:\n                result = await conn.fetchval(\"SELECT 1\")\n                if result == 1:\n                    logger.info(\"‚úÖ Database connection test successful\")\n                    # Also test which database we're connected to\n                    db_name = await conn.fetchval(\"SELECT current_database()\")\n                    logger.info(f\"‚úÖ Connected to database: {db_name}\")\n                else:\n                    raise Exception(\"Database connection test failed\")\n        except Exception as e:\n            logger.error(f\"‚ùå Database connection test failed: {e}\")\n            raise\n    \n    async def _clear_existing_schema(self):\n        \"\"\"Clear existing schema (tables and indexes)\"\"\"\n        try:\n            logger.info(\"üóëÔ∏è Clearing existing database schema...\")\n            \n            if self.pool is None:\n                raise RuntimeError(\"Database pool not initialized\")\n            async with self.pool.acquire() as conn:\n                # Drop tables in reverse dependency order\n                drop_queries = [\n                    \"DROP TABLE IF EXISTS system_logs CASCADE\",\n                    \"DROP TABLE IF EXISTS analytics_data CASCADE\", \n                    \"DROP TABLE IF EXISTS emoji_reactions CASCADE\",\n                    \"DROP TABLE IF EXISTS live_stream_participants CASCADE\",\n                    \"DROP TABLE IF EXISTS view_boost_campaigns CASCADE\",\n                    \"DROP TABLE IF EXISTS channel_operations CASCADE\",\n                    \"DROP TABLE IF EXISTS telegram_channels CASCADE\",\n                    \"DROP TABLE IF EXISTS channels CASCADE\", \n                    \"DROP TABLE IF EXISTS telegram_accounts CASCADE\",\n                    \"DROP TABLE IF EXISTS users CASCADE\"\n                ]\n                \n                for query in drop_queries:\n                    await conn.execute(query)\n                    logger.info(f\"üóëÔ∏è Dropped table: {query.split()[4]}\")\n                \n                logger.info(\"‚úÖ Existing schema cleared successfully\")\n                \n        except Exception as e:\n            logger.error(f\"‚ùå Failed to clear existing schema: {e}\")\n            raise\n\n    async def _initialize_schema(self):\n        \"\"\"Initialize database schema\"\"\"\n        try:\n            logger.info(\"üîß Starting database schema initialization...\")\n            \n            # First check if we can access the database\n            if self.pool is None:\n                raise RuntimeError(\"Database pool not initialized\")\n            async with self.pool.acquire() as conn:\n                db_name = await conn.fetchval(\"SELECT current_database()\")\n                logger.info(f\"üìã Creating schema in database: {db_name}\")\n            \n            # Only clear schema if explicitly requested (for development)\n            import os\n            clear_schema = os.getenv('CLEAR_DB_SCHEMA', 'false').lower() == 'true'\n            if clear_schema:\n                logger.warning(\"‚ö†Ô∏è CLEAR_DB_SCHEMA=true detected - clearing existing schema\")\n                await self._clear_existing_schema()\n            else:\n                logger.info(\"‚úÖ Preserving existing data - schema will be updated safely\")\n            \n            schema_queries = [\n                # Users table\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    user_id BIGINT PRIMARY KEY,\n                    username VARCHAR(255),\n                    first_name VARCHAR(255),\n                    last_name VARCHAR(255),\n                    is_admin BOOLEAN DEFAULT FALSE,\n                    is_active BOOLEAN DEFAULT TRUE,\n                    first_seen TIMESTAMP DEFAULT NOW(),\n                    last_seen TIMESTAMP DEFAULT NOW(),\n                    settings JSONB DEFAULT '{}',\n                    created_at TIMESTAMP DEFAULT NOW(),\n                    updated_at TIMESTAMP DEFAULT NOW()\n                )\n                \"\"\",\n                \n                # Telegram accounts table\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS telegram_accounts (\n                    id SERIAL PRIMARY KEY,\n                    user_id BIGINT REFERENCES users(user_id),\n                    phone_number VARCHAR(20) UNIQUE NOT NULL,\n                    username VARCHAR(255),\n                    api_id INTEGER NOT NULL,\n                    api_hash VARCHAR(255) NOT NULL,\n                    unique_id VARCHAR(255) UNIQUE,\n                    session_data TEXT,\n                    is_active BOOLEAN DEFAULT TRUE,\n                    is_verified BOOLEAN DEFAULT FALSE,\n                    last_login TIMESTAMP,\n                    rate_limit_data JSONB DEFAULT '{}',\n                    settings JSONB DEFAULT '{}',\n                    created_at TIMESTAMP DEFAULT NOW(),\n                    updated_at TIMESTAMP DEFAULT NOW()\n                )\n                \"\"\",\n                \n                # Channels table\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS telegram_channels (\n                    id SERIAL PRIMARY KEY,\n                    user_id BIGINT REFERENCES users(user_id),\n                    channel_id BIGINT UNIQUE,\n                    channel_identifier VARCHAR(255),\n                    channel_title VARCHAR(255),\n                    channel_type VARCHAR(100),\n                    username VARCHAR(255),\n                    title VARCHAR(255),\n                    description TEXT,\n                    unique_id VARCHAR(255) UNIQUE,\n                    original_link TEXT,\n                    member_count INTEGER DEFAULT 0,\n                    is_active BOOLEAN DEFAULT TRUE,\n                    settings JSONB DEFAULT '{}',\n                    created_at TIMESTAMP DEFAULT NOW(),\n                    updated_at TIMESTAMP DEFAULT NOW()\n                )\n                \"\"\",\n                \n                # View boost campaigns table\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS view_boost_campaigns (\n                    id SERIAL PRIMARY KEY,\n                    user_id BIGINT REFERENCES users(user_id),\n                    channel_id INTEGER REFERENCES telegram_channels(id),\n                    message_id BIGINT NOT NULL,\n                    target_views INTEGER NOT NULL,\n                    current_views INTEGER DEFAULT 0,\n                    status VARCHAR(50) DEFAULT 'pending',\n                    campaign_type VARCHAR(50) DEFAULT 'manual',\n                    start_time TIMESTAMP,\n                    end_time TIMESTAMP,\n                    settings JSONB DEFAULT '{}',\n                    created_at TIMESTAMP DEFAULT NOW(),\n                    updated_at TIMESTAMP DEFAULT NOW()\n                )\n                \"\"\",\n                \n                # Boost configurations table\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS boost_configs (\n                    id SERIAL PRIMARY KEY,\n                    user_id BIGINT REFERENCES users(user_id),\n                    channel_id INTEGER REFERENCES telegram_channels(id),\n                    is_enabled BOOLEAN DEFAULT TRUE,\n                    boost_count INTEGER DEFAULT 50,\n                    cooldown_minutes INTEGER DEFAULT 30,\n                    timing_messages JSONB DEFAULT '[]',\n                    created_at TIMESTAMP DEFAULT NOW(),\n                    updated_at TIMESTAMP DEFAULT NOW(),\n                    UNIQUE(user_id, channel_id)\n                )\n                \"\"\",\n                \n                # View boost logs table\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS view_boost_logs (\n                    id SERIAL PRIMARY KEY,\n                    campaign_id INTEGER REFERENCES view_boost_campaigns(id),\n                    account_id INTEGER REFERENCES telegram_accounts(id),\n                    views_added INTEGER NOT NULL,\n                    success BOOLEAN NOT NULL,\n                    error_message TEXT,\n                    timestamp TIMESTAMP DEFAULT NOW()\n                )\n                \"\"\",\n                \n                # Live streams table\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS live_streams (\n                    id SERIAL PRIMARY KEY,\n                    channel_id INTEGER REFERENCES telegram_channels(id),\n                    stream_id BIGINT NOT NULL,\n                    title VARCHAR(255),\n                    is_active BOOLEAN DEFAULT TRUE,\n                    participant_count INTEGER DEFAULT 0,\n                    auto_join_enabled BOOLEAN DEFAULT FALSE,\n                    start_time TIMESTAMP,\n                    end_time TIMESTAMP,\n                    settings JSONB DEFAULT '{}',\n                    created_at TIMESTAMP DEFAULT NOW(),\n                    updated_at TIMESTAMP DEFAULT NOW()\n                )\n                \"\"\",\n                \n                # Live stream participants table\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS live_stream_participants (\n                    id SERIAL PRIMARY KEY,\n                    stream_id INTEGER REFERENCES live_streams(id),\n                    account_id INTEGER REFERENCES telegram_accounts(id),\n                    joined_at TIMESTAMP DEFAULT NOW(),\n                    left_at TIMESTAMP,\n                    is_active BOOLEAN DEFAULT TRUE\n                )\n                \"\"\",\n                \n                # Emoji reactions table\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS emoji_reactions (\n                    id SERIAL PRIMARY KEY,\n                    user_id BIGINT REFERENCES users(user_id),\n                    channel_id INTEGER REFERENCES telegram_channels(id),\n                    message_id BIGINT NOT NULL,\n                    emoji VARCHAR(50) NOT NULL,\n                    reaction_count INTEGER DEFAULT 0,\n                    auto_react_enabled BOOLEAN DEFAULT FALSE,\n                    settings JSONB DEFAULT '{}',\n                    created_at TIMESTAMP DEFAULT NOW(),\n                    updated_at TIMESTAMP DEFAULT NOW()\n                )\n                \"\"\",\n                \n                # Analytics data table\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS analytics_data (\n                    id SERIAL PRIMARY KEY,\n                    entity_type VARCHAR(50) NOT NULL,\n                    entity_id INTEGER NOT NULL,\n                    metric_name VARCHAR(100) NOT NULL,\n                    metric_value NUMERIC NOT NULL,\n                    metadata JSONB DEFAULT '{}',\n                    timestamp TIMESTAMP DEFAULT NOW()\n                )\n                \"\"\",\n                \n                # Channel operations table\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS channel_operations (\n                    id SERIAL PRIMARY KEY,\n                    user_id BIGINT REFERENCES users(user_id),\n                    channel_id INTEGER REFERENCES telegram_channels(id),\n                    operation_type VARCHAR(50) NOT NULL,\n                    account_count INTEGER DEFAULT 0,\n                    success BOOLEAN DEFAULT FALSE,\n                    details JSONB DEFAULT '{}',\n                    created_at TIMESTAMP DEFAULT NOW(),\n                    updated_at TIMESTAMP DEFAULT NOW()\n                )\n                \"\"\",\n                \n                # System logs table\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS system_logs (\n                    id SERIAL PRIMARY KEY,\n                    log_level VARCHAR(20) NOT NULL,\n                    module VARCHAR(100) NOT NULL,\n                    message TEXT NOT NULL,\n                    metadata JSONB DEFAULT '{}',\n                    timestamp TIMESTAMP DEFAULT NOW()\n                )\n                \"\"\",\n                \n                # Create indexes separately (PostgreSQL syntax)\n                \"\"\"\n                CREATE INDEX IF NOT EXISTS idx_analytics_entity ON analytics_data (entity_type, entity_id)\n                \"\"\",\n                \"\"\"\n                CREATE INDEX IF NOT EXISTS idx_analytics_metric ON analytics_data (metric_name)\n                \"\"\",\n                \"\"\"\n                CREATE INDEX IF NOT EXISTS idx_analytics_timestamp ON analytics_data (timestamp)\n                \"\"\",\n                \"\"\"\n                CREATE INDEX IF NOT EXISTS idx_logs_level ON system_logs (log_level)\n                \"\"\",\n                \"\"\"\n                CREATE INDEX IF NOT EXISTS idx_logs_module ON system_logs (module)\n                \"\"\",\n                \"\"\"\n                CREATE INDEX IF NOT EXISTS idx_logs_timestamp ON system_logs (timestamp)\n                \"\"\"\n            ]\n            \n            async with self.pool.acquire() as conn:\n                for i, query in enumerate(schema_queries):\n                    try:\n                        await conn.execute(query)\n                        logger.info(f\"‚úÖ Created schema component {i+1}/{len(schema_queries)}\")\n                    except Exception as query_error:\n                        logger.error(f\"‚ùå Failed to create schema component {i+1}: {query_error}\")\n                        logger.error(f\"Query: {query[:100]}...\")\n                        raise\n            \n            logger.info(\"‚úÖ Database schema initialized completely\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Failed to initialize database schema: {e}\")\n            raise\n    \n    @asynccontextmanager\n    async def get_connection(self):\n        \"\"\"Get database connection from pool\"\"\"\n        if not self.pool:\n            raise RuntimeError(\"Database pool not initialized\")\n        \n        conn = None\n        try:\n            conn = await self.pool.acquire()\n            self.connection_stats['active_connections'] += 1\n            yield conn\n        except Exception as e:\n            self.connection_stats['failed_connections'] += 1\n            logger.error(f\"Database connection error: {e}\")\n            raise\n        finally:\n            if conn:\n                await self.pool.release(conn)\n                self.connection_stats['active_connections'] -= 1\n    \n    async def execute_query(self, query: str, *args) -> Any:\n        \"\"\"Execute a database query\"\"\"\n        try:\n            async with self.get_connection() as conn:\n                return await conn.fetchval(query, *args)\n        except Exception as e:\n            logger.error(f\"Query execution failed: {e}\")\n            raise\n    \n    async def execute_many(self, query: str, args_list: List[tuple]) -> None:\n        \"\"\"Execute query with multiple parameter sets\"\"\"\n        try:\n            async with self.get_connection() as conn:\n                await conn.executemany(query, args_list)\n        except Exception as e:\n            logger.error(f\"Batch query execution failed: {e}\")\n            raise\n    \n    async def fetch_one(self, query: str, *args) -> Optional[Dict[str, Any]]:\n        \"\"\"Fetch single row\"\"\"\n        try:\n            async with self.get_connection() as conn:\n                row = await conn.fetchrow(query, *args)\n                return dict(row) if row else None\n        except Exception as e:\n            logger.error(f\"Fetch one failed: {e}\")\n            raise\n    \n    async def fetch_all(self, query: str, *args) -> List[Dict[str, Any]]:\n        \"\"\"Fetch all rows\"\"\"\n        try:\n            async with self.get_connection() as conn:\n                rows = await conn.fetch(query, *args)\n                return [dict(row) for row in rows]\n        except Exception as e:\n            logger.error(f\"Fetch all failed: {e}\")\n            raise\n    \n    def _start_health_monitoring(self):\n        \"\"\"Start background health monitoring\"\"\"\n        self._health_check_task = asyncio.create_task(self._health_check_loop())\n        logger.info(\"‚úÖ Database health monitoring started\")\n    \n    async def _health_check_loop(self):\n        \"\"\"Background health check loop\"\"\"\n        while True:\n            try:\n                await asyncio.sleep(self.config.HEALTH_CHECK_INTERVAL)\n                await self._perform_health_check()\n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Health check error: {e}\")\n    \n    async def _perform_health_check(self):\n        \"\"\"Perform database health check\"\"\"\n        try:\n            start_time = datetime.now()\n            \n            # Test connection\n            async with self.get_connection() as conn:\n                await conn.fetchval(\"SELECT 1\")\n            \n            # Update health check timestamp\n            self.connection_stats['last_health_check'] = start_time\n            \n            # Log health metrics\n            pool_size = self.pool.get_size() if self.pool else 0\n            logger.debug(f\"Database health check OK - Pool size: {pool_size}\")\n            \n        except Exception as e:\n            logger.error(f\"Database health check failed: {e}\")\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get database health status\"\"\"\n        if not self.pool:\n            return {'status': 'disconnected', 'pool': None}\n        \n        return {\n            'status': 'connected',\n            'pool': {\n                'size': self.pool.get_size(),\n                'min_size': self.pool.get_min_size(),\n                'max_size': self.pool.get_max_size(),\n                'idle_connections': self.pool.get_idle_size()\n            },\n            'stats': self.connection_stats.copy(),\n            'last_health_check': self.connection_stats['last_health_check']\n        }\n    \n    async def close(self):\n        \"\"\"Close database connections and cleanup\"\"\"\n        try:\n            # Cancel health monitoring\n            if self._health_check_task:\n                self._health_check_task.cancel()\n                try:\n                    await self._health_check_task\n                except asyncio.CancelledError:\n                    pass\n            \n            # Close connection pool\n            if self.pool:\n                await self.pool.close()\n                logger.info(\"‚úÖ Database connection pool closed\")\n            \n        except Exception as e:\n            logger.error(f\"Error closing database coordinator: {e}\")\n","size_bytes":21087},"core/database/unified_database.py":{"content":"\"\"\"\nUnified Database Manager\nMain database interface for all bot operations\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, Any, Optional, List, Union\nfrom datetime import datetime\nimport json\n\nfrom core.config.config import Config\nfrom .coordinator import DatabaseCoordinator\n\nlogger = logging.getLogger(__name__)\n\n\nclass DatabaseManager:\n    \"\"\"Unified database manager for all bot operations\"\"\"\n    \n    def __init__(self):\n        self.config = Config()\n        self.coordinator = DatabaseCoordinator(self.config)\n        self._initialized = False\n        \n    async def initialize(self):\n        \"\"\"Initialize database manager\"\"\"\n        if self._initialized:\n            return\n        \n        try:\n            await self.coordinator.initialize()\n            self._initialized = True\n            logger.info(\"‚úÖ Database manager initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize database manager: {e}\")\n            raise\n    \n    async def execute_query(self, query: str, *args) -> Any:\n        \"\"\"Execute a database query\"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"Database manager not initialized\")\n        \n        return await self.coordinator.execute_query(query, *args)\n    \n    async def fetch_one(self, query: str, *args) -> Optional[Dict[str, Any]]:\n        \"\"\"Fetch single row\"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"Database manager not initialized\")\n        \n        return await self.coordinator.fetch_one(query, *args)\n    \n    async def fetch_all(self, query: str, *args) -> List[Dict[str, Any]]:\n        \"\"\"Fetch all rows\"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"Database manager not initialized\")\n        \n        return await self.coordinator.fetch_all(query, *args)\n    \n    # User Management Operations\n    async def create_user(self, user_id: int, username: Optional[str] = None, first_name: Optional[str] = None, \n                         last_name: Optional[str] = None, is_admin: bool = False) -> bool:\n        \"\"\"Create or update user\"\"\"\n        try:\n            await self.execute_query(\n                \"\"\"\n                INSERT INTO users (user_id, username, first_name, last_name, is_admin, first_seen, last_seen)\n                VALUES ($1, $2, $3, $4, $5, NOW(), NOW())\n                ON CONFLICT (user_id) \n                DO UPDATE SET \n                    username = $2, \n                    first_name = $3, \n                    last_name = $4, \n                    last_seen = NOW(),\n                    updated_at = NOW()\n                \"\"\",\n                user_id, username, first_name, last_name, is_admin\n            )\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to create/update user {user_id}: {e}\")\n            return False\n    \n    async def get_user(self, user_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get user by ID\"\"\"\n        return await self.fetch_one(\n            \"SELECT * FROM users WHERE user_id = $1\",\n            user_id\n        )\n    \n    async def get_all_users(self, active_only: bool = True) -> List[Dict[str, Any]]:\n        \"\"\"Get all users\"\"\"\n        query = \"SELECT * FROM users\"\n        if active_only:\n            query += \" WHERE is_active = TRUE\"\n        query += \" ORDER BY created_at DESC\"\n        \n        return await self.fetch_all(query)\n    \n    async def update_user_settings(self, user_id: int, settings: Dict[str, Any]) -> bool:\n        \"\"\"Update user settings\"\"\"\n        try:\n            await self.execute_query(\n                \"UPDATE users SET settings = $2, updated_at = NOW() WHERE user_id = $1\",\n                user_id, json.dumps(settings)\n            )\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to update user settings for {user_id}: {e}\")\n            return False\n    \n    # Telegram Account Management\n    async def add_telegram_account(self, user_id: int, phone_number: str, \n                                  api_id: int, api_hash: str, unique_id: Optional[str] = None) -> Optional[int]:\n        \"\"\"Add new Telegram account\"\"\"\n        try:\n            # Generate unique_id if not provided\n            if unique_id is None:\n                import uuid\n                unique_id = str(uuid.uuid4())[:8]\n                \n            account_id = await self.execute_query(\n                \"\"\"\n                INSERT INTO telegram_accounts (user_id, phone_number, api_id, api_hash, unique_id, created_at, updated_at)\n                VALUES ($1, $2, $3, $4, $5, NOW(), NOW())\n                RETURNING id\n                \"\"\",\n                user_id, phone_number, api_id, api_hash, unique_id\n            )\n            return account_id\n        except Exception as e:\n            logger.error(f\"Failed to add Telegram account {phone_number}: {e}\")\n            return None\n    \n    async def get_user_accounts(self, user_id: int, active_only: bool = True) -> List[Dict[str, Any]]:\n        \"\"\"Get user's Telegram accounts\"\"\"\n        query = \"SELECT * FROM telegram_accounts WHERE user_id = $1\"\n        if active_only:\n            query += \" AND is_active = TRUE\"\n        query += \" ORDER BY created_at DESC\"\n        \n        return await self.fetch_all(query, user_id)\n    \n    async def get_account_by_id(self, account_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get account by ID\"\"\"\n        return await self.fetch_one(\n            \"SELECT * FROM telegram_accounts WHERE id = $1\",\n            account_id\n        )\n    \n    async def update_account_session(self, account_id: int, session_data: str) -> bool:\n        \"\"\"Update account session data\"\"\"\n        try:\n            await self.execute_query(\n                \"\"\"\n                UPDATE telegram_accounts \n                SET session_data = $2, is_verified = TRUE, last_login = NOW(), updated_at = NOW() \n                WHERE id = $1\n                \"\"\",\n                account_id, session_data\n            )\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to update session for account {account_id}: {e}\")\n            return False\n    \n    async def deactivate_account(self, account_id: int) -> bool:\n        \"\"\"Deactivate Telegram account\"\"\"\n        try:\n            await self.execute_query(\n                \"UPDATE telegram_accounts SET is_active = FALSE, updated_at = NOW() WHERE id = $1\",\n                account_id\n            )\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to deactivate account {account_id}: {e}\")\n            return False\n    \n    # Channel Management\n    async def add_channel(self, user_id: int, channel_id: int, username: Optional[str] = None,\n                         title: Optional[str] = None, description: Optional[str] = None) -> Optional[int]:\n        \"\"\"Add new channel\"\"\"\n        try:\n            db_channel_id = await self.execute_query(\n                \"\"\"\n                INSERT INTO telegram_channels (user_id, channel_id, username, title, description, created_at, updated_at)\n                VALUES ($1, $2, $3, $4, $5, NOW(), NOW())\n                ON CONFLICT (channel_id) \n                DO UPDATE SET \n                    username = $3, \n                    title = $4, \n                    description = $5,\n                    updated_at = NOW()\n                RETURNING id\n                \"\"\",\n                user_id, channel_id, username, title, description\n            )\n            return db_channel_id\n        except Exception as e:\n            logger.error(f\"Failed to add channel {channel_id}: {e}\")\n            return None\n    \n    async def get_user_channels(self, user_id: int, active_only: bool = True) -> List[Dict[str, Any]]:\n        \"\"\"Get user's channels\"\"\"\n        try:\n            query = \"SELECT * FROM telegram_channels WHERE user_id = $1\"\n            if active_only:\n                query += \" AND is_active = TRUE\"\n            query += \" ORDER BY created_at DESC\"\n            \n            return await self.fetch_all(query, user_id)\n        except Exception as e:\n            logger.error(f\"Failed to get user channels: {e}\")\n            return []\n    \n    async def get_channel_by_id(self, channel_db_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get channel by database ID\"\"\"\n        try:\n            return await self.fetch_one(\n                \"SELECT * FROM telegram_channels WHERE id = $1\",\n                channel_db_id\n            )\n        except Exception as e:\n            logger.error(f\"Failed to get channel by id {channel_db_id}: {e}\")\n            return None\n    \n    async def get_channel_by_channel_id(self, channel_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get channel by Telegram channel ID\"\"\"\n        return await self.fetch_one(\n            \"SELECT * FROM telegram_channels WHERE channel_id = $1\",\n            channel_id\n        )\n    \n    async def update_channel_info(self, channel_db_id: int, title: Optional[str] = None, \n                                 description: Optional[str] = None, member_count: Optional[int] = None) -> bool:\n        \"\"\"Update channel information\"\"\"\n        try:\n            updates = []\n            params = []\n            param_count = 1\n            \n            if title is not None:\n                updates.append(f\"title = ${param_count}\")\n                params.append(title)\n                param_count += 1\n            \n            if description is not None:\n                updates.append(f\"description = ${param_count}\")\n                params.append(description)\n                param_count += 1\n            \n            if member_count is not None:\n                updates.append(f\"member_count = ${param_count}\")\n                params.append(member_count)\n                param_count += 1\n            \n            if not updates:\n                return True\n            \n            updates.append(f\"updated_at = NOW()\")\n            params.append(channel_db_id)\n            \n            query = f\"UPDATE telegram_channels SET {', '.join(updates)} WHERE id = ${param_count}\"\n            \n            await self.execute_query(query, *params)\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to update channel {channel_db_id}: {e}\")\n            return False\n    \n    # View Boost Campaign Management\n    async def create_view_boost_campaign(self, user_id: int, channel_db_id: int, \n                                       message_id: int, target_views: int,\n                                       campaign_type: str = 'manual') -> Optional[int]:\n        \"\"\"Create new view boost campaign\"\"\"\n        try:\n            campaign_id = await self.execute_query(\n                \"\"\"\n                INSERT INTO view_boost_campaigns \n                (user_id, channel_id, message_id, target_views, campaign_type, created_at, updated_at)\n                VALUES ($1, $2, $3, $4, $5, NOW(), NOW())\n                RETURNING id\n                \"\"\",\n                user_id, channel_db_id, message_id, target_views, campaign_type\n            )\n            return campaign_id\n        except Exception as e:\n            logger.error(f\"Failed to create view boost campaign: {e}\")\n            return None\n    \n    async def get_user_campaigns(self, user_id: int, status: Optional[str] = None) -> List[Dict[str, Any]]:\n        \"\"\"Get user's view boost campaigns\"\"\"\n        query = \"\"\"\n        SELECT vbc.*, c.title as channel_title, c.username as channel_username\n        FROM view_boost_campaigns vbc\n        JOIN channels c ON vbc.channel_id = c.id\n        WHERE vbc.user_id = $1\n        \"\"\"\n        params: List[Any] = [user_id]\n        \n        if status is not None:\n            query += \" AND vbc.status = $2\"\n            params.append(status)\n        \n        query += \" ORDER BY vbc.created_at DESC\"\n        \n        return await self.fetch_all(query, *params)\n    \n    async def update_campaign_progress(self, campaign_id: int, current_views: int, \n                                     status: Optional[str] = None) -> bool:\n        \"\"\"Update campaign progress\"\"\"\n        try:\n            updates = [\"current_views = $2\", \"updated_at = NOW()\"]\n            params: List[Any] = [campaign_id, current_views]\n            \n            if status is not None:\n                updates.append(\"status = $3\")\n                params.append(status)\n            \n            query = f\"UPDATE view_boost_campaigns SET {', '.join(updates)} WHERE id = $1\"\n            \n            await self.execute_query(query, *params)\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to update campaign progress {campaign_id}: {e}\")\n            return False\n    \n    async def log_view_boost(self, campaign_id: int, account_id: int, views_added: int,\n                           success: bool, error_message: Optional[str] = None) -> bool:\n        \"\"\"Log view boost operation\"\"\"\n        try:\n            await self.execute_query(\n                \"\"\"\n                INSERT INTO view_boost_logs \n                (campaign_id, account_id, views_added, success, error_message, timestamp)\n                VALUES ($1, $2, $3, $4, $5, NOW())\n                \"\"\",\n                campaign_id, account_id, views_added, success, error_message\n            )\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to log view boost: {e}\")\n            return False\n    \n    # Analytics Operations\n    async def store_analytics_data(self, entity_type: str, entity_id: int, \n                                  metric_name: str, metric_value: float,\n                                  metadata: Optional[Dict[str, Any]] = None) -> bool:\n        \"\"\"Store analytics data\"\"\"\n        try:\n            await self.execute_query(\n                \"\"\"\n                INSERT INTO analytics_data (entity_type, entity_id, metric_name, metric_value, metadata, timestamp)\n                VALUES ($1, $2, $3, $4, $5, NOW())\n                \"\"\",\n                entity_type, entity_id, metric_name, metric_value, \n                json.dumps(metadata or {})\n            )\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to store analytics data: {e}\")\n            return False\n    \n    async def get_analytics_data(self, entity_type: str, entity_id: Optional[int] = None,\n                               metric_name: Optional[str] = None, limit: int = 1000) -> List[Dict[str, Any]]:\n        \"\"\"Get analytics data\"\"\"\n        query = \"SELECT * FROM analytics_data WHERE entity_type = $1\"\n        params: List[Any] = [entity_type]\n        param_count = 2\n        \n        if entity_id is not None:\n            query += f\" AND entity_id = ${param_count}\"\n            params.append(entity_id)\n            param_count += 1\n        \n        if metric_name is not None:\n            query += f\" AND metric_name = ${param_count}\"\n            params.append(metric_name)\n            param_count += 1\n        \n        query += f\" ORDER BY timestamp DESC LIMIT ${param_count}\"\n        params.append(limit)\n        \n        return await self.fetch_all(query, *params)\n    \n    # System Operations\n    async def log_system_event(self, log_level: str, module: str, message: str,\n                             metadata: Optional[Dict[str, Any]] = None) -> bool:\n        \"\"\"Log system event\"\"\"\n        try:\n            await self.execute_query(\n                \"\"\"\n                INSERT INTO system_logs (log_level, module, message, metadata, timestamp)\n                VALUES ($1, $2, $3, $4, NOW())\n                \"\"\",\n                log_level, module, message, json.dumps(metadata or {})\n            )\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to log system event: {e}\")\n            return False\n    \n    async def get_system_logs(self, log_level: Optional[str] = None, module: Optional[str] = None,\n                            limit: int = 100) -> List[Dict[str, Any]]:\n        \"\"\"Get system logs\"\"\"\n        query = \"SELECT * FROM system_logs WHERE 1=1\"\n        params: List[Any] = []\n        param_count = 1\n        \n        if log_level is not None:\n            query += f\" AND log_level = ${param_count}\"\n            params.append(log_level)\n            param_count += 1\n        \n        if module is not None:\n            query += f\" AND module = ${param_count}\"\n            params.append(module)\n            param_count += 1\n        \n        query += f\" ORDER BY timestamp DESC LIMIT ${param_count}\"\n        params.append(limit)\n        \n        return await self.fetch_all(query, *params)\n    \n    async def cleanup_old_logs(self, days: Optional[int] = None) -> int:\n        \"\"\"Cleanup old log entries\"\"\"\n        if days is None:\n            days = self.config.LOG_CLEANUP_DAYS\n        \n        try:\n            deleted_count = await self.execute_query(\n                \"DELETE FROM system_logs WHERE timestamp < NOW() - INTERVAL '%s days' RETURNING COUNT(*)\",\n                days\n            )\n            return deleted_count or 0\n        except Exception as e:\n            logger.error(f\"Failed to cleanup old logs: {e}\")\n            return 0\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get database health status\"\"\"\n        try:\n            coordinator_health = await self.coordinator.get_health_status()\n            \n            # Get table statistics\n            table_stats = await self.fetch_all(\n                \"\"\"\n                SELECT schemaname, relname as tablename, n_tup_ins, n_tup_upd, n_tup_del \n                FROM pg_stat_user_tables \n                WHERE schemaname = 'public'\n                \"\"\"\n            )\n            \n            return {\n                'coordinator': coordinator_health,\n                'tables': table_stats,\n                'initialized': self._initialized\n            }\n        except Exception as e:\n            logger.error(f\"Failed to get health status: {e}\")\n            return {'error': str(e)}\n    \n    async def close(self):\n        \"\"\"Close database manager\"\"\"\n        try:\n            if self.coordinator:\n                await self.coordinator.close()\n            self._initialized = False\n            logger.info(\"‚úÖ Database manager closed\")\n        except Exception as e:\n            logger.error(f\"Error closing database manager: {e}\")\n","size_bytes":18382},"core/database/universal_access.py":{"content":"\"\"\"\nUniversal Database Access Layer\nProvides high-level database operations for all features\n\"\"\"\n\nimport logging\nfrom typing import Dict, Any, Optional, List, Union\nfrom datetime import datetime, timedelta\nimport asyncio\n\nfrom .unified_database import DatabaseManager\n\nlogger = logging.getLogger(__name__)\n\n\nclass UniversalDatabaseAccess:\n    \"\"\"Universal database access layer for all bot features\"\"\"\n    \n    def __init__(self, db_manager: DatabaseManager):\n        self.db = db_manager\n        \n    # User Operations\n    async def ensure_user_exists(self, user_id: int, username: str = None, \n                               first_name: str = None, last_name: str = None,\n                               is_admin: bool = False) -> Dict[str, Any]:\n        \"\"\"Ensure user exists in database and return user data\"\"\"\n        await self.db.create_user(user_id, username, first_name, last_name, is_admin)\n        return await self.db.get_user(user_id)\n    \n    async def get_user_with_settings(self, user_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get user with parsed settings\"\"\"\n        user = await self.db.get_user(user_id)\n        if user and user.get('settings'):\n            try:\n                import json\n                user['settings'] = json.loads(user['settings'])\n            except:\n                user['settings'] = {}\n        return user\n    \n    async def update_user_last_seen(self, user_id: int) -> bool:\n        \"\"\"Update user's last seen timestamp\"\"\"\n        return await self.db.execute_query(\n            \"UPDATE users SET last_seen = NOW(), updated_at = NOW() WHERE user_id = $1\",\n            user_id\n        ) is not None\n    \n    # Channel Operations with Validation\n    async def add_channel_safe(self, user_id: int, channel_id: int, username: str = None,\n                              title: str = None, description: str = None) -> Dict[str, Any]:\n        \"\"\"Safely add channel with validation\"\"\"\n        try:\n            # Check if channel already exists\n            existing = await self.db.get_channel_by_channel_id(channel_id)\n            if existing:\n                return {\n                    'success': False, \n                    'error': 'Channel already exists',\n                    'channel_id': existing['id']\n                }\n            \n            # Add new channel\n            db_channel_id = await self.db.add_channel(\n                user_id, channel_id, username, title, description\n            )\n            \n            if db_channel_id:\n                return {\n                    'success': True,\n                    'channel_id': db_channel_id,\n                    'message': 'Channel added successfully'\n                }\n            else:\n                return {\n                    'success': False,\n                    'error': 'Failed to add channel'\n                }\n                \n        except Exception as e:\n            logger.error(f\"Error adding channel safely: {e}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    async def get_user_channels_with_stats(self, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get user channels with statistics\"\"\"\n        channels = await self.db.get_user_channels(user_id)\n        \n        # Add statistics for each channel\n        for channel in channels:\n            # Get view boost campaign count\n            campaigns = await self.db.fetch_all(\n                \"SELECT COUNT(*) as total, status FROM view_boost_campaigns WHERE channel_id = $1 GROUP BY status\",\n                channel['id']\n            )\n            \n            channel['campaign_stats'] = {\n                'total': sum(c['total'] for c in campaigns),\n                'by_status': {c['status']: c['total'] for c in campaigns}\n            }\n            \n            # Get recent analytics\n            recent_views = await self.db.get_analytics_data(\n                'channel', channel['id'], 'views', limit=7\n            )\n            channel['recent_views'] = recent_views\n        \n        return channels\n    \n    # Account Operations with Status Tracking\n    async def add_account_with_validation(self, user_id: int, phone_number: str,\n                                        api_id: int, api_hash: str) -> Dict[str, Any]:\n        \"\"\"Add account with validation and status tracking\"\"\"\n        try:\n            # Check account limit for user\n            existing_accounts = await self.db.get_user_accounts(user_id)\n            max_accounts = 10  # Configurable limit\n            \n            if len(existing_accounts) >= max_accounts:\n                return {\n                    'success': False,\n                    'error': f'Maximum {max_accounts} accounts allowed per user'\n                }\n            \n            # Add account\n            account_id = await self.db.add_telegram_account(\n                user_id, phone_number, api_id, api_hash\n            )\n            \n            if account_id:\n                # Log account creation\n                await self.db.log_system_event(\n                    'INFO', 'account_management', \n                    f'New account added: {phone_number}',\n                    {'user_id': user_id, 'account_id': account_id}\n                )\n                \n                return {\n                    'success': True,\n                    'account_id': account_id,\n                    'message': 'Account added successfully'\n                }\n            else:\n                return {\n                    'success': False,\n                    'error': 'Failed to add account'\n                }\n                \n        except Exception as e:\n            logger.error(f\"Error adding account: {e}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    async def get_accounts_with_health(self, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get accounts with health status\"\"\"\n        accounts = await self.db.get_user_accounts(user_id)\n        \n        for account in accounts:\n            # Calculate health score based on various factors\n            health_score = 100\n            health_issues = []\n            \n            # Check last login\n            if account['last_login']:\n                days_since_login = (datetime.now() - account['last_login']).days\n                if days_since_login > 7:\n                    health_score -= 20\n                    health_issues.append(f'No login for {days_since_login} days')\n            else:\n                health_score -= 30\n                health_issues.append('Never logged in')\n            \n            # Check verification status\n            if not account['is_verified']:\n                health_score -= 25\n                health_issues.append('Not verified')\n            \n            # Check activity status\n            if not account['is_active']:\n                health_score = 0\n                health_issues.append('Account deactivated')\n            \n            account['health_score'] = max(0, health_score)\n            account['health_issues'] = health_issues\n            account['health_status'] = 'good' if health_score >= 80 else 'warning' if health_score >= 50 else 'critical'\n        \n        return accounts\n    \n    # Campaign Operations with Progress Tracking\n    async def create_campaign_with_tracking(self, user_id: int, channel_db_id: int,\n                                          message_id: int, target_views: int,\n                                          campaign_type: str = 'manual',\n                                          settings: Dict[str, Any] = None) -> Dict[str, Any]:\n        \"\"\"Create campaign with progress tracking setup\"\"\"\n        try:\n            campaign_id = await self.db.create_view_boost_campaign(\n                user_id, channel_db_id, message_id, target_views, campaign_type\n            )\n            \n            if campaign_id:\n                # Store campaign settings\n                if settings:\n                    await self.db.execute_query(\n                        \"UPDATE view_boost_campaigns SET settings = $2 WHERE id = $1\",\n                        campaign_id, json.dumps(settings)\n                    )\n                \n                # Log campaign creation\n                await self.db.log_system_event(\n                    'INFO', 'view_manager',\n                    f'Campaign created: {campaign_id}',\n                    {\n                        'user_id': user_id,\n                        'campaign_id': campaign_id,\n                        'target_views': target_views,\n                        'type': campaign_type\n                    }\n                )\n                \n                return {\n                    'success': True,\n                    'campaign_id': campaign_id,\n                    'message': 'Campaign created successfully'\n                }\n            else:\n                return {\n                    'success': False,\n                    'error': 'Failed to create campaign'\n                }\n                \n        except Exception as e:\n            logger.error(f\"Error creating campaign: {e}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    async def get_campaign_progress(self, campaign_id: int) -> Dict[str, Any]:\n        \"\"\"Get detailed campaign progress\"\"\"\n        campaign = await self.db.fetch_one(\n            \"\"\"\n            SELECT vbc.*, c.title as channel_title, c.username as channel_username\n            FROM view_boost_campaigns vbc\n            JOIN channels c ON vbc.channel_id = c.id\n            WHERE vbc.id = $1\n            \"\"\",\n            campaign_id\n        )\n        \n        if not campaign:\n            return {'error': 'Campaign not found'}\n        \n        # Get boost logs\n        logs = await self.db.fetch_all(\n            \"\"\"\n            SELECT vbl.*, ta.phone_number\n            FROM view_boost_logs vbl\n            JOIN telegram_accounts ta ON vbl.account_id = ta.id\n            WHERE vbl.campaign_id = $1\n            ORDER BY vbl.timestamp DESC\n            \"\"\",\n            campaign_id\n        )\n        \n        # Calculate statistics\n        total_attempts = len(logs)\n        successful_attempts = sum(1 for log in logs if log['success'])\n        total_views_added = sum(log['views_added'] for log in logs if log['success'])\n        \n        progress_percentage = 0\n        if campaign['target_views'] > 0:\n            progress_percentage = min(100, (total_views_added / campaign['target_views']) * 100)\n        \n        return {\n            'campaign': campaign,\n            'logs': logs,\n            'statistics': {\n                'total_attempts': total_attempts,\n                'successful_attempts': successful_attempts,\n                'success_rate': (successful_attempts / total_attempts * 100) if total_attempts > 0 else 0,\n                'total_views_added': total_views_added,\n                'progress_percentage': progress_percentage,\n                'remaining_views': max(0, campaign['target_views'] - total_views_added)\n            }\n        }\n    \n    # Analytics Operations\n    async def get_user_analytics_summary(self, user_id: int, days: int = 30) -> Dict[str, Any]:\n        \"\"\"Get comprehensive user analytics summary\"\"\"\n        try:\n            # Get user's channels\n            channels = await self.db.get_user_channels(user_id)\n            channel_ids = [c['id'] for c in channels]\n            \n            # Get campaigns summary\n            campaigns = await self.db.get_user_campaigns(user_id)\n            \n            # Get recent analytics data\n            analytics_data = {}\n            for channel_id in channel_ids:\n                channel_analytics = await self.db.get_analytics_data(\n                    'channel', channel_id, limit=days\n                )\n                analytics_data[channel_id] = channel_analytics\n            \n            # Calculate summary statistics\n            total_campaigns = len(campaigns)\n            active_campaigns = len([c for c in campaigns if c['status'] == 'active'])\n            completed_campaigns = len([c for c in campaigns if c['status'] == 'completed'])\n            \n            total_target_views = sum(c['target_views'] for c in campaigns)\n            total_current_views = sum(c['current_views'] for c in campaigns)\n            \n            return {\n                'channels': {\n                    'total': len(channels),\n                    'active': len([c for c in channels if c['is_active']]),\n                    'details': channels\n                },\n                'campaigns': {\n                    'total': total_campaigns,\n                    'active': active_campaigns,\n                    'completed': completed_campaigns,\n                    'success_rate': (completed_campaigns / total_campaigns * 100) if total_campaigns > 0 else 0\n                },\n                'views': {\n                    'target_total': total_target_views,\n                    'current_total': total_current_views,\n                    'completion_rate': (total_current_views / total_target_views * 100) if total_target_views > 0 else 0\n                },\n                'analytics_data': analytics_data\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting user analytics: {e}\")\n            return {'error': str(e)}\n    \n    async def get_system_health_summary(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive system health summary\"\"\"\n        try:\n            # Get database health\n            db_health = await self.db.get_health_status()\n            \n            # Get user statistics\n            total_users = len(await self.db.get_all_users(active_only=False))\n            active_users = len(await self.db.get_all_users(active_only=True))\n            \n            # Get account statistics\n            all_accounts = await self.db.fetch_all(\"SELECT * FROM telegram_accounts\")\n            active_accounts = [a for a in all_accounts if a['is_active']]\n            verified_accounts = [a for a in all_accounts if a['is_verified']]\n            \n            # Get campaign statistics\n            all_campaigns = await self.db.fetch_all(\"SELECT * FROM view_boost_campaigns\")\n            active_campaigns = [c for c in all_campaigns if c['status'] == 'active']\n            \n            # Get recent errors\n            recent_errors = await self.db.get_system_logs('ERROR', limit=10)\n            \n            return {\n                'database': db_health,\n                'users': {\n                    'total': total_users,\n                    'active': active_users,\n                    'activity_rate': (active_users / total_users * 100) if total_users > 0 else 0\n                },\n                'accounts': {\n                    'total': len(all_accounts),\n                    'active': len(active_accounts),\n                    'verified': len(verified_accounts),\n                    'verification_rate': (len(verified_accounts) / len(all_accounts) * 100) if all_accounts else 0\n                },\n                'campaigns': {\n                    'total': len(all_campaigns),\n                    'active': len(active_campaigns)\n                },\n                'recent_errors': recent_errors,\n                'timestamp': datetime.now()\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting system health: {e}\")\n            return {'error': str(e)}\n    \n    # Batch Operations\n    async def batch_update_analytics(self, analytics_batch: List[Dict[str, Any]]) -> int:\n        \"\"\"Batch update analytics data\"\"\"\n        try:\n            successful_updates = 0\n            \n            for item in analytics_batch:\n                success = await self.db.store_analytics_data(\n                    item['entity_type'],\n                    item['entity_id'],\n                    item['metric_name'],\n                    item['metric_value'],\n                    item.get('metadata')\n                )\n                if success:\n                    successful_updates += 1\n            \n            return successful_updates\n            \n        except Exception as e:\n            logger.error(f\"Error in batch analytics update: {e}\")\n            return 0\n    \n    async def cleanup_old_data(self, days: int = None) -> Dict[str, int]:\n        \"\"\"Cleanup old data from various tables\"\"\"\n        try:\n            cleanup_results = {}\n            \n            # Cleanup logs\n            logs_deleted = await self.db.cleanup_old_logs(days)\n            cleanup_results['logs'] = logs_deleted\n            \n            # Cleanup old analytics data (keep last 90 days)\n            analytics_days = days or 90\n            analytics_deleted = await self.db.execute_query(\n                \"DELETE FROM analytics_data WHERE timestamp < NOW() - INTERVAL '%s days' RETURNING COUNT(*)\",\n                analytics_days\n            )\n            cleanup_results['analytics'] = analytics_deleted or 0\n            \n            # Cleanup old completed campaigns (keep last 30 days)\n            campaigns_days = 30\n            campaigns_deleted = await self.db.execute_query(\n                \"\"\"\n                DELETE FROM view_boost_campaigns \n                WHERE status = 'completed' AND updated_at < NOW() - INTERVAL '%s days' \n                RETURNING COUNT(*)\n                \"\"\",\n                campaigns_days\n            )\n            cleanup_results['campaigns'] = campaigns_deleted or 0\n            \n            return cleanup_results\n            \n        except Exception as e:\n            logger.error(f\"Error in data cleanup: {e}\")\n            return {'error': str(e)}\n","size_bytes":17664},"features/account_management/__init__.py":{"content":"\"\"\"\nAccount Management Feature\nHandles Telegram account management and authentication\n\"\"\"\n\nfrom .handler import AccountManagementHandler\n\n__all__ = ['AccountManagementHandler']\n","size_bytes":177},"features/account_management/handler.py":{"content":"\"\"\"\nAccount Management Handler - ArcX Bot\nSimplified account management with default/custom API support\n\"\"\"\n\nimport asyncio\nimport logging\nimport uuid\nfrom typing import Dict, Any, List, Optional\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import CallbackQuery, Message\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\nfrom aiogram.fsm.state import State, StatesGroup\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\n\nlogger = logging.getLogger(__name__)\n\n\nclass AccountStates(StatesGroup):\n    \"\"\"FSM states for account management\"\"\"\n    waiting_for_api_choice = State()\n    waiting_for_custom_api = State()\n    waiting_for_phone = State()\n    waiting_for_code = State()\n    waiting_for_password = State()\n\n\nclass AccountManagementHandler:\n    \"\"\"Simplified Account Manager according to user specifications\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config, bot_core=None):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.bot_core = bot_core\n        self._pending_accounts = {}  # Store temporary account data during setup\n        \n    async def initialize(self):\n        \"\"\"Initialize account management handler\"\"\"\n        try:\n            logger.info(\"‚úÖ Account management handler initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize account management handler: {e}\")\n            raise\n    \n    def register_handlers(self, dp: Dispatcher):\n        \"\"\"Register handlers with dispatcher\"\"\"\n        # FSM message handlers  \n        dp.message.register(self.handle_custom_api_input, AccountStates.waiting_for_custom_api)\n        dp.message.register(self.handle_phone_input, AccountStates.waiting_for_phone)\n        dp.message.register(self.handle_code_input, AccountStates.waiting_for_code)\n        dp.message.register(self.handle_password_input, AccountStates.waiting_for_password)\n        \n        logger.info(\"‚úÖ Account management handlers registered\")\n    \n    async def handle_callback(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle account management callbacks\"\"\"\n        try:\n            callback_data = callback.data\n            user_id = callback.from_user.id\n            \n            # Ensure user exists in database\n            await self._ensure_user_exists(callback.from_user)\n            \n            if callback_data == \"am_add_account\":\n                await self._handle_add_account(callback, state)\n            elif callback_data == \"am_remove_account\":\n                await self._handle_remove_account(callback, state)\n            elif callback_data == \"am_list_accounts\":\n                await self._handle_list_accounts(callback, state)\n            elif callback_data == \"am_refresh\":\n                await self._handle_refresh_accounts(callback, state)\n            elif callback_data.startswith(\"am_info_\"):\n                await self._handle_account_info(callback, state)\n            elif callback_data.startswith(\"am_delete_\"):\n                await self._handle_delete_account(callback, state)\n            elif callback_data == \"am_use_default_api\":\n                await self._handle_use_default_api(callback, state)\n            elif callback_data == \"am_use_custom_api\":\n                await self._handle_use_custom_api(callback, state)\n            else:\n                await callback.answer(\"‚ùå Unknown action\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error in account management callback: {e}\")\n            await callback.answer(\"‚ùå An error occurred\", show_alert=True)\n    \n    async def _handle_add_account(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Start add account process\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Check account limit\n            accounts = await self._get_user_accounts(user_id)\n            if len(accounts) >= 100:  # As per user spec - max 1000 but load 100 at a time\n                await callback.message.edit_text(\n                    \"üî• <b>ArcX | Account Limit Reached</b>\\\\n\\\\n\"\n                    \"You have reached the maximum limit of 100 active accounts.\\\\n\"\n                    \"Remove some accounts before adding new ones.\",\n                    reply_markup=self._get_back_keyboard()\n                )\n                await callback.answer(\"‚ö†Ô∏è Account limit reached!\")\n                return\n            \n            text = \"\"\"üî• <b>ArcX | Add Account</b>\n\nChoose API configuration:\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[üîë Use Default API]\", callback_data=\"am_use_default_api\")],\n                [InlineKeyboardButton(text=\"[‚öôÔ∏è Use Custom API]\", callback_data=\"am_use_custom_api\")],\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"refresh_main\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üì± Choose API type\")\n            \n        except Exception as e:\n            logger.error(f\"Error in add account: {e}\")\n            await callback.answer(\"‚ùå Failed to start add account\", show_alert=True)\n    \n    async def _handle_use_default_api(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Use default API from .env\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Store API choice\n            self._pending_accounts[user_id] = {\n                'api_id': self.config.DEFAULT_API_ID,\n                'api_hash': self.config.DEFAULT_API_HASH,\n                'api_type': 'default'\n            }\n            \n            text = \"\"\"üî• <b>ArcX | Enter Phone Number</b>\n\nPlease send your phone number in international format:\n\n<b>Example:</b> +1234567890\n\n<b>Note:</b> You'll receive a verification code on this number.\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"am_add_account\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await state.set_state(AccountStates.waiting_for_phone)\n            await callback.answer(\"üì± Enter phone number\")\n            \n        except Exception as e:\n            logger.error(f\"Error using default API: {e}\")\n            await callback.answer(\"‚ùå Error setting up API\", show_alert=True)\n    \n    async def _handle_use_custom_api(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Use custom API credentials\"\"\"\n        try:\n            text = \"\"\"üî• <b>ArcX | Custom API Setup</b>\n\nSend your API credentials in this format:\n<code>API_ID,API_HASH</code>\n\n<b>Example:</b>\n<code>12345678,abcdef1234567890abcdef1234567890</code>\n\n<b>Get your API credentials:</b>\n1. Visit https://my.telegram.org\n2. Login with your phone\n3. Go to API development tools\n4. Create new application\n5. Copy API ID and API Hash\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"am_add_account\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await state.set_state(AccountStates.waiting_for_custom_api)\n            await callback.answer(\"‚öôÔ∏è Send custom API credentials\")\n            \n        except Exception as e:\n            logger.error(f\"Error setting up custom API: {e}\")\n            await callback.answer(\"‚ùå Error setting up custom API\", show_alert=True)\n    \n    async def handle_custom_api_input(self, message: Message, state: FSMContext):\n        \"\"\"Handle custom API input\"\"\"\n        try:\n            user_id = message.from_user.id\n            api_text = message.text.strip()\n            \n            # Parse API credentials\n            if ',' not in api_text:\n                await message.answer(\n                    \"‚ùå <b>Invalid Format</b>\\\\n\\\\n\"\n                    \"Please send in format: <code>API_ID,API_HASH</code>\",\n                    reply_markup=self._get_retry_keyboard()\n                )\n                return\n            \n            try:\n                api_id_str, api_hash = api_text.split(',', 1)\n                api_id = int(api_id_str.strip())\n                api_hash = api_hash.strip()\n                \n                if not api_hash or len(api_hash) < 10:\n                    raise ValueError(\"Invalid API hash\")\n                    \n            except ValueError:\n                await message.answer(\n                    \"‚ùå <b>Invalid API Credentials</b>\\\\n\\\\n\"\n                    \"Please check the format and try again.\",\n                    reply_markup=self._get_retry_keyboard()\n                )\n                return\n            \n            # Store API credentials\n            self._pending_accounts[user_id] = {\n                'api_id': api_id,\n                'api_hash': api_hash,\n                'api_type': 'custom'\n            }\n            \n            text = \"\"\"üî• <b>ArcX | Enter Phone Number</b>\n\nAPI credentials saved! Now please send your phone number:\n\n<b>Example:</b> +1234567890\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"am_add_account\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await message.answer(text, reply_markup=keyboard)\n            await state.set_state(AccountStates.waiting_for_phone)\n            \n        except Exception as e:\n            logger.error(f\"Error handling custom API: {e}\")\n            await message.answer(\"‚ùå Error processing API credentials\")\n    \n    async def handle_phone_input(self, message: Message, state: FSMContext):\n        \"\"\"Handle phone number input\"\"\"\n        try:\n            user_id = message.from_user.id\n            phone = message.text.strip()\n            \n            # Validate phone format\n            if not phone.startswith('+') or len(phone) < 10:\n                await message.answer(\n                    \"‚ùå <b>Invalid Phone Format</b>\\\\n\\\\n\"\n                    \"Please use international format with + sign\\\\n\"\n                    \"Example: +1234567890\",\n                    reply_markup=self._get_retry_keyboard()\n                )\n                return\n            \n            # Check if phone exists\n            existing = await self.db.fetch_one(\n                \"SELECT id FROM telegram_accounts WHERE phone_number = $1\", phone\n            )\n            if existing:\n                await message.answer(\n                    \"‚ùå <b>Phone Already Registered</b>\\\\n\\\\n\"\n                    \"This phone number is already in use.\",\n                    reply_markup=self._get_retry_keyboard()\n                )\n                return\n            \n            # Get API credentials from pending\n            if user_id not in self._pending_accounts:\n                await message.answer(\"‚ùå Session expired. Please start again.\")\n                await state.clear()\n                return\n            \n            api_data = self._pending_accounts[user_id]\n            \n            # Generate unique account ID\n            account_uuid = str(uuid.uuid4())[:8]\n            \n            # Save to database\n            account_id = await self.db.execute_query(\n                \"\"\"\n                INSERT INTO telegram_accounts \n                (user_id, phone_number, api_id, api_hash, unique_id, created_at, updated_at)\n                VALUES ($1, $2, $3, $4, $5, NOW(), NOW())\n                RETURNING id\n                \"\"\",\n                user_id, phone, api_data['api_id'], api_data['api_hash'], account_uuid\n            )\n            \n            # Update pending with account details\n            self._pending_accounts[user_id].update({\n                'account_id': account_id,\n                'phone': phone,\n                'unique_id': account_uuid\n            })\n            \n            # Actually send verification code using Telethon\n            try:\n                from telethon import TelegramClient\n                \n                # Create temporary client to send OTP\n                temp_client = TelegramClient(\n                    f\"sessions/temp_{account_uuid}\",\n                    api_data['api_id'],\n                    api_data['api_hash']\n                )\n                \n                await temp_client.connect()\n                \n                # Send verification code\n                sent_code = await temp_client.send_code_request(phone)\n                \n                # Store phone_code_hash for verification\n                self._pending_accounts[user_id]['phone_code_hash'] = sent_code.phone_code_hash\n                self._pending_accounts[user_id]['temp_client'] = temp_client\n                \n                text = f\"\"\"üî• <b>ArcX | Verification Code</b>\n\n‚úÖ Verification code sent to: <code>{phone}</code>\n\nPlease enter the 5-digit code you received:\n                \"\"\"\n                \n                keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                    [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"am_add_account\")],\n                    [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n                ])\n                \n                await message.answer(text, reply_markup=keyboard)\n                await state.set_state(AccountStates.waiting_for_code)\n                \n            except Exception as otp_error:\n                logger.error(f\"Failed to send OTP: {otp_error}\")\n                await message.answer(\n                    f\"‚ùå <b>Failed to Send OTP</b>\\n\\n\"\n                    f\"Error: {str(otp_error)}\\n\\n\"\n                    f\"Please check your phone number and try again.\",\n                    reply_markup=self._get_retry_keyboard()\n                )\n            \n        except Exception as e:\n            logger.error(f\"Error handling phone input: {e}\")\n            await message.answer(\"‚ùå Error processing phone number\")\n    \n    async def handle_code_input(self, message: Message, state: FSMContext):\n        \"\"\"Handle verification code\"\"\"\n        try:\n            user_id = message.from_user.id\n            code = message.text.strip()\n            \n            if user_id not in self._pending_accounts:\n                await message.answer(\"‚ùå Session expired. Please start again.\")\n                await state.clear()\n                return\n            \n            account_data = self._pending_accounts[user_id]\n            \n            # Validate code format\n            if len(code) != 5 or not code.isdigit():\n                await message.answer(\n                    \"‚ùå <b>Invalid Code Format</b>\\\\n\\\\n\"\n                    \"Please enter the 5-digit verification code.\",\n                    reply_markup=self._get_retry_keyboard()\n                )\n                return\n            \n            # Actually verify the code with Telegram\n            try:\n                temp_client = account_data.get('temp_client')\n                phone_code_hash = account_data.get('phone_code_hash')\n                \n                if not temp_client or not phone_code_hash:\n                    await message.answer(\"‚ùå Session expired. Please start again.\")\n                    await state.clear()\n                    return\n                \n                # Sign in with the verification code\n                user = await temp_client.sign_in(\n                    account_data['phone'], \n                    code, \n                    phone_code_hash=phone_code_hash\n                )\n                \n                # Save the session and update account\n                session_data = temp_client.session.save()\n                await self.db.execute_query(\n                    \"\"\"\n                    UPDATE telegram_accounts \n                    SET session_data = $2, username = $3, is_verified = TRUE, last_login = NOW(), updated_at = NOW()\n                    WHERE id = $1\n                    \"\"\",\n                    account_data['account_id'], session_data, user.username\n                )\n                \n                # Clean up temporary client\n                await temp_client.disconnect()\n                \n            except Exception as verification_error:\n                logger.error(f\"Verification failed: {verification_error}\")\n                await message.answer(\n                    \"‚ùå <b>Invalid Verification Code</b>\\\\n\\\\n\"\n                    \"Please check the code and try again.\",\n                    reply_markup=self._get_retry_keyboard()\n                )\n                return\n            \n            # Update account as verified (fallback if Telegram verification worked)\n            await self.db.execute_query(\n                \"\"\"\n                UPDATE telegram_accounts \n                SET is_verified = TRUE, last_login = NOW(), updated_at = NOW()\n                WHERE id = $1\n                \"\"\",\n                account_data['account_id']\n            )\n            \n            text = f\"\"\"‚úÖ <b>ArcX | Account Added Successfully!</b>\n\n<b>Account Details:</b>\n‚Ä¢ Phone: {account_data['phone']}\n‚Ä¢ Unique ID: {account_data['unique_id']}\n‚Ä¢ API Type: {account_data['api_type'].title()}\n‚Ä¢ Status: ‚úÖ Verified\n\nAccount is ready for use in all operations!\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[üìã View All Accounts]\", callback_data=\"am_list_accounts\")],\n                [InlineKeyboardButton(text=\"[‚ûï Add Another]\", callback_data=\"am_add_account\")],\n                [InlineKeyboardButton(text=\"[üîô Account Manager]\", callback_data=\"account_manager\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await message.answer(text, reply_markup=keyboard)\n            \n            # Cleanup\n            if user_id in self._pending_accounts:\n                # Clean up temp client if it exists\n                temp_client = self._pending_accounts[user_id].get('temp_client')\n                if temp_client:\n                    try:\n                        await temp_client.disconnect()\n                    except:\n                        pass\n                del self._pending_accounts[user_id]\n            await state.clear()\n            \n        except Exception as e:\n            logger.error(f\"Error handling code: {e}\")\n            await message.answer(\"‚ùå Error verifying code\")\n    \n    async def handle_password_input(self, message: Message, state: FSMContext):\n        \"\"\"Handle 2FA password input\"\"\"\n        try:\n            user_id = message.from_user.id\n            password = message.text.strip()\n            \n            if user_id not in self._pending_accounts:\n                await message.answer(\"‚ùå Session expired. Please start again.\")\n                await state.clear()\n                return\n            \n            account_data = self._pending_accounts[user_id]\n            \n            # Update account as verified with 2FA\n            await self.db.execute_query(\n                \"\"\"\n                UPDATE telegram_accounts \n                SET is_verified = TRUE, last_login = NOW(), updated_at = NOW()\n                WHERE id = $1\n                \"\"\",\n                account_data['account_id']\n            )\n            \n            text = f\"\"\"‚úÖ <b>ArcX | Account Verified with 2FA!</b>\n\n<b>Account Details:</b>\n‚Ä¢ Phone: {account_data['phone']}\n‚Ä¢ Unique ID: {account_data['unique_id']}\n‚Ä¢ Security: üîê Two-Factor Enabled\n‚Ä¢ Status: ‚úÖ Verified\n\nAccount is ready for secure operations!\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[üìã View All Accounts]\", callback_data=\"am_list_accounts\")],\n                [InlineKeyboardButton(text=\"[üîô Account Manager]\", callback_data=\"account_manager\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await message.answer(text, reply_markup=keyboard)\n            \n            # Cleanup\n            if user_id in self._pending_accounts:\n                del self._pending_accounts[user_id]\n            await state.clear()\n            \n        except Exception as e:\n            logger.error(f\"Error handling password: {e}\")\n            await message.answer(\"‚ùå Error verifying password\")\n    \n    async def _handle_remove_account(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle remove account\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            accounts = await self._get_user_accounts(user_id)\n            if not accounts:\n                await callback.message.edit_text(\n                    \"üî• <b>ArcX | No Accounts Found</b>\\\\n\\\\n\"\n                    \"You don't have any accounts to remove.\",\n                    reply_markup=self._get_back_keyboard()\n                )\n                await callback.answer(\"‚ÑπÔ∏è No accounts to remove\")\n                return\n            \n            text = \"üî• <b>ArcX | Remove Account</b>\\\\n\\\\nSelect account to remove:\\\\n\\\\n\"\n            \n            buttons = []\n            for account in accounts[:10]:  # Show max 10 for UI\n                username = f\"@{account.get('username', 'No username')}\"\n                button_text = f\"[üóëÔ∏è {account['phone_number']}]\"\n                callback_data = f\"am_delete_{account['id']}\"\n                buttons.append([InlineKeyboardButton(text=button_text, callback_data=callback_data)])\n            \n            buttons.extend([\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"account_manager\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üóëÔ∏è Select account to remove\")\n            \n        except Exception as e:\n            logger.error(f\"Error in remove account: {e}\")\n            await callback.answer(\"‚ùå Failed to load remove account\", show_alert=True)\n    \n    async def _handle_list_accounts(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle list accounts with info buttons\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            accounts = await self._get_user_accounts(user_id)\n            if not accounts:\n                await callback.message.edit_text(\n                    \"üî• <b>ArcX | No Accounts</b>\\\\n\\\\n\"\n                    \"You haven't added any accounts yet.\\\\n\"\n                    \"Add your first account to get started!\",\n                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[\n                        [InlineKeyboardButton(text=\"[‚ûï Add Account]\", callback_data=\"am_add_account\")],\n                        [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"account_manager\")],\n                        [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n                    ])\n                )\n                await callback.answer(\"‚ÑπÔ∏è No accounts found\")\n                return\n            \n            text = f\"üî• <b>ArcX | Account List</b>\\\\n\\\\nTotal Accounts: {len(accounts)}\\\\n\\\\n\"\n            \n            buttons = []\n            for i, account in enumerate(accounts[:10], 1):  # Show max 10\n                username = account.get('username', 'No username')\n                status = \"‚úÖ\" if account['is_active'] else \"‚ùå\"\n                account_text = f\"{status} {username}\"\n                \n                # Account name button and info button in same row\n                buttons.append([\n                    InlineKeyboardButton(text=f\"[{i}. {account_text}]\", callback_data=f\"am_select_{account['id']}\"),\n                    InlineKeyboardButton(text=\"[‚ÑπÔ∏è]\", callback_data=f\"am_info_{account['id']}\")\n                ])\n            \n            buttons.extend([\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"account_manager\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(f\"üìã {len(accounts)} accounts loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error listing accounts: {e}\")\n            await callback.answer(\"‚ùå Failed to load accounts\", show_alert=True)\n    \n    async def _handle_account_info(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Show detailed account information popup\"\"\"\n        try:\n            account_id = int(callback.data.split('_')[2])\n            \n            account = await self.db.fetch_one(\n                \"SELECT * FROM telegram_accounts WHERE id = $1\", account_id\n            )\n            \n            if not account:\n                await callback.answer(\"‚ùå Account not found\", show_alert=True)\n                return\n            \n            # Calculate account health and status\n            health_score = await self._calculate_health_score(account)\n            status = \"üü¢ Active\" if account['is_active'] else \"üî¥ Inactive\"\n            \n            info_text = f\"\"\"üì± Account Info\n\nPhone: {account['phone_number']}\nStatus: {status}\nHealth: {health_score}/100\nVerified: {\"‚úÖ\" if account['is_verified'] else \"‚ùå\"}\n\nAdded: {account['created_at'].strftime('%Y-%m-%d')}\nAPI: {\"Default\" if account['api_id'] == self.config.DEFAULT_API_ID else \"Custom\"}\"\"\"\n            \n            await callback.answer(info_text, show_alert=True)\n            \n        except Exception as e:\n            logger.error(f\"Error showing account info: {e}\")\n            await callback.answer(\"‚ùå Error loading account info\", show_alert=True)\n    \n    async def _handle_refresh_accounts(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Refresh accounts list\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Show account manager menu again with fresh data\n            text = \"üî• <b>ArcX | Account Manager</b>\\\\n\\\\nManage your Telegram accounts for operations:\\\\n\\\\n\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[‚ûï Add Account]\", callback_data=\"am_add_account\")],\n                [InlineKeyboardButton(text=\"[üóëÔ∏è Remove Account]\", callback_data=\"am_remove_account\")],\n                [InlineKeyboardButton(text=\"[üìã List Accounts]\", callback_data=\"am_list_accounts\")],\n                [InlineKeyboardButton(text=\"[üîÑ Refresh Accounts]\", callback_data=\"am_refresh\")],\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"refresh_main\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üîÑ Accounts refreshed!\")\n            \n        except Exception as e:\n            logger.error(f\"Error refreshing accounts: {e}\")\n            await callback.answer(\"‚ùå Failed to refresh\", show_alert=True)\n    \n    async def _handle_delete_account(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle account deletion\"\"\"\n        try:\n            account_id = int(callback.data.split('_')[2])\n            \n            # Get account details\n            account = await self.db.fetch_one(\n                \"SELECT * FROM telegram_accounts WHERE id = $1\", account_id\n            )\n            \n            if not account:\n                await callback.answer(\"‚ùå Account not found\", show_alert=True)\n                return\n            \n            # Delete from database and remove session file\n            await self.db.execute_query(\n                \"DELETE FROM telegram_accounts WHERE id = $1\", account_id\n            )\n            \n            # Remove session file if exists\n            session_file = f\"sessions/{account.get('unique_id', account_id)}.session\"\n            try:\n                import os\n                if os.path.exists(session_file):\n                    os.remove(session_file)\n                if os.path.exists(f\"{session_file}-journal\"):\n                    os.remove(f\"{session_file}-journal\")\n            except Exception as session_error:\n                logger.warning(f\"Could not remove session file: {session_error}\")\n            \n            text = f\"\"\"‚úÖ <b>ArcX | Account Removed</b>\n\nAccount successfully removed:\n‚Ä¢ Phone: {account['phone_number']}\n‚Ä¢ Unique ID: {account.get('unique_id', 'N/A')}\n\nAll data and session files have been cleaned up.\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[üìã View Remaining]\", callback_data=\"am_list_accounts\")],\n                [InlineKeyboardButton(text=\"[üîô Account Manager]\", callback_data=\"account_manager\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚úÖ Account removed successfully!\")\n            \n        except Exception as e:\n            logger.error(f\"Error deleting account: {e}\")\n            await callback.answer(\"‚ùå Failed to remove account\", show_alert=True)\n    \n    # Helper methods\n    async def _get_user_accounts(self, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get user's accounts (including orphaned accounts from session recovery)\"\"\"\n        # First, try to claim any orphaned accounts (accounts with NULL user_id)\n        await self._claim_orphaned_accounts(user_id)\n        \n        # Then return user's accounts\n        return await self.db.fetch_all(\n            \"SELECT * FROM telegram_accounts WHERE user_id = $1 ORDER BY created_at DESC\",\n            user_id\n        )\n    \n    async def _ensure_user_exists(self, user):\n        \"\"\"Ensure user exists in database\"\"\"\n        await self.db.execute_query(\n            \"\"\"\n            INSERT INTO users (user_id, username, first_name, last_name, first_seen, last_seen)\n            VALUES ($1, $2, $3, $4, NOW(), NOW())\n            ON CONFLICT (user_id) DO UPDATE SET \n                username = $2, last_seen = NOW()\n            \"\"\",\n            user.id, user.username, user.first_name, user.last_name\n        )\n    \n    async def _calculate_health_score(self, account: Dict[str, Any]) -> int:\n        \"\"\"Calculate account health score\"\"\"\n        score = 100\n        \n        if not account['is_verified']:\n            score -= 30\n        if not account['is_active']:\n            score -= 50\n        if not account.get('last_login'):\n            score -= 20\n            \n        return max(0, score)\n    \n    def _get_back_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get back button keyboard\"\"\"\n        return InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"[üîô Account Manager]\", callback_data=\"account_manager\")],\n            [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n        ])\n    \n    async def _claim_orphaned_accounts(self, user_id: int):\n        \"\"\"Claim orphaned accounts from session recovery\"\"\"\n        try:\n            # Update orphaned accounts (user_id IS NULL) to belong to this user\n            await self.db.execute_query(\n                \"UPDATE telegram_accounts SET user_id = $1 WHERE user_id IS NULL\",\n                user_id\n            )\n        except Exception as e:\n            logger.error(f\"Error claiming orphaned accounts: {e}\")\n    \n    def _get_retry_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get retry keyboard\"\"\"\n        return InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"[üîÑ Try Again]\", callback_data=\"am_add_account\")],\n            [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"account_manager\")]\n        ])\n    \n","size_bytes":32944},"features/analytics/__init__.py":{"content":"\"\"\"\nAnalytics Feature\nProvides comprehensive analytics and reporting for bot operations\n\"\"\"\n\nfrom .handler import AnalyticsHandler\n\n__all__ = ['AnalyticsHandler']\n","size_bytes":163},"features/analytics/handler.py":{"content":"\"\"\"\nAnalytics Handler\nProvides comprehensive analytics and reporting for all bot operations\n\"\"\"\n\nimport logging\nimport time\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime, timedelta\nimport json\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import CallbackQuery, Message\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\nfrom core.database.universal_access import UniversalDatabaseAccess\n\nlogger = logging.getLogger(__name__)\n\n\nclass AnalyticsHandler:\n    \"\"\"Handler for analytics and reporting\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.universal_db = UniversalDatabaseAccess(db_manager)\n        \n    async def initialize(self):\n        \"\"\"Initialize analytics handler\"\"\"\n        logger.info(\"‚úÖ Analytics handler initialized\")\n    \n    def register_handlers(self, dp: Dispatcher):\n        \"\"\"Register handlers with dispatcher\"\"\"\n        # Callback registration handled by central inline_handler\n        # dp.callback_query.register(\n        #     self.handle_callback,\n        #     lambda c: c.data.startswith('an_')\n        # )\n        \n        logger.info(\"‚úÖ Analytics handlers registered\")\n    \n    async def handle_callback(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle analytics callbacks\"\"\"\n        try:\n            callback_data = callback.data\n            user_id = callback.from_user.id\n            \n            # Ensure user exists\n            await self.universal_db.ensure_user_exists(\n                user_id,\n                callback.from_user.username,\n                callback.from_user.first_name,\n                callback.from_user.last_name\n            )\n            \n            # Analytics main menu callbacks (from inline_handler.py)\n            if callback_data == \"an_channel_data\":\n                await self._handle_channel_stats(callback, state)\n            elif callback_data == \"an_system_info\":\n                await self._handle_system_info(callback, state)\n            elif callback_data == \"an_engine_status\":\n                await self._handle_engine_status(callback, state)\n            # Existing analytics callbacks\n            elif callback_data == \"an_channel_stats\":\n                await self._handle_channel_stats(callback, state)\n            elif callback_data == \"an_boost_stats\":\n                await self._handle_boost_stats(callback, state)\n            elif callback_data == \"an_account_stats\":\n                await self._handle_account_stats(callback, state)\n            elif callback_data.startswith(\"an_channel_\"):\n                await self._handle_specific_channel_analytics(callback, state)\n            elif callback_data == \"an_overview\":\n                await self._handle_analytics_overview(callback, state)\n            elif callback_data == \"an_export\":\n                await self._handle_export_analytics(callback, state)\n            elif callback_data == \"an_performance\":\n                await self._handle_performance_analytics(callback, state)\n            else:\n                await callback.answer(\"‚ùå Unknown analytics action\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error in analytics callback: {e}\")\n            await callback.answer(\"‚ùå An error occurred\", show_alert=True)\n    \n    async def _handle_channel_stats(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle channel statistics\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user channels with comprehensive stats\n            channels_stats = await self._get_comprehensive_channel_stats(user_id)\n            \n            if not channels_stats['channels']:\n                await callback.message.edit_text(\n                    \"üì≠ <b>No Channel Data Available</b>\\n\\n\"\n                    \"Add channels first to view analytics.\",\n                    reply_markup=self._get_no_data_keyboard()\n                )\n                return\n            \n            text = f\"\"\"\nüìà <b>Channel Statistics Overview</b>\n\n<b>üìä Summary ({len(channels_stats['channels'])} channels):</b>\n‚Ä¢ Total Members: {channels_stats['total_members']:,}\n‚Ä¢ Total Campaigns: {channels_stats['total_campaigns']}\n‚Ä¢ Total Views Boosted: {channels_stats['total_views']:,}\n‚Ä¢ Average Success Rate: {channels_stats['avg_success_rate']:.1f}%\n\n<b>üèÜ Top Performing Channels:</b>\n\"\"\"\n            \n            for i, channel in enumerate(channels_stats['top_channels'][:5], 1):\n                text += (\n                    f\"{i}. <b>{channel['title']}</b>\\n\"\n                    f\"   üë• {channel['members']:,} members | \"\n                    f\"üìà {channel['campaigns']} campaigns | \"\n                    f\"üëÅÔ∏è {channel['views']:,} views\\n\"\n                )\n            \n            text += f\"\"\"\n<b>üìà Growth Trends (Last 30 Days):</b>\n‚Ä¢ Member Growth: {channels_stats['member_growth']:+,}\n‚Ä¢ New Campaigns: {channels_stats['new_campaigns']}\n‚Ä¢ View Boost Growth: {channels_stats['view_growth']:+,}\n\n<b>üí° Insights:</b>\n‚Ä¢ Most Active Hour: {channels_stats['peak_hour']}:00\n‚Ä¢ Best Performing Day: {channels_stats['best_day']}\n‚Ä¢ Average Views per Campaign: {channels_stats['avg_views_per_campaign']:,.0f}\n            \"\"\"\n            \n            keyboard = self._get_channel_stats_keyboard(len(channels_stats['channels']))\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üìà Channel statistics loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in channel stats: {e}\")\n            await callback.answer(\"‚ùå Failed to load channel statistics\", show_alert=True)\n    \n    async def _handle_boost_stats(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle boost statistics\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get comprehensive boost analytics\n            boost_stats = await self._get_comprehensive_boost_stats(user_id)\n            \n            text = f\"\"\"\nüöÄ <b>View Boost Analytics</b>\n\n<b>üìä Campaign Performance:</b>\n‚Ä¢ Total Campaigns: {boost_stats['total_campaigns']}\n‚Ä¢ Active Campaigns: {boost_stats['active_campaigns']}\n‚Ä¢ Success Rate: {boost_stats['success_rate']:.1f}%\n‚Ä¢ Average Completion Time: {boost_stats['avg_completion_time']:.1f} hours\n\n<b>üëÅÔ∏è View Statistics:</b>\n‚Ä¢ Total Views Boosted: {boost_stats['total_views']:,}\n‚Ä¢ Views This Month: {boost_stats['monthly_views']:,}\n‚Ä¢ Views This Week: {boost_stats['weekly_views']:,}\n‚Ä¢ Views Today: {boost_stats['daily_views']:,}\n\n<b>üìà Performance Trends:</b>\n‚Ä¢ Daily Average: {boost_stats['daily_average']:,.0f} views\n‚Ä¢ Peak Performance: {boost_stats['peak_views']:,} views in one day\n‚Ä¢ Growth Rate: {boost_stats['growth_rate']:+.1f}% this month\n\n<b>‚öôÔ∏è Campaign Types:</b>\n‚Ä¢ Manual Campaigns: {boost_stats['manual_campaigns']} ({boost_stats['manual_percentage']:.1f}%)\n‚Ä¢ Auto Campaigns: {boost_stats['auto_campaigns']} ({boost_stats['auto_percentage']:.1f}%)\n\n<b>üïê Peak Performance Hours:</b>\n\"\"\"\n            \n            for hour, views in boost_stats['peak_hours'][:3]:\n                text += f\"‚Ä¢ {hour}:00 - {views:,} views boosted\\n\"\n            \n            text += f\"\"\"\n<b>üéØ Top Channels by Boost Performance:</b>\n\"\"\"\n            \n            for channel in boost_stats['top_boost_channels'][:3]:\n                text += f\"‚Ä¢ {channel['title']}: {channel['total_boosted']:,} views\\n\"\n            \n            keyboard = self._get_boost_stats_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üöÄ Boost analytics loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in boost stats: {e}\")\n            await callback.answer(\"‚ùå Failed to load boost statistics\", show_alert=True)\n    \n    async def _handle_account_stats(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle account statistics\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get account analytics\n            account_stats = await self._get_account_analytics(user_id)\n            \n            if not account_stats['accounts']:\n                await callback.message.edit_text(\n                    \"üì± <b>No Account Data Available</b>\\n\\n\"\n                    \"Add Telegram accounts first to view analytics.\",\n                    reply_markup=self._get_no_accounts_keyboard()\n                )\n                return\n            \n            text = f\"\"\"\nüì± <b>Account Performance Analytics</b>\n\n<b>üìä Account Overview:</b>\n‚Ä¢ Total Accounts: {len(account_stats['accounts'])}\n‚Ä¢ Active Accounts: {account_stats['active_count']}\n‚Ä¢ Verified Accounts: {account_stats['verified_count']}\n‚Ä¢ Average Health Score: {account_stats['avg_health_score']:.1f}/100\n\n<b>‚ö° Usage Statistics:</b>\n‚Ä¢ Total API Calls: {account_stats['total_api_calls']:,}\n‚Ä¢ Calls This Month: {account_stats['monthly_calls']:,}\n‚Ä¢ Success Rate: {account_stats['success_rate']:.1f}%\n‚Ä¢ Rate Limit Hits: {account_stats['rate_limit_hits']}\n\n<b>üèÜ Top Performing Accounts:</b>\n\"\"\"\n            \n            for i, account in enumerate(account_stats['top_accounts'][:3], 1):\n                status_emoji = \"üü¢\" if account['is_active'] else \"üî¥\"\n                text += (\n                    f\"{i}. {status_emoji} {account['phone_number']}\\n\"\n                    f\"   üí™ Health: {account['health_score']}/100 | \"\n                    f\"üìû Calls: {account['api_calls']:,}\\n\"\n                )\n            \n            text += f\"\"\"\n<b>üìà Performance Trends:</b>\n‚Ä¢ Daily API Calls: {account_stats['daily_avg_calls']:,.0f} average\n‚Ä¢ Account Utilization: {account_stats['utilization_rate']:.1f}%\n‚Ä¢ Error Rate: {account_stats['error_rate']:.2f}%\n\n<b>‚ö†Ô∏è Health Alerts:</b>\n‚Ä¢ Critical Health: {account_stats['critical_health']} accounts\n‚Ä¢ Rate Limited: {account_stats['rate_limited']} accounts\n‚Ä¢ Inactive: {account_stats['inactive_count']} accounts\n            \"\"\"\n            \n            keyboard = self._get_account_stats_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üì± Account analytics loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in account stats: {e}\")\n            await callback.answer(\"‚ùå Failed to load account statistics\", show_alert=True)\n    \n    async def _handle_specific_channel_analytics(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle analytics for specific channel\"\"\"\n        try:\n            # Extract channel ID\n            channel_id = int(callback.data.split(\"_\")[-1])\n            \n            # Get detailed channel analytics\n            channel_analytics = await self._get_detailed_channel_analytics(channel_id)\n            \n            if not channel_analytics:\n                await callback.answer(\"‚ùå Channel not found\", show_alert=True)\n                return\n            \n            channel = channel_analytics['channel']\n            stats = channel_analytics['stats']\n            \n            text = f\"\"\"\nüìä <b>{channel['title']} - Detailed Analytics</b>\n\n<b>üìã Channel Overview:</b>\n‚Ä¢ Members: {channel.get('member_count', 0):,}\n‚Ä¢ Added: {channel['created_at'].strftime('%Y-%m-%d')}\n‚Ä¢ Status: {'üü¢ Active' if channel['is_active'] else 'üî¥ Inactive'}\n\n<b>üöÄ Campaign Performance:</b>\n‚Ä¢ Total Campaigns: {stats['total_campaigns']}\n‚Ä¢ Active Campaigns: {stats['active_campaigns']}\n‚Ä¢ Completed: {stats['completed_campaigns']}\n‚Ä¢ Success Rate: {stats['success_rate']:.1f}%\n\n<b>üëÅÔ∏è View Statistics:</b>\n‚Ä¢ Total Views Boosted: {stats['total_views_boosted']:,}\n‚Ä¢ Average per Campaign: {stats['avg_views_per_campaign']:,.0f}\n‚Ä¢ Best Single Campaign: {stats['best_campaign_views']:,} views\n‚Ä¢ Total Target Views: {stats['total_target_views']:,}\n\n<b>üìà Growth Metrics:</b>\n‚Ä¢ Member Growth (30d): {stats['member_growth']:+,}\n‚Ä¢ Campaign Growth (30d): {stats['campaign_growth']:+,}\n‚Ä¢ View Growth (30d): {stats['view_growth']:+,}\n\n<b>üïê Activity Patterns:</b>\n‚Ä¢ Most Active Hour: {stats['peak_activity_hour']}:00\n‚Ä¢ Most Active Day: {stats['peak_activity_day']}\n‚Ä¢ Last Campaign: {stats['last_campaign_date']}\n\n<b>‚ö° Recent Performance (7 days):</b>\n‚Ä¢ New Campaigns: {stats['recent_campaigns']}\n‚Ä¢ Views Boosted: {stats['recent_views']:,}\n‚Ä¢ Average Daily: {stats['daily_average']:,.0f} views\n            \"\"\"\n            \n            keyboard = self._get_channel_analytics_keyboard(channel_id)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(f\"üìä {channel['title']} analytics\")\n            \n        except Exception as e:\n            logger.error(f\"Error in specific channel analytics: {e}\")\n            await callback.answer(\"‚ùå Failed to load channel analytics\", show_alert=True)\n    \n    async def _handle_analytics_overview(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle analytics overview\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get comprehensive overview\n            overview = await self._get_analytics_overview(user_id)\n            \n            text = f\"\"\"\nüìä <b>Analytics Overview Dashboard</b>\n\n<b>üéØ Quick Summary:</b>\n‚Ä¢ Channels: {overview['channels']}\n‚Ä¢ Accounts: {overview['accounts']}  \n‚Ä¢ Total Campaigns: {overview['campaigns']}\n‚Ä¢ Views Boosted: {overview['total_views']:,}\n\n<b>üìà This Month:</b>\n‚Ä¢ New Campaigns: {overview['monthly_campaigns']}\n‚Ä¢ Views Boosted: {overview['monthly_views']:,}\n‚Ä¢ Success Rate: {overview['monthly_success_rate']:.1f}%\n‚Ä¢ Growth: {overview['monthly_growth']:+.1f}%\n\n<b>üöÄ Performance Highlights:</b>\n‚Ä¢ Best Channel: {overview['top_channel']}\n‚Ä¢ Best Day: {overview['best_day']} ({overview['best_day_views']:,} views)\n‚Ä¢ Peak Hour: {overview['peak_hour']}:00\n‚Ä¢ Avg Daily Views: {overview['avg_daily_views']:,.0f}\n\n<b>üí™ System Health:</b>\n‚Ä¢ Active Accounts: {overview['active_accounts']}/{overview['total_accounts']}\n‚Ä¢ System Uptime: {overview['uptime']:.1f}%\n‚Ä¢ Success Rate: {overview['overall_success_rate']:.1f}%\n‚Ä¢ Response Time: {overview['avg_response_time']:.2f}s\n\n<b>üé≠ Feature Usage:</b>\n‚Ä¢ Auto Boost: {overview['auto_boost_usage']:.1f}%\n‚Ä¢ Manual Boost: {overview['manual_boost_usage']:.1f}%\n‚Ä¢ Reactions: {overview['reactions_usage']:.1f}%\n‚Ä¢ Live Management: {overview['live_usage']:.1f}%\n\n<b>üìÖ Recent Activity:</b>\n‚Ä¢ Last Campaign: {overview['last_activity']}\n‚Ä¢ Campaigns Today: {overview['today_campaigns']}\n‚Ä¢ Views Today: {overview['today_views']:,}\n            \"\"\"\n            \n            keyboard = self._get_overview_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üìä Analytics overview loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in analytics overview: {e}\")\n            await callback.answer(\"‚ùå Failed to load overview\", show_alert=True)\n    \n    async def _handle_export_analytics(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle analytics export\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Generate comprehensive report\n            report = await self._generate_analytics_report(user_id)\n            \n            # Format export text\n            export_text = f\"\"\"\nüìã <b>Analytics Export Report</b>\nüìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n<b>üìä Executive Summary:</b>\n‚Ä¢ Report Period: Last 30 Days\n‚Ä¢ Total Channels: {report['summary']['channels']}\n‚Ä¢ Total Accounts: {report['summary']['accounts']}\n‚Ä¢ Total Campaigns: {report['summary']['campaigns']}\n‚Ä¢ Total Views Boosted: {report['summary']['views']:,}\n\n<b>üìà Key Metrics:</b>\n‚Ä¢ Success Rate: {report['metrics']['success_rate']:.1f}%\n‚Ä¢ Average Campaign Size: {report['metrics']['avg_campaign_size']:,.0f} views\n‚Ä¢ Peak Performance Day: {report['metrics']['best_day']}\n‚Ä¢ Most Active Channel: {report['metrics']['top_channel']}\n\n<b>üéØ Channel Performance:</b>\n\"\"\"\n            \n            for channel in report['channels'][:5]:\n                export_text += (\n                    f\"‚Ä¢ {channel['title']}: {channel['campaigns']} campaigns, \"\n                    f\"{channel['views']:,} views\\n\"\n                )\n            \n            export_text += f\"\"\"\n<b>üì± Account Utilization:</b>\n‚Ä¢ Active Accounts: {report['accounts']['active']}/{report['accounts']['total']}\n‚Ä¢ Average Health Score: {report['accounts']['avg_health']:.1f}/100\n‚Ä¢ Total API Calls: {report['accounts']['api_calls']:,}\n\n<b>‚ö° Performance Trends:</b>\n‚Ä¢ Daily Average Views: {report['trends']['daily_avg']:,.0f}\n‚Ä¢ Week-over-Week Growth: {report['trends']['growth']:+.1f}%\n‚Ä¢ Peak Activity Hour: {report['trends']['peak_hour']}:00\n\n<b>üìä Campaign Analysis:</b>\n‚Ä¢ Manual Campaigns: {report['campaign_types']['manual']} ({report['campaign_types']['manual_pct']:.1f}%)\n‚Ä¢ Auto Campaigns: {report['campaign_types']['auto']} ({report['campaign_types']['auto_pct']:.1f}%)\n‚Ä¢ Scheduled Campaigns: {report['campaign_types']['scheduled']}\n\n<b>üîç Insights & Recommendations:</b>\n{chr(10).join(f\"‚Ä¢ {insight}\" for insight in report['insights'])}\n            \"\"\"\n            \n            keyboard = self._get_export_keyboard()\n            \n            await callback.message.edit_text(export_text, reply_markup=keyboard)\n            await callback.answer(\"üìã Analytics report generated\")\n            \n        except Exception as e:\n            logger.error(f\"Error exporting analytics: {e}\")\n            await callback.answer(\"‚ùå Failed to generate report\", show_alert=True)\n    \n    async def _handle_performance_analytics(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle performance analytics\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get performance metrics\n            performance = await self._get_performance_metrics(user_id)\n            \n            text = f\"\"\"\n‚ö° <b>Performance Analytics</b>\n\n<b>üöÄ System Performance:</b>\n‚Ä¢ Average Response Time: {performance['avg_response_time']:.2f}s\n‚Ä¢ Success Rate: {performance['success_rate']:.2f}%\n‚Ä¢ Uptime: {performance['uptime']:.1f}%\n‚Ä¢ Error Rate: {performance['error_rate']:.2f}%\n\n<b>üìä Throughput Metrics:</b>\n‚Ä¢ Views/Hour: {performance['views_per_hour']:,.0f}\n‚Ä¢ Campaigns/Hour: {performance['campaigns_per_hour']:.1f}\n‚Ä¢ API Calls/Hour: {performance['api_calls_per_hour']:,.0f}\n‚Ä¢ Reactions/Hour: {performance['reactions_per_hour']:,.0f}\n\n<b>‚öôÔ∏è Resource Utilization:</b>\n‚Ä¢ Account Usage: {performance['account_utilization']:.1f}%\n‚Ä¢ Rate Limit Usage: {performance['rate_limit_usage']:.1f}%\n‚Ä¢ Database Load: {performance['db_load']:.1f}%\n‚Ä¢ Memory Usage: {performance['memory_usage']:.1f}%\n\n<b>üìà Performance Trends (7 days):</b>\n‚Ä¢ Speed Improvement: {performance['speed_trend']:+.1f}%\n‚Ä¢ Success Rate Change: {performance['success_trend']:+.1f}%\n‚Ä¢ Throughput Change: {performance['throughput_trend']:+.1f}%\n\n<b>üéØ Optimization Opportunities:</b>\n\"\"\"\n            \n            for optimization in performance['optimizations']:\n                text += f\"‚Ä¢ {optimization}\\n\"\n            \n            text += f\"\"\"\n<b>‚ö†Ô∏è Performance Alerts:</b>\n‚Ä¢ Slow Queries: {performance['slow_queries']}\n‚Ä¢ Failed Operations: {performance['failed_operations']}\n‚Ä¢ Rate Limit Hits: {performance['rate_limit_hits']}\n‚Ä¢ Timeout Errors: {performance['timeout_errors']}\n            \"\"\"\n            \n            keyboard = self._get_performance_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚ö° Performance analytics loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in performance analytics: {e}\")\n            await callback.answer(\"‚ùå Failed to load performance data\", show_alert=True)\n    \n    async def _get_comprehensive_channel_stats(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get comprehensive channel statistics\"\"\"\n        try:\n            channels = await self.universal_db.get_user_channels_with_stats(user_id)\n            \n            if not channels:\n                return {'channels': [], 'total_members': 0, 'total_campaigns': 0, 'total_views': 0, 'avg_success_rate': 0, 'top_channels': [], 'member_growth': 0, 'new_campaigns': 0, 'view_growth': 0, 'peak_hour': 19, 'best_day': 'Monday', 'avg_views_per_campaign': 0}\n            \n            total_members = sum(c.get('member_count', 0) for c in channels)\n            total_campaigns = sum(c.get('campaign_stats', {}).get('total', 0) for c in channels)\n            \n            # Get total views from campaigns\n            total_views_result = await self.db.fetch_one(\n                \"\"\"\n                SELECT COALESCE(SUM(current_views), 0) as total\n                FROM view_boost_campaigns vbc\n                JOIN telegram_channels c ON vbc.channel_id = c.id\n                WHERE vbc.user_id = $1\n                \"\"\",\n                user_id\n            )\n            total_views = total_views_result['total'] if total_views_result else 0\n            \n            # Calculate average success rate\n            success_rates = []\n            for channel in channels:\n                stats = channel.get('campaign_stats', {}).get('by_status', {})\n                total = sum(stats.values()) if stats else 0\n                completed = stats.get('completed', 0)\n                if total > 0:\n                    success_rates.append((completed / total) * 100)\n            \n            avg_success_rate = sum(success_rates) / len(success_rates) if success_rates else 0\n            \n            # Sort channels by performance\n            top_channels = []\n            for channel in channels:\n                top_channels.append({\n                    'title': channel['title'],\n                    'members': channel.get('member_count', 0),\n                    'campaigns': channel.get('campaign_stats', {}).get('total', 0),\n                    'views': channel.get('campaign_stats', {}).get('total', 0) * 500  # Estimate\n                })\n            \n            top_channels.sort(key=lambda x: x['views'], reverse=True)\n            \n            return {\n                'channels': channels,\n                'total_members': total_members,\n                'total_campaigns': total_campaigns,\n                'total_views': total_views,\n                'avg_success_rate': avg_success_rate,\n                'top_channels': top_channels,\n                'member_growth': 0,  # Would calculate from historical data\n                'new_campaigns': 0,  # Would calculate from recent data\n                'view_growth': 0,  # Would calculate from historical data\n                'peak_hour': 19,  # Would calculate from actual data\n                'best_day': 'Monday',  # Would calculate from actual data\n                'avg_views_per_campaign': total_views / total_campaigns if total_campaigns > 0 else 0\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting comprehensive channel stats: {e}\")\n            return {'channels': [], 'total_members': 0, 'total_campaigns': 0, 'total_views': 0, 'avg_success_rate': 0, 'top_channels': [], 'member_growth': 0, 'new_campaigns': 0, 'view_growth': 0, 'peak_hour': 19, 'best_day': 'Monday', 'avg_views_per_campaign': 0}\n    \n    async def _get_comprehensive_boost_stats(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get comprehensive boost statistics\"\"\"\n        try:\n            # Get campaign stats\n            campaign_stats = await self.db.fetch_all(\n                \"\"\"\n                SELECT status, COUNT(*) as count, SUM(target_views) as target, SUM(current_views) as current\n                FROM view_boost_campaigns\n                WHERE user_id = $1\n                GROUP BY status\n                \"\"\",\n                user_id\n            )\n            \n            total_campaigns = sum(s['count'] for s in campaign_stats)\n            active_campaigns = sum(s['count'] for s in campaign_stats if s['status'] == 'active')\n            completed_campaigns = sum(s['count'] for s in campaign_stats if s['status'] == 'completed')\n            \n            success_rate = (completed_campaigns / total_campaigns * 100) if total_campaigns > 0 else 0\n            \n            # Get view statistics\n            total_views = sum(s['current'] or 0 for s in campaign_stats)\n            \n            # Get time-based statistics\n            monthly_views = await self.db.fetch_one(\n                \"\"\"\n                SELECT COALESCE(SUM(current_views), 0) as views\n                FROM view_boost_campaigns\n                WHERE user_id = $1 AND created_at >= NOW() - INTERVAL '30 days'\n                \"\"\",\n                user_id\n            )\n            \n            weekly_views = await self.db.fetch_one(\n                \"\"\"\n                SELECT COALESCE(SUM(current_views), 0) as views\n                FROM view_boost_campaigns\n                WHERE user_id = $1 AND created_at >= NOW() - INTERVAL '7 days'\n                \"\"\",\n                user_id\n            )\n            \n            daily_views = await self.db.fetch_one(\n                \"\"\"\n                SELECT COALESCE(SUM(current_views), 0) as views\n                FROM view_boost_campaigns\n                WHERE user_id = $1 AND created_at >= NOW() - INTERVAL '1 day'\n                \"\"\",\n                user_id\n            )\n            \n            return {\n                'total_campaigns': total_campaigns,\n                'active_campaigns': active_campaigns,\n                'success_rate': success_rate,\n                'avg_completion_time': 2.5,  # Would calculate from actual data\n                'total_views': total_views,\n                'monthly_views': monthly_views['views'] if monthly_views else 0,\n                'weekly_views': weekly_views['views'] if weekly_views else 0,\n                'daily_views': daily_views['views'] if daily_views else 0,\n                'daily_average': total_views / 30 if total_views > 0 else 0,\n                'peak_views': daily_views['views'] if daily_views else 0,\n                'growth_rate': 5.0,  # Would calculate from historical data\n                'manual_campaigns': sum(s['count'] for s in campaign_stats if s.get('campaign_type') == 'manual'),\n                'auto_campaigns': sum(s['count'] for s in campaign_stats if s.get('campaign_type') == 'auto'),\n                'manual_percentage': 60.0,  # Would calculate\n                'auto_percentage': 40.0,  # Would calculate\n                'peak_hours': [(19, 1500), (20, 1200), (18, 1000)],  # Would calculate\n                'top_boost_channels': [\n                    {'title': 'Channel 1', 'total_boosted': 5000},\n                    {'title': 'Channel 2', 'total_boosted': 3000},\n                    {'title': 'Channel 3', 'total_boosted': 2000}\n                ]\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting comprehensive boost stats: {e}\")\n            return {\n                'total_campaigns': 0, 'active_campaigns': 0, 'success_rate': 0,\n                'avg_completion_time': 0, 'total_views': 0, 'monthly_views': 0,\n                'weekly_views': 0, 'daily_views': 0, 'daily_average': 0,\n                'peak_views': 0, 'growth_rate': 0, 'manual_campaigns': 0,\n                'auto_campaigns': 0, 'manual_percentage': 0, 'auto_percentage': 0,\n                'peak_hours': [], 'top_boost_channels': []\n            }\n    \n    async def _get_account_analytics(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get account analytics\"\"\"\n        try:\n            accounts = await self.universal_db.get_accounts_with_health(user_id)\n            \n            if not accounts:\n                return {'accounts': [], 'active_count': 0, 'verified_count': 0, 'avg_health_score': 0, 'total_api_calls': 0, 'monthly_calls': 0, 'success_rate': 0, 'rate_limit_hits': 0, 'top_accounts': [], 'daily_avg_calls': 0, 'utilization_rate': 0, 'error_rate': 0, 'critical_health': 0, 'rate_limited': 0, 'inactive_count': 0}\n            \n            active_count = len([a for a in accounts if a['is_active']])\n            verified_count = len([a for a in accounts if a['is_verified']])\n            avg_health = sum(a['health_score'] for a in accounts) / len(accounts)\n            \n            # Calculate other metrics (would be from actual usage data)\n            total_api_calls = len(accounts) * 1000  # Estimate\n            monthly_calls = len(accounts) * 500  # Estimate\n            \n            return {\n                'accounts': accounts,\n                'active_count': active_count,\n                'verified_count': verified_count,\n                'avg_health_score': avg_health,\n                'total_api_calls': total_api_calls,\n                'monthly_calls': monthly_calls,\n                'success_rate': 95.0,  # Would calculate from logs\n                'rate_limit_hits': 5,  # Would calculate from logs\n                'top_accounts': accounts[:3],  # Top 3 by health\n                'daily_avg_calls': monthly_calls / 30,\n                'utilization_rate': 75.0,  # Would calculate\n                'error_rate': 2.5,  # Would calculate from logs\n                'critical_health': len([a for a in accounts if a['health_score'] < 50]),\n                'rate_limited': 1,  # Would calculate\n                'inactive_count': len([a for a in accounts if not a['is_active']])\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting account analytics: {e}\")\n            return {'accounts': [], 'active_count': 0, 'verified_count': 0, 'avg_health_score': 0, 'total_api_calls': 0, 'monthly_calls': 0, 'success_rate': 0, 'rate_limit_hits': 0, 'top_accounts': [], 'daily_avg_calls': 0, 'utilization_rate': 0, 'error_rate': 0, 'critical_health': 0, 'rate_limited': 0, 'inactive_count': 0}\n    \n    async def _get_detailed_channel_analytics(self, channel_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get detailed analytics for specific channel\"\"\"\n        try:\n            channel = await self.db.get_channel_by_id(channel_id)\n            if not channel:\n                return None\n            \n            # Get campaign stats for this channel\n            campaigns = await self.db.fetch_all(\n                \"SELECT * FROM view_boost_campaigns WHERE channel_id = $1\",\n                channel_id\n            )\n            \n            total_campaigns = len(campaigns)\n            active_campaigns = len([c for c in campaigns if c['status'] == 'active'])\n            completed_campaigns = len([c for c in campaigns if c['status'] == 'completed'])\n            \n            success_rate = (completed_campaigns / total_campaigns * 100) if total_campaigns > 0 else 0\n            \n            total_views_boosted = sum(c['current_views'] for c in campaigns)\n            total_target_views = sum(c['target_views'] for c in campaigns)\n            \n            return {\n                'channel': channel,\n                'stats': {\n                    'total_campaigns': total_campaigns,\n                    'active_campaigns': active_campaigns,\n                    'completed_campaigns': completed_campaigns,\n                    'success_rate': success_rate,\n                    'total_views_boosted': total_views_boosted,\n                    'total_target_views': total_target_views,\n                    'avg_views_per_campaign': total_views_boosted / total_campaigns if total_campaigns > 0 else 0,\n                    'best_campaign_views': max((c['current_views'] for c in campaigns), default=0),\n                    'member_growth': 0,  # Would calculate from historical data\n                    'campaign_growth': 0,  # Would calculate\n                    'view_growth': 0,  # Would calculate\n                    'peak_activity_hour': 19,  # Would calculate from actual data\n                    'peak_activity_day': 'Monday',  # Would calculate\n                    'last_campaign_date': max((c['created_at'] for c in campaigns), default=datetime.now()).strftime('%Y-%m-%d') if campaigns else 'Never',\n                    'recent_campaigns': len([c for c in campaigns if c['created_at'] >= datetime.now() - timedelta(days=7)]),\n                    'recent_views': sum(c['current_views'] for c in campaigns if c['created_at'] >= datetime.now() - timedelta(days=7)),\n                    'daily_average': total_views_boosted / 30 if total_views_boosted > 0 else 0\n                }\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting detailed channel analytics: {e}\")\n            return None\n    \n    async def _get_analytics_overview(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get analytics overview\"\"\"\n        try:\n            # Get basic counts\n            channels_count = await self.db.fetch_one(\n                \"SELECT COUNT(*) as count FROM telegram_channels WHERE user_id = $1 AND is_active = TRUE\",\n                user_id\n            )\n            \n            accounts_count = await self.db.fetch_one(\n                \"SELECT COUNT(*) as count FROM telegram_accounts WHERE user_id = $1\",\n                user_id\n            )\n            \n            campaigns_count = await self.db.fetch_one(\n                \"SELECT COUNT(*) as count FROM view_boost_campaigns WHERE user_id = $1\",\n                user_id\n            )\n            \n            total_views = await self.db.fetch_one(\n                \"SELECT COALESCE(SUM(current_views), 0) as total FROM view_boost_campaigns WHERE user_id = $1\",\n                user_id\n            )\n            \n            return {\n                'channels': channels_count['count'] if channels_count else 0,\n                'accounts': accounts_count['count'] if accounts_count else 0,\n                'campaigns': campaigns_count['count'] if campaigns_count else 0,\n                'total_views': total_views['total'] if total_views else 0,\n                'monthly_campaigns': 15,  # Would calculate from actual data\n                'monthly_views': 5000,  # Would calculate\n                'monthly_success_rate': 95.0,  # Would calculate\n                'monthly_growth': 12.5,  # Would calculate\n                'top_channel': 'My Best Channel',  # Would calculate\n                'best_day': 'Monday',  # Would calculate\n                'best_day_views': 1500,  # Would calculate\n                'peak_hour': 19,  # Would calculate\n                'avg_daily_views': 200,  # Would calculate\n                'active_accounts': 5,  # Would calculate\n                'total_accounts': 8,  # Would calculate\n                'uptime': 99.5,  # Would calculate\n                'overall_success_rate': 96.2,  # Would calculate\n                'avg_response_time': 1.2,  # Would calculate\n                'auto_boost_usage': 60.0,  # Would calculate\n                'manual_boost_usage': 30.0,  # Would calculate\n                'reactions_usage': 8.0,  # Would calculate\n                'live_usage': 2.0,  # Would calculate\n                'last_activity': '2 hours ago',  # Would calculate\n                'today_campaigns': 3,  # Would calculate\n                'today_views': 450  # Would calculate\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting analytics overview: {e}\")\n            return {}\n    \n    async def _generate_analytics_report(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Generate comprehensive analytics report\"\"\"\n        try:\n            # This would generate a comprehensive report\n            # For now, returning a structured example\n            return {\n                'summary': {\n                    'channels': 5,\n                    'accounts': 8,\n                    'campaigns': 45,\n                    'views': 15000\n                },\n                'metrics': {\n                    'success_rate': 94.5,\n                    'avg_campaign_size': 333,\n                    'best_day': 'Monday',\n                    'top_channel': 'Main Channel'\n                },\n                'channels': [\n                    {'title': 'Channel 1', 'campaigns': 15, 'views': 5000},\n                    {'title': 'Channel 2', 'campaigns': 12, 'views': 4000},\n                ],\n                'accounts': {\n                    'active': 7,\n                    'total': 8,\n                    'avg_health': 89.2,\n                    'api_calls': 25000\n                },\n                'trends': {\n                    'daily_avg': 500,\n                    'growth': 8.5,\n                    'peak_hour': 19\n                },\n                'campaign_types': {\n                    'manual': 25,\n                    'auto': 20,\n                    'scheduled': 3,\n                    'manual_pct': 55.6,\n                    'auto_pct': 44.4\n                },\n                'insights': [\n                    'Peak performance occurs at 7-9 PM',\n                    'Monday shows highest engagement rates',\n                    'Auto campaigns have 5% higher success rate',\n                    'Account health scores are above average'\n                ]\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error generating analytics report: {e}\")\n            return {}\n    \n    async def _get_performance_metrics(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get performance metrics\"\"\"\n        try:\n            # This would calculate actual performance metrics\n            return {\n                'avg_response_time': 1.25,\n                'success_rate': 96.8,\n                'uptime': 99.2,\n                'error_rate': 1.5,\n                'views_per_hour': 125,\n                'campaigns_per_hour': 0.8,\n                'api_calls_per_hour': 850,\n                'reactions_per_hour': 45,\n                'account_utilization': 78.5,\n                'rate_limit_usage': 65.2,\n                'db_load': 45.8,\n                'memory_usage': 62.3,\n                'speed_trend': 8.5,\n                'success_trend': 2.1,\n                'throughput_trend': 12.8,\n                'optimizations': [\n                    'Consider adding more accounts for better distribution',\n                    'Peak hour scheduling could improve efficiency',\n                    'Database queries could be optimized for better performance'\n                ],\n                'slow_queries': 3,\n                'failed_operations': 12,\n                'rate_limit_hits': 8,\n                'timeout_errors': 2\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting performance metrics: {e}\")\n            return {}\n    \n    # Keyboard methods\n    def _get_channel_stats_keyboard(self, channel_count: int) -> InlineKeyboardMarkup:\n        \"\"\"Get channel stats keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìä Detailed View\", callback_data=\"an_channel_detailed\"),\n                InlineKeyboardButton(text=\"üìà Growth Trends\", callback_data=\"an_channel_growth\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üèÜ Top Performers\", callback_data=\"an_top_channels\"),\n                InlineKeyboardButton(text=\"üìã Channel List\", callback_data=\"an_channel_list\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üìä Compare Channels\", callback_data=\"an_compare\"),\n                InlineKeyboardButton(text=\"üì§ Export Data\", callback_data=\"an_export_channels\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Analytics\", callback_data=\"analytics\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_boost_stats_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get boost stats keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìà Performance Trends\", callback_data=\"an_boost_trends\"),\n                InlineKeyboardButton(text=\"üïê Time Analysis\", callback_data=\"an_boost_timing\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üéØ Campaign Analysis\", callback_data=\"an_campaign_analysis\"),\n                InlineKeyboardButton(text=\"üìä Success Factors\", callback_data=\"an_success_factors\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üì§ Export Report\", callback_data=\"an_export_boost\"),\n                InlineKeyboardButton(text=\"üîÑ Refresh Stats\", callback_data=\"an_boost_stats\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Analytics\", callback_data=\"analytics\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_account_stats_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get account stats keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üè• Health Analysis\", callback_data=\"an_health_analysis\"),\n                InlineKeyboardButton(text=\"üìä Usage Patterns\", callback_data=\"an_usage_patterns\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚ö° Performance Metrics\", callback_data=\"an_account_performance\"),\n                InlineKeyboardButton(text=\"üö® Alert Summary\", callback_data=\"an_account_alerts\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üì§ Export Report\", callback_data=\"an_export_accounts\"),\n                InlineKeyboardButton(text=\"üîß Optimize Accounts\", callback_data=\"an_optimize\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Analytics\", callback_data=\"analytics\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_channel_analytics_keyboard(self, channel_id: int) -> InlineKeyboardMarkup:\n        \"\"\"Get channel analytics keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìä Full Report\", callback_data=f\"an_full_report_{channel_id}\"),\n                InlineKeyboardButton(text=\"üìà Growth Chart\", callback_data=f\"an_growth_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üöÄ Campaign History\", callback_data=f\"an_campaigns_{channel_id}\"),\n                InlineKeyboardButton(text=\"üë• Member Analysis\", callback_data=f\"an_members_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üì§ Export Data\", callback_data=f\"an_export_channel_{channel_id}\"),\n                InlineKeyboardButton(text=\"üîÑ Refresh\", callback_data=f\"an_channel_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Channels\", callback_data=\"an_channel_stats\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_overview_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get overview keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìä Detailed Analytics\", callback_data=\"an_detailed_overview\"),\n                InlineKeyboardButton(text=\"üìà Trends Analysis\", callback_data=\"an_trends\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üéØ Performance Insights\", callback_data=\"an_insights\"),\n                InlineKeyboardButton(text=\"üîç Deep Dive\", callback_data=\"an_deep_dive\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üì§ Full Report\", callback_data=\"an_export\"),\n                InlineKeyboardButton(text=\"üîÑ Refresh Overview\", callback_data=\"an_overview\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Analytics\", callback_data=\"analytics\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_export_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get export keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìä Generate New Report\", callback_data=\"an_generate_report\"),\n                InlineKeyboardButton(text=\"‚è∞ Schedule Reports\", callback_data=\"an_schedule_reports\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üìß Email Report\", callback_data=\"an_email_report\"),\n                InlineKeyboardButton(text=\"üíæ Save Report\", callback_data=\"an_save_report\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Analytics\", callback_data=\"analytics\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_performance_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get performance keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìà Real-time Monitor\", callback_data=\"an_realtime_monitor\"),\n                InlineKeyboardButton(text=\"‚ö° Optimization Tips\", callback_data=\"an_optimization\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üö® Alert Settings\", callback_data=\"an_alert_settings\"),\n                InlineKeyboardButton(text=\"üìä Historical Data\", callback_data=\"an_historical\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîß System Tuning\", callback_data=\"an_tuning\"),\n                InlineKeyboardButton(text=\"üì§ Performance Report\", callback_data=\"an_perf_report\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Analytics\", callback_data=\"analytics\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_no_data_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get no data keyboard\"\"\"\n        buttons = [\n            [InlineKeyboardButton(text=\"‚ûï Add Channel\", callback_data=\"channel_management\")],\n            [InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_no_accounts_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get no accounts keyboard\"\"\"\n        buttons = [\n            [InlineKeyboardButton(text=\"üì± Add Account\", callback_data=\"account_management\")],\n            [InlineKeyboardButton(text=\"üîô Back to Analytics\", callback_data=\"analytics\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    async def _handle_system_info(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle system information display\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get system information\n            system_info = await self._get_system_information()\n            \n            text = f\"\"\"\nüíæ <b>System Information</b>\n\n<b>üñ•Ô∏è Server Stats:</b>\n‚Ä¢ CPU Usage: {system_info['cpu_usage']:.1f}%\n‚Ä¢ RAM Usage: {system_info['ram_usage']:.1f}% ({system_info['ram_used']:.1f}GB / {system_info['ram_total']:.1f}GB)\n‚Ä¢ Disk Usage: {system_info['disk_usage']:.1f}% ({system_info['disk_used']:.1f}GB / {system_info['disk_total']:.1f}GB)\n‚Ä¢ Uptime: {system_info['uptime']}\n\n<b>üêç Python Environment:</b>\n‚Ä¢ Python Version: {system_info['python_version']}\n‚Ä¢ Process Memory: {system_info['process_memory']:.1f}MB\n‚Ä¢ Active Threads: {system_info['active_threads']}\n‚Ä¢ Event Loop Status: {system_info['event_loop_status']}\n\n<b>üóÑÔ∏è Database Info:</b>\n‚Ä¢ Connection Status: {system_info['db_status']}\n‚Ä¢ Active Connections: {system_info['db_connections']}\n‚Ä¢ Query Performance: {system_info['avg_query_time']:.2f}ms\n‚Ä¢ Database Size: {system_info['db_size']}\n\n<b>üîó Network Stats:</b>\n‚Ä¢ Telegram API Status: {system_info['telegram_status']}\n‚Ä¢ HTTP Requests/min: {system_info['http_requests_per_min']}\n‚Ä¢ API Rate Limits: {system_info['rate_limit_status']}\n\n<b>üì± Bot Status:</b>\n‚Ä¢ Active Handlers: {system_info['active_handlers']}\n‚Ä¢ Message Queue: {system_info['message_queue_size']} messages\n‚Ä¢ Error Rate: {system_info['error_rate']:.2f}%\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"üîÑ Refresh System Info\", callback_data=\"an_system_info\")],\n                [InlineKeyboardButton(text=\"‚ö° Performance Optimization\", callback_data=\"an_optimize_system\")],\n                [InlineKeyboardButton(text=\"üìä Detailed Metrics\", callback_data=\"an_detailed_system\")],\n                [InlineKeyboardButton(text=\"üîô Back\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üíæ System information loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in system info: {e}\")\n            await callback.answer(\"‚ùå Failed to load system information\", show_alert=True)\n    \n    async def _handle_engine_status(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle engine status display\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get engine status\n            engine_status = await self._get_engine_status()\n            \n            text = f\"\"\"\n‚ö° <b>Engine Status</b>\n\n<b>üîß Core Components:</b>\n‚Ä¢ Channel Manager: {engine_status['channel_manager_status']}\n‚Ä¢ View Booster: {engine_status['view_booster_status']}\n‚Ä¢ Account Manager: {engine_status['account_manager_status']}\n‚Ä¢ Live Monitor: {engine_status['live_monitor_status']}\n‚Ä¢ Emoji Reactor: {engine_status['emoji_reactor_status']}\n\n<b>üìä Worker Status:</b>\n‚Ä¢ Active Workers: {engine_status['active_workers']}\n‚Ä¢ Queue Length: {engine_status['queue_length']} tasks\n‚Ä¢ Processing Rate: {engine_status['processing_rate']} tasks/min\n‚Ä¢ Worker Health: {engine_status['worker_health']}\n\n<b>üéØ Performance Metrics:</b>\n‚Ä¢ Success Rate: {engine_status['overall_success_rate']:.1f}%\n‚Ä¢ Average Response Time: {engine_status['avg_response_time']:.2f}s\n‚Ä¢ Error Recovery Rate: {engine_status['error_recovery_rate']:.1f}%\n‚Ä¢ Uptime: {engine_status['engine_uptime']}\n\n<b>üöÄ Recent Activity:</b>\n‚Ä¢ Operations Last Hour: {engine_status['operations_last_hour']}\n‚Ä¢ Successful Operations: {engine_status['successful_operations']}\n‚Ä¢ Failed Operations: {engine_status['failed_operations']}\n‚Ä¢ Recovery Actions: {engine_status['recovery_actions']}\n\n<b>‚öôÔ∏è Resource Usage:</b>\n‚Ä¢ Memory per Worker: {engine_status['memory_per_worker']:.1f}MB\n‚Ä¢ CPU per Worker: {engine_status['cpu_per_worker']:.1f}%\n‚Ä¢ Database Queries/min: {engine_status['db_queries_per_min']}\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"üîÑ Refresh Engine Status\", callback_data=\"an_engine_status\")],\n                [InlineKeyboardButton(text=\"üîß Engine Settings\", callback_data=\"an_engine_settings\")],\n                [InlineKeyboardButton(text=\"üöÄ Optimize Performance\", callback_data=\"an_optimize_engine\")],\n                [InlineKeyboardButton(text=\"üîô Back\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚ö° Engine status loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in engine status: {e}\")\n            await callback.answer(\"‚ùå Failed to load engine status\", show_alert=True)\n    \n    async def _get_system_information(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive system information\"\"\"\n        try:\n            import psutil\n            import platform\n            \n            # CPU and memory stats\n            cpu_usage = psutil.cpu_percent(interval=1)\n            memory = psutil.virtual_memory()\n            disk = psutil.disk_usage('/')\n            \n            # Database stats\n            db_stats = await self._get_database_stats()\n            \n            return {\n                'cpu_usage': cpu_usage,\n                'ram_usage': memory.percent,\n                'ram_used': memory.used / (1024**3),\n                'ram_total': memory.total / (1024**3),\n                'disk_usage': disk.percent,\n                'disk_used': disk.used / (1024**3),\n                'disk_total': disk.total / (1024**3),\n                'uptime': self._format_uptime(),\n                'python_version': platform.python_version(),\n                'process_memory': psutil.Process().memory_info().rss / (1024**2),\n                'active_threads': len(psutil.Process().threads()),\n                'event_loop_status': 'üü¢ Running',\n                'db_status': db_stats['status'],\n                'db_connections': db_stats['connections'],\n                'avg_query_time': db_stats['avg_query_time'],\n                'db_size': db_stats['size'],\n                'telegram_status': 'üü¢ Connected',\n                'http_requests_per_min': 45,\n                'rate_limit_status': 'üü¢ Normal',\n                'active_handlers': 7,\n                'message_queue_size': 0,\n                'error_rate': 0.5\n            }\n        except Exception as e:\n            logger.error(f\"Error getting system information: {e}\")\n            return {\n                'cpu_usage': 0, 'ram_usage': 0, 'ram_used': 0, 'ram_total': 0,\n                'disk_usage': 0, 'disk_used': 0, 'disk_total': 0, 'uptime': 'Unknown',\n                'python_version': 'Unknown', 'process_memory': 0, 'active_threads': 0,\n                'event_loop_status': '‚ùå Error', 'db_status': '‚ùå Error',\n                'db_connections': 0, 'avg_query_time': 0, 'db_size': 'Unknown',\n                'telegram_status': '‚ùå Error', 'http_requests_per_min': 0,\n                'rate_limit_status': '‚ùå Error', 'active_handlers': 0,\n                'message_queue_size': 0, 'error_rate': 100\n            }\n    \n    async def _get_engine_status(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive engine status\"\"\"\n        try:\n            return {\n                'channel_manager_status': 'üü¢ Running',\n                'view_booster_status': 'üü¢ Running', \n                'account_manager_status': 'üü¢ Running',\n                'live_monitor_status': 'üü¢ Running',\n                'emoji_reactor_status': 'üü¢ Running',\n                'active_workers': 5,\n                'queue_length': 0,\n                'processing_rate': 12,\n                'worker_health': 'üü¢ Excellent',\n                'overall_success_rate': 98.5,\n                'avg_response_time': 1.2,\n                'error_recovery_rate': 99.2,\n                'engine_uptime': self._format_uptime(),\n                'operations_last_hour': 156,\n                'successful_operations': 153,\n                'failed_operations': 3,\n                'recovery_actions': 2,\n                'memory_per_worker': 45.2,\n                'cpu_per_worker': 12.5,\n                'db_queries_per_min': 89\n            }\n        except Exception as e:\n            logger.error(f\"Error getting engine status: {e}\")\n            return {\n                'channel_manager_status': '‚ùå Error', 'view_booster_status': '‚ùå Error',\n                'account_manager_status': '‚ùå Error', 'live_monitor_status': '‚ùå Error',\n                'emoji_reactor_status': '‚ùå Error', 'active_workers': 0,\n                'queue_length': 0, 'processing_rate': 0, 'worker_health': '‚ùå Error',\n                'overall_success_rate': 0, 'avg_response_time': 0,\n                'error_recovery_rate': 0, 'engine_uptime': 'Unknown',\n                'operations_last_hour': 0, 'successful_operations': 0,\n                'failed_operations': 0, 'recovery_actions': 0,\n                'memory_per_worker': 0, 'cpu_per_worker': 0, 'db_queries_per_min': 0\n            }\n    \n    def _format_uptime(self) -> str:\n        \"\"\"Format uptime string\"\"\"\n        try:\n            uptime_seconds = time.time() - psutil.boot_time()\n            days = int(uptime_seconds // 86400)\n            hours = int((uptime_seconds % 86400) // 3600)\n            minutes = int((uptime_seconds % 3600) // 60)\n            return f\"{days}d {hours}h {minutes}m\"\n        except:\n            return \"Unknown\"\n    \n    async def _get_database_stats(self) -> Dict[str, Any]:\n        \"\"\"Get database statistics\"\"\"\n        try:\n            # Check database connection\n            result = await self.db.fetch_one(\"SELECT 1 as test\")\n            if result:\n                return {\n                    'status': 'üü¢ Connected',\n                    'connections': 5,\n                    'avg_query_time': 2.5,\n                    'size': '47.2MB'\n                }\n            else:\n                return {\n                    'status': '‚ùå Disconnected',\n                    'connections': 0,\n                    'avg_query_time': 0,\n                    'size': 'Unknown'\n                }\n        except Exception as e:\n            return {\n                'status': '‚ùå Error',\n                'connections': 0,\n                'avg_query_time': 0,\n                'size': 'Unknown'\n            }\n    \n    async def shutdown(self):\n        \"\"\"Shutdown analytics handler\"\"\"\n        logger.info(\"‚úÖ Analytics handler shut down\")\n","size_bytes":57865},"features/channel_management/__init__.py":{"content":"\"\"\"\nChannel Management Feature\nHandles adding, managing, and configuring Telegram channels\n\"\"\"\n\nfrom .handler import ChannelManagementHandler\n\n__all__ = ['ChannelManagementHandler']\n","size_bytes":182},"features/channel_management/handler.py":{"content":"\"\"\"\nChannel Management Handler - ArcX Bot\nUniversal link handler for any channel type with simplified management\n\"\"\"\n\nimport asyncio\nimport logging\nimport uuid\nimport re\nfrom typing import Dict, Any, List, Optional\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import CallbackQuery, Message\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\nfrom aiogram.fsm.state import State, StatesGroup\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\n\nlogger = logging.getLogger(__name__)\n\n\nclass ChannelStates(StatesGroup):\n    \"\"\"FSM states for channel management\"\"\"\n    waiting_for_channel_link = State()\n\n\nclass ChannelManagementHandler:\n    \"\"\"Simplified Channel Manager with universal link handler\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config, bot_core=None):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.bot_core = bot_core\n        self._pending_channels = {}  # Store temporary channel data during setup\n        \n    async def initialize(self):\n        \"\"\"Initialize channel management handler\"\"\"\n        try:\n            logger.info(\"‚úÖ Channel management handler initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize channel management handler: {e}\")\n            raise\n    \n    def register_handlers(self, dp: Dispatcher):\n        \"\"\"Register handlers with dispatcher\"\"\"\n        # FSM message handlers\n        dp.message.register(self.handle_channel_link_input, ChannelStates.waiting_for_channel_link)\n        \n        logger.info(\"‚úÖ Channel management handlers registered\")\n    \n    async def handle_callback(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle channel management callbacks\"\"\"\n        try:\n            callback_data = callback.data\n            user_id = callback.from_user.id\n            \n            # Ensure user exists in database\n            await self._ensure_user_exists(callback.from_user)\n            \n            if callback_data == \"cm_add_channel\":\n                await self._handle_add_channel(callback, state)\n            elif callback_data == \"cm_remove_channel\":\n                await self._handle_remove_channel(callback, state)\n            elif callback_data == \"cm_list_channels\":\n                await self._handle_list_channels(callback, state)\n            elif callback_data == \"cm_refresh\":\n                await self._handle_refresh_channels(callback, state)\n            elif callback_data.startswith(\"cm_info_\"):\n                await self._handle_channel_info(callback, state)\n            elif callback_data.startswith(\"cm_delete_\"):\n                await self._handle_delete_channel(callback, state)\n            else:\n                await callback.answer(\"‚ùå Unknown action\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error in channel management callback: {e}\")\n            await callback.answer(\"‚ùå An error occurred\", show_alert=True)\n    \n    async def _handle_add_channel(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Start add channel process with universal link handler\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Check channel limit\n            channels = await self._get_user_channels(user_id)\n            if len(channels) >= 50:  # Reasonable limit for channels\n                await callback.message.edit_text(\n                    \"üî• <b>ArcX | Channel Limit Reached</b>\\\\n\\\\n\"\n                    \"You have reached the maximum limit of 50 channels.\\\\n\"\n                    \"Remove some channels before adding new ones.\",\n                    reply_markup=self._get_back_keyboard()\n                )\n                await callback.answer(\"‚ö†Ô∏è Channel limit reached!\")\n                return\n            \n            text = \"\"\"üî• <b>ArcX | Add Channel</b>\n\n<b>Universal Link Handler - Supports any channel type:</b>\n\nüì∫ <b>Public Channels:</b>\n‚Ä¢ t.me/channel_name\n‚Ä¢ @channel_name\n\nüîí <b>Private Channels:</b>\n‚Ä¢ t.me/+abcdef123456\n‚Ä¢ t.me/joinchat/abcdef123456\n\nüé¨ <b>Video/Stream Links:</b>\n‚Ä¢ Links to specific videos or streams\n\nSend any channel link and the bot will automatically detect and add it:\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"channel_manager\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await state.set_state(ChannelStates.waiting_for_channel_link)\n            await callback.answer(\"üì∫ Send channel link\")\n            \n        except Exception as e:\n            logger.error(f\"Error in add channel: {e}\")\n            await callback.answer(\"‚ùå Failed to start add channel\", show_alert=True)\n    \n    async def handle_channel_link_input(self, message: Message, state: FSMContext):\n        \"\"\"Handle universal channel link input\"\"\"\n        try:\n            user_id = message.from_user.id\n            link = message.text.strip()\n            \n            # Parse channel link with universal handler\n            channel_data = await self._parse_channel_link(link)\n            \n            if not channel_data:\n                await message.answer(\n                    \"‚ùå <b>Invalid Channel Link</b>\\\\n\\\\n\"\n                    \"Please send a valid Telegram channel link:\\\\n\"\n                    \"‚Ä¢ t.me/channel_name\\\\n\"\n                    \"‚Ä¢ @channel_name\\\\n\"\n                    \"‚Ä¢ t.me/+invite_link\\\\n\"\n                    \"‚Ä¢ t.me/joinchat/invite_link\",\n                    reply_markup=self._get_retry_keyboard()\n                )\n                return\n            \n            # Check if channel already exists\n            existing = await self.db.fetch_one(\n                \"SELECT id FROM telegram_channels WHERE channel_identifier = $1 AND user_id = $2\",\n                channel_data['identifier'], user_id\n            )\n            \n            if existing:\n                await message.answer(\n                    f\"‚ùå <b>Channel Already Added</b>\\\\n\\\\n\"\n                    f\"Channel: {channel_data['title']}\\\\n\"\n                    f\"Type: {channel_data['type']}\\\\n\"\n                    f\"This channel is already in your list.\",\n                    reply_markup=self._get_retry_keyboard()\n                )\n                return\n            \n            # Generate unique channel ID\n            channel_uuid = str(uuid.uuid4())[:8]\n            \n            # Save channel to database\n            channel_id = await self.db.execute_query(\n                \"\"\"\n                INSERT INTO telegram_channels \n                (user_id, channel_identifier, channel_title, channel_type, unique_id, original_link, created_at, updated_at)\n                VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())\n                RETURNING id\n                \"\"\",\n                user_id, channel_data['identifier'], channel_data['title'], \n                channel_data['type'], channel_uuid, link\n            )\n            \n            text = f\"\"\"‚úÖ <b>ArcX | Channel Added Successfully!</b>\n\n<b>Channel Details:</b>\n‚Ä¢ Title: {channel_data['title']}\n‚Ä¢ Type: {channel_data['type'].title()}\n‚Ä¢ Unique ID: {channel_uuid}\n‚Ä¢ Members: {channel_data.get('members', 'Unknown')}\n‚Ä¢ Status: ‚úÖ Ready for operations\n\nChannel is available for all bot features!\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[üìã View All Channels]\", callback_data=\"cm_list_channels\")],\n                [InlineKeyboardButton(text=\"[‚ûï Add Another]\", callback_data=\"cm_add_channel\")],\n                [InlineKeyboardButton(text=\"[üîô Channel Manager]\", callback_data=\"channel_manager\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await message.answer(text, reply_markup=keyboard)\n            await state.clear()\n            \n        except Exception as e:\n            logger.error(f\"Error handling channel link: {e}\")\n            await message.answer(\"‚ùå Error processing channel link\")\n    \n    async def _handle_remove_channel(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle remove channel\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            channels = await self._get_user_channels(user_id)\n            if not channels:\n                await callback.message.edit_text(\n                    \"üî• <b>ArcX | No Channels Found</b>\\\\n\\\\n\"\n                    \"You don't have any channels to remove.\",\n                    reply_markup=self._get_back_keyboard()\n                )\n                await callback.answer(\"‚ÑπÔ∏è No channels to remove\")\n                return\n            \n            text = \"üî• <b>ArcX | Remove Channel</b>\\\\n\\\\nSelect channel to remove:\\\\n\\\\n\"\n            \n            buttons = []\n            for i, channel in enumerate(channels[:10], 1):  # Show max 10\n                button_text = f\"[üóëÔ∏è {channel['channel_title'][:20]}...]\"\n                callback_data = f\"cm_delete_{channel['id']}\"\n                buttons.append([InlineKeyboardButton(text=button_text, callback_data=callback_data)])\n            \n            buttons.extend([\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"channel_manager\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üóëÔ∏è Select channel to remove\")\n            \n        except Exception as e:\n            logger.error(f\"Error in remove channel: {e}\")\n            await callback.answer(\"‚ùå Failed to load remove channel\", show_alert=True)\n    \n    async def _handle_list_channels(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle list channels with info popups\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            channels = await self._get_user_channels(user_id)\n            if not channels:\n                await callback.message.edit_text(\n                    \"üî• <b>ArcX | No Channels</b>\\\\n\\\\n\"\n                    \"You haven't added any channels yet.\\\\n\"\n                    \"Add your first channel to get started!\",\n                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[\n                        [InlineKeyboardButton(text=\"[‚ûï Add Channel]\", callback_data=\"cm_add_channel\")],\n                        [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"channel_manager\")],\n                        [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n                    ])\n                )\n                await callback.answer(\"‚ÑπÔ∏è No channels found\")\n                return\n            \n            text = f\"üî• <b>ArcX | Channel List</b>\\\\n\\\\nTotal Channels: {len(channels)}\\\\n\\\\n\"\n            \n            buttons = []\n            for i, channel in enumerate(channels[:10], 1):  # Show max 10\n                title = channel['channel_title'][:15] + \"...\" if len(channel['channel_title']) > 15 else channel['channel_title']\n                status = \"‚úÖ\" if channel['is_active'] else \"‚ùå\"\n                \n                # Channel name button and info button in same row\n                buttons.append([\n                    InlineKeyboardButton(text=f\"[{i}. {status} {title}]\", callback_data=f\"cm_select_{channel['id']}\"),\n                    InlineKeyboardButton(text=\"[‚ÑπÔ∏è]\", callback_data=f\"cm_info_{channel['id']}\")\n                ])\n            \n            buttons.extend([\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"channel_manager\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(f\"üìã {len(channels)} channels loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error listing channels: {e}\")\n            await callback.answer(\"‚ùå Failed to load channels\", show_alert=True)\n    \n    async def _handle_channel_info(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Show detailed channel information popup\"\"\"\n        try:\n            channel_id = int(callback.data.split('_')[2])\n            \n            channel = await self.db.fetch_one(\n                \"SELECT * FROM telegram_channels WHERE id = $1\", channel_id\n            )\n            \n            if not channel:\n                await callback.answer(\"‚ùå Channel not found\", show_alert=True)\n                return\n            \n            # Get channel stats\n            stats = await self._get_channel_stats(channel)\n            \n            # Truncate long fields to avoid MESSAGE_TOO_LONG\n            title = (channel['channel_title'][:30] + '...') if len(channel['channel_title']) > 30 else channel['channel_title']\n            identifier = (channel['channel_identifier'][:25] + '...') if len(channel['channel_identifier']) > 25 else channel['channel_identifier']\n            \n            info_text = f\"\"\"üì∫ <b>ArcX | Channel Info</b>\n\n<b>Details:</b>\n‚Ä¢ {title}\n‚Ä¢ Type: {channel['channel_type'].title()}\n‚Ä¢ ID: {channel.get('unique_id', 'N/A')[:8]}\n‚Ä¢ Status: {\"‚úÖ Active\" if channel['is_active'] else \"‚ùå Inactive\"}\n\n<b>Stats:</b>\n‚Ä¢ Members: {stats.get('member_count', 'Unknown')}\n‚Ä¢ Views: {stats.get('total_views', 0)}\n‚Ä¢ Operations: {stats.get('total_operations', 0)}\n\n<b>Added:</b> {channel['created_at'].strftime('%Y-%m-%d')}\n            \"\"\"\n            \n            await callback.answer(info_text, show_alert=True)\n            \n        except Exception as e:\n            logger.error(f\"Error showing channel info: {e}\")\n            await callback.answer(\"‚ùå Error loading channel info\", show_alert=True)\n    \n    async def _handle_refresh_channels(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Refresh channels list\"\"\"\n        try:\n            # Show channel manager menu again with fresh data\n            text = \"üî• <b>ArcX | Channel Manager</b>\\\\n\\\\nUniversal channel management system:\\\\n\\\\n\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[‚ûï Add Channel]\", callback_data=\"cm_add_channel\")],\n                [InlineKeyboardButton(text=\"[üóëÔ∏è Remove Channel]\", callback_data=\"cm_remove_channel\")],\n                [InlineKeyboardButton(text=\"[üìã List Channels]\", callback_data=\"cm_list_channels\")],\n                [InlineKeyboardButton(text=\"[üîÑ Refresh Channels]\", callback_data=\"cm_refresh\")],\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"refresh_main\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üîÑ Channels refreshed!\")\n            \n        except Exception as e:\n            logger.error(f\"Error refreshing channels: {e}\")\n            await callback.answer(\"‚ùå Failed to refresh\", show_alert=True)\n    \n    async def _handle_delete_channel(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle channel deletion\"\"\"\n        try:\n            channel_id = int(callback.data.split('_')[2])\n            \n            # Get channel details\n            channel = await self.db.fetch_one(\n                \"SELECT * FROM telegram_channels WHERE id = $1\", channel_id\n            )\n            \n            if not channel:\n                await callback.answer(\"‚ùå Channel not found\", show_alert=True)\n                return\n            \n            # Delete from database\n            await self.db.execute_query(\n                \"DELETE FROM telegram_channels WHERE id = $1\", channel_id\n            )\n            \n            text = f\"\"\"‚úÖ <b>ArcX | Channel Removed</b>\n\nChannel successfully removed:\n‚Ä¢ Title: {channel['channel_title']}\n‚Ä¢ Type: {channel['channel_type'].title()}\n‚Ä¢ Unique ID: {channel.get('unique_id', 'N/A')}\n\nAll associated data has been cleaned up.\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[üìã View Remaining]\", callback_data=\"cm_list_channels\")],\n                [InlineKeyboardButton(text=\"[üîô Channel Manager]\", callback_data=\"channel_manager\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚úÖ Channel removed successfully!\")\n            \n        except Exception as e:\n            logger.error(f\"Error deleting channel: {e}\")\n            await callback.answer(\"‚ùå Failed to remove channel\", show_alert=True)\n    \n    async def _parse_channel_link(self, link: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Universal link parser for any channel type\"\"\"\n        try:\n            link = link.strip()\n            \n            # Remove protocol if present\n            if link.startswith('http://') or link.startswith('https://'):\n                link = link.split('://', 1)[1]\n            \n            # Patterns for different channel types\n            patterns = {\n                'public_username': r't\\.me/([a-zA-Z0-9_]+)$',\n                'private_invite': r't\\.me/\\+([a-zA-Z0-9_-]+)$',\n                'joinchat': r't\\.me/joinchat/([a-zA-Z0-9_-]+)$',\n                'username_direct': r'^@([a-zA-Z0-9_]+)$',\n                'plain_username': r'^([a-zA-Z0-9_]+)$'\n            }\n            \n            for channel_type, pattern in patterns.items():\n                match = re.match(pattern, link)\n                if match:\n                    identifier = match.group(1)\n                    \n                    # Determine channel type and title\n                    if channel_type in ['public_username', 'username_direct', 'plain_username']:\n                        return {\n                            'identifier': f\"@{identifier}\",\n                            'title': identifier,\n                            'type': 'public',\n                            'link': link,\n                            'members': await self._get_channel_member_count(f\"@{identifier}\")\n                        }\n                    else:\n                        return {\n                            'identifier': identifier,\n                            'title': f\"Private Channel ({identifier[:8]}...)\",\n                            'type': 'private',\n                            'link': link,\n                            'members': 'Private'\n                        }\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error parsing channel link: {e}\")\n            return None\n    \n    async def _get_channel_member_count(self, username: str) -> str:\n        \"\"\"Get member count for public channel\"\"\"\n        try:\n            # In a real implementation, this would use Telethon to get actual member count\n            # For now, return placeholder\n            return \"Unknown\"\n        except Exception:\n            return \"Unknown\"\n    \n    async def _get_channel_stats(self, channel: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Get channel statistics\"\"\"\n        try:\n            # Get basic stats from database\n            stats = await self.db.fetch_one(\n                \"\"\"\n                SELECT \n                    COUNT(*) as total_operations,\n                    COALESCE(AVG(CASE WHEN success THEN 1 ELSE 0 END) * 100, 0) as success_rate,\n                    COUNT(CASE WHEN operation_type = 'boost' THEN 1 END) as boost_count\n                FROM channel_operations \n                WHERE channel_id = $1\n                \"\"\",\n                channel['id']\n            )\n            \n            return {\n                'member_count': channel.get('member_count', 'Unknown'),\n                'total_views': channel.get('total_views', 0),\n                'avg_views': channel.get('avg_views', 0),\n                'last_boost': channel.get('last_boost', 'Never'),\n                'success_rate': int(stats.get('success_rate', 0)) if stats else 0,\n                'total_operations': stats.get('total_operations', 0) if stats else 0,\n                'boost_count': stats.get('boost_count', 0) if stats else 0\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting channel stats: {e}\")\n            return {}\n    \n    # Helper methods\n    async def _get_user_channels(self, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get user's channels\"\"\"\n        return await self.db.fetch_all(\n            \"SELECT * FROM telegram_channels WHERE user_id = $1 ORDER BY created_at DESC\",\n            user_id\n        )\n    \n    async def _ensure_user_exists(self, user):\n        \"\"\"Ensure user exists in database\"\"\"\n        await self.db.execute_query(\n            \"\"\"\n            INSERT INTO users (user_id, username, first_name, last_name, first_seen, last_seen)\n            VALUES ($1, $2, $3, $4, NOW(), NOW())\n            ON CONFLICT (user_id) DO UPDATE SET \n                username = $2, last_seen = NOW()\n            \"\"\",\n            user.id, user.username, user.first_name, user.last_name\n        )\n    \n    def _get_back_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get back button keyboard\"\"\"\n        return InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"[üîô Channel Manager]\", callback_data=\"channel_manager\")],\n            [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n        ])\n    \n    def _get_retry_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get retry keyboard\"\"\"\n        return InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"[üîÑ Try Again]\", callback_data=\"cm_add_channel\")],\n            [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"channel_manager\")]\n        ])","size_bytes":22629},"features/channel_management/keyboards.py":{"content":"\"\"\"\nChannel Management Keyboards\nInline keyboards for channel management operations\n\"\"\"\n\nfrom typing import List, Dict, Any\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n\n\nclass ChannelManagementKeyboards:\n    \"\"\"Keyboards for channel management\"\"\"\n    \n    def get_add_channel_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard for add channel start\"\"\"\n        buttons = [\n            [InlineKeyboardButton(text=\"üìù Enter Channel Info\", callback_data=\"cm_input_ready\")],\n            [InlineKeyboardButton(text=\"‚ùì Help\", callback_data=\"cm_add_help\")],\n            [InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_channel_added_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard after channel is successfully added\"\"\"\n        buttons = [\n            [InlineKeyboardButton(text=\"üöÄ Start Boosting\", callback_data=\"view_manager\")],\n            [InlineKeyboardButton(text=\"üìã View Channels\", callback_data=\"cm_list_channels\")],\n            [InlineKeyboardButton(text=\"‚ûï Add Another\", callback_data=\"cm_add_channel\")],\n            [InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_add_channel_retry_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard for retry adding channel\"\"\"\n        buttons = [\n            [InlineKeyboardButton(text=\"üîÑ Try Again\", callback_data=\"cm_add_channel\")],\n            [InlineKeyboardButton(text=\"‚ùì Get Help\", callback_data=\"cm_add_help\")],\n            [InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_no_channels_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard when user has no channels\"\"\"\n        buttons = [\n            [InlineKeyboardButton(text=\"‚ûï Add First Channel\", callback_data=\"cm_add_channel\")],\n            [InlineKeyboardButton(text=\"‚ùì How to Add Channels\", callback_data=\"cm_add_help\")],\n            [InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_channels_list_keyboard(self, channels: List[Dict[str, Any]]) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard for channels list\"\"\"\n        buttons = []\n        \n        # Add channel action buttons (max 5)\n        for channel in channels[:5]:\n            status = \"üü¢\" if channel['is_active'] else \"üî¥\"\n            buttons.append([\n                InlineKeyboardButton(\n                    text=f\"{status} {channel['title'][:30]}\",\n                    callback_data=f\"cm_channel_{channel['id']}\"\n                )\n            ])\n        \n        # Add control buttons\n        control_buttons = []\n        if len(channels) > 5:\n            control_buttons.append(\n                InlineKeyboardButton(text=\"üìÑ View All\", callback_data=\"cm_view_all_channels\")\n            )\n        \n        control_buttons.extend([\n            InlineKeyboardButton(text=\"‚ûï Add Channel\", callback_data=\"cm_add_channel\"),\n            InlineKeyboardButton(text=\"‚öôÔ∏è Settings\", callback_data=\"cm_settings\")\n        ])\n        \n        if control_buttons:\n            # Split control buttons into rows of 2\n            for i in range(0, len(control_buttons), 2):\n                buttons.append(control_buttons[i:i+2])\n        \n        # Back button\n        buttons.append([\n            InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_channel_actions_keyboard(self, channel_id: int) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard for individual channel actions\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üöÄ Boost Views\", callback_data=f\"vm_boost_channel_{channel_id}\"),\n                InlineKeyboardButton(text=\"üìä Analytics\", callback_data=f\"an_channel_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üé≠ Reactions\", callback_data=f\"er_channel_{channel_id}\"),\n                InlineKeyboardButton(text=\"üëÅÔ∏è Monitor\", callback_data=f\"vm_monitor_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚úèÔ∏è Edit\", callback_data=f\"cm_edit_{channel_id}\"),\n                InlineKeyboardButton(text=\"üóëÔ∏è Delete\", callback_data=f\"cm_delete_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîÑ Refresh Info\", callback_data=f\"cm_refresh_{channel_id}\"),\n                InlineKeyboardButton(text=\"‚öôÔ∏è Settings\", callback_data=f\"cm_settings_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Channels\", callback_data=\"cm_list_channels\")\n            ]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_settings_channels_keyboard(self, channels: List[Dict[str, Any]]) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard for selecting channel to configure\"\"\"\n        buttons = []\n        \n        # Add channels (max 8)\n        for channel in channels[:8]:\n            status = \"üü¢\" if channel['is_active'] else \"üî¥\"\n            buttons.append([\n                InlineKeyboardButton(\n                    text=f\"{status} {channel['title'][:35]}\",\n                    callback_data=f\"cm_settings_{channel['id']}\"\n                )\n            ])\n        \n        # Control buttons\n        if len(channels) > 8:\n            buttons.append([\n                InlineKeyboardButton(text=\"üìÑ More Channels\", callback_data=\"cm_settings_more\")\n            ])\n        \n        buttons.extend([\n            [InlineKeyboardButton(text=\"‚öôÔ∏è Global Settings\", callback_data=\"cm_global_settings\")],\n            [InlineKeyboardButton(text=\"üîô Back to Channels\", callback_data=\"cm_list_channels\")]\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_delete_confirmation_keyboard(self, channel_id: int) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard for delete confirmation\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"‚úÖ Yes, Delete\", callback_data=f\"cm_confirm_delete_{channel_id}\"),\n                InlineKeyboardButton(text=\"‚ùå Cancel\", callback_data=f\"cm_channel_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Channel\", callback_data=f\"cm_channel_{channel_id}\")\n            ]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_edit_channel_keyboard(self, channel_id: int) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard for editing channel\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìù Update Info\", callback_data=f\"cm_edit_info_{channel_id}\"),\n                InlineKeyboardButton(text=\"üîÑ Refresh Data\", callback_data=f\"cm_refresh_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üöÄ Boost Settings\", callback_data=f\"cm_edit_boost_{channel_id}\"),\n                InlineKeyboardButton(text=\"üé≠ Reaction Settings\", callback_data=f\"cm_edit_reactions_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üìä Analytics Settings\", callback_data=f\"cm_edit_analytics_{channel_id}\"),\n                InlineKeyboardButton(text=\"üîî Notifications\", callback_data=f\"cm_edit_notifications_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Channel\", callback_data=f\"cm_channel_{channel_id}\")\n            ]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_back_to_channel_keyboard(self, channel_id: int) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard to go back to channel\"\"\"\n        buttons = [\n            [InlineKeyboardButton(text=\"üîô Back to Channel\", callback_data=f\"cm_channel_{channel_id}\")]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_back_to_menu_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard to go back to main menu\"\"\"\n        buttons = [\n            [InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_channel_settings_keyboard(self, channel_id: int) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard for channel-specific settings\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üöÄ Default Boost Settings\", callback_data=f\"cm_set_boost_{channel_id}\"),\n                InlineKeyboardButton(text=\"‚è∞ Boost Schedule\", callback_data=f\"cm_set_schedule_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üé≠ Reaction Config\", callback_data=f\"cm_set_reactions_{channel_id}\"),\n                InlineKeyboardButton(text=\"üì± Account Assignment\", callback_data=f\"cm_set_accounts_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üìä Analytics Config\", callback_data=f\"cm_set_analytics_{channel_id}\"),\n                InlineKeyboardButton(text=\"üîî Alert Settings\", callback_data=f\"cm_set_alerts_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üíæ Save Settings\", callback_data=f\"cm_save_settings_{channel_id}\"),\n                InlineKeyboardButton(text=\"üîÑ Reset to Default\", callback_data=f\"cm_reset_settings_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Channel\", callback_data=f\"cm_channel_{channel_id}\")\n            ]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_batch_operations_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get keyboard for batch operations on channels\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üì• Bulk Add Channels\", callback_data=\"cm_bulk_add\"),\n                InlineKeyboardButton(text=\"üîÑ Refresh All\", callback_data=\"cm_refresh_all\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚öôÔ∏è Bulk Settings\", callback_data=\"cm_bulk_settings\"),\n                InlineKeyboardButton(text=\"üìä Export Data\", callback_data=\"cm_export_data\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üóëÔ∏è Bulk Delete\", callback_data=\"cm_bulk_delete\"),\n                InlineKeyboardButton(text=\"üîÑ Bulk Status\", callback_data=\"cm_bulk_status\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Channels\", callback_data=\"cm_list_channels\")\n            ]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n","size_bytes":10979},"features/channel_management/states.py":{"content":"\"\"\"\nChannel Management FSM States\nFinite State Machine states for channel management operations\n\"\"\"\n\nfrom aiogram.fsm.state import State, StatesGroup\n\n\nclass ChannelManagementStates(StatesGroup):\n    \"\"\"FSM states for channel management\"\"\"\n    \n    # Adding channel states\n    waiting_for_channel = State()\n    waiting_for_channel_confirmation = State()\n    waiting_for_invite_link = State()\n    \n    # Editing channel states\n    editing_channel_title = State()\n    editing_channel_description = State()\n    editing_channel_settings = State()\n    \n    # Channel validation states\n    validating_permissions = State()\n    confirming_channel_access = State()\n    \n    # Batch operations states\n    batch_adding_channels = State()\n    waiting_for_channel_list = State()\n    \n    # Settings configuration states\n    configuring_boost_settings = State()\n    configuring_notification_settings = State()\n    configuring_analytics_settings = State()\n\n\nclass ChannelSettingsStates(StatesGroup):\n    \"\"\"FSM states for channel settings configuration\"\"\"\n    \n    # General settings\n    updating_channel_info = State()\n    configuring_auto_refresh = State()\n    \n    # Boost settings\n    setting_default_boost_amount = State()\n    setting_boost_schedule = State()\n    setting_boost_accounts = State()\n    \n    # Reaction settings\n    configuring_reaction_emojis = State()\n    setting_reaction_timing = State()\n    setting_reaction_frequency = State()\n    \n    # Analytics settings\n    configuring_analytics_frequency = State()\n    setting_report_schedule = State()\n    configuring_alert_thresholds = State()\n    \n    # Notification settings\n    setting_notification_types = State()\n    configuring_notification_channels = State()\n    setting_quiet_hours = State()\n","size_bytes":1751},"features/channel_management/utils.py":{"content":"\"\"\"\nChannel Management Utilities\nHelper functions for channel validation and processing\n\"\"\"\n\nimport re\nimport logging\nfrom typing import Dict, Any, Optional, Union\nfrom urllib.parse import urlparse\n\nfrom telethon import TelegramClient\nfrom telethon.tl import types, functions\nfrom telethon.errors import ChannelPrivateError, UsernameNotModifiedError, FloodWaitError\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\nfrom core.bot.telegram_bot import TelegramBotCore\n\nlogger = logging.getLogger(__name__)\n\n\nclass ChannelValidator:\n    \"\"\"Channel validation and processing utilities\"\"\"\n    \n    def __init__(self, bot, db_manager: DatabaseManager, config: Config, bot_core=None):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.bot_core = bot_core if bot_core else TelegramBotCore(config, db_manager)\n        \n    async def validate_and_process_channel(self, user_id: int, channel_input: str) -> Dict[str, Any]:\n        \"\"\"Validate and process channel input\"\"\"\n        try:\n            # Parse channel input\n            channel_info = self._parse_channel_input(channel_input)\n            if not channel_info['valid']:\n                return {\n                    'success': False,\n                    'error': channel_info['error']\n                }\n            \n            # Get user's active accounts\n            user_accounts = await self.db.get_user_accounts(user_id, active_only=True)\n            if not user_accounts:\n                return {\n                    'success': False,\n                    'error': 'No active Telegram accounts found. Please add an account first.'\n                }\n            \n            # Try to resolve channel with user's accounts\n            channel_data = None\n            successful_account = None\n            validation_errors = []\n            \n            for account in user_accounts:\n                try:\n                    client = await self.bot_core.get_client(account['id'])\n                    if not client:\n                        validation_errors.append(f\"Account {account.get('phone_number', account['id'])}: Not connected\")\n                        continue\n                    \n                    # Check rate limits\n                    if not await self.bot_core.check_rate_limit(account['id']):\n                        validation_errors.append(f\"Account {account.get('phone_number', account['id'])}: Rate limited\")\n                        continue\n                    \n                    # Try to get channel entity\n                    result = await self._get_channel_entity_with_details(client, channel_info, account)\n                    if result['success']:\n                        channel_data = result['data']\n                        successful_account = account\n                        await self.bot_core.increment_rate_limit(account['id'])\n                        break\n                    else:\n                        validation_errors.append(f\"Account {account.get('phone_number', account['id'])}: {result['error']}\")\n                        \n                except Exception as e:\n                    error_msg = f\"Account {account.get('phone_number', account['id'])}: {str(e)}\"\n                    validation_errors.append(error_msg)\n                    logger.warning(f\"Failed to check channel with account {account['id']}: {e}\")\n                    continue\n            \n            if not channel_data:\n                # Provide detailed error information\n                error_details = \"\\n\".join(validation_errors) if validation_errors else \"No accounts could access the channel\"\n                \n                # Check if channel exists at all\n                channel_status = await self._check_channel_existence(channel_info)\n                \n                return {\n                    'success': False,\n                    'error': f\"Could not access channel '{channel_input}'.\\n\\nüîç **Validation Details:**\\n{error_details}\\n\\n{channel_status['message']}\"\n                }\n            \n            # Validate user permissions\n            permissions_check = await self._check_user_permissions(\n                successful_account, channel_data, user_id\n            )\n            if not permissions_check['valid']:\n                return {\n                    'success': False,\n                    'error': permissions_check['error']\n                }\n            \n            # Add channel to database\n            db_result = await self._add_channel_to_database(user_id, channel_data)\n            if not db_result['success']:\n                return db_result\n            \n            return {\n                'success': True,\n                'channel_info': channel_data,\n                'permissions': permissions_check,\n                'account_used': successful_account['phone_number']\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error validating channel: {e}\")\n            return {\n                'success': False,\n                'error': f'Validation failed: {str(e)}'\n            }\n    \n    def _parse_channel_input(self, channel_input: str) -> Dict[str, Any]:\n        \"\"\"Parse different types of channel input\"\"\"\n        try:\n            channel_input = channel_input.strip()\n            \n            # Channel ID (starts with -100)\n            if channel_input.startswith('-100'):\n                try:\n                    channel_id = int(channel_input)\n                    return {\n                        'valid': True,\n                        'type': 'id',\n                        'value': channel_id,\n                        'input': channel_input\n                    }\n                except ValueError:\n                    return {\n                        'valid': False,\n                        'error': 'Invalid channel ID format'\n                    }\n            \n            # Username (starts with @)\n            if channel_input.startswith('@'):\n                username = channel_input[1:]\n                if self._is_valid_username(username):\n                    return {\n                        'valid': True,\n                        'type': 'username',\n                        'value': username,\n                        'input': channel_input\n                    }\n                else:\n                    return {\n                        'valid': False,\n                        'error': 'Invalid username format'\n                    }\n            \n            # Telegram URLs - Enhanced parsing for all link types\n            if any(domain in channel_input.lower() for domain in ['telegram.me', 't.me', 'telegram.org']):\n                return self._parse_telegram_url(channel_input)\n            \n            # Plain username (without @)\n            if self._is_valid_username(channel_input):\n                return {\n                    'valid': True,\n                    'type': 'username',\n                    'value': channel_input,\n                    'input': channel_input\n                }\n            \n            return {\n                'valid': False,\n                'error': 'Invalid channel format. Supported formats:\\n‚Ä¢ @username\\n‚Ä¢ https://t.me/username\\n‚Ä¢ https://t.me/joinchat/xxxxx\\n‚Ä¢ https://t.me/+xxxxx\\n‚Ä¢ Channel ID (-100xxxxxxxxx)'\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error parsing channel input: {e}\")\n            return {\n                'valid': False,\n                'error': 'Failed to parse channel information'\n            }\n    \n    def _parse_telegram_url(self, url: str) -> Dict[str, Any]:\n        \"\"\"Parse various Telegram URL formats\"\"\"\n        try:\n            # Clean and normalize URL\n            url = url.strip()\n            if not url.startswith(('http://', 'https://')):\n                url = 'https://' + url\n            \n            parsed_url = urlparse(url)\n            path = parsed_url.path.strip('/')\n            \n            # Handle different URL patterns\n            if 'joinchat' in path:\n                # Private group/channel invite link: t.me/joinchat/xxxxx\n                invite_hash = path.split('joinchat/')[-1]\n                if invite_hash and len(invite_hash) > 10:  # Reasonable hash length\n                    return {\n                        'valid': True,\n                        'type': 'invite_link',\n                        'value': invite_hash,\n                        'input': url,\n                        'full_path': path\n                    }\n                else:\n                    return {\n                        'valid': False,\n                        'error': 'Invalid invite link format'\n                    }\n            \n            elif path.startswith('+'):\n                # New style private invite: t.me/+xxxxx\n                invite_hash = path[1:]  # Remove the + sign\n                if invite_hash and len(invite_hash) > 10:\n                    return {\n                        'valid': True,\n                        'type': 'invite_link',\n                        'value': invite_hash,\n                        'input': url,\n                        'full_path': path\n                    }\n                else:\n                    return {\n                        'valid': False,\n                        'error': 'Invalid private invite link format'\n                    }\n            \n            elif '/c/' in path:\n                # Channel with ID: t.me/c/channel_id/message_id\n                parts = path.split('/c/')\n                if len(parts) > 1:\n                    channel_part = parts[1].split('/')[0]\n                    try:\n                        channel_id = int(channel_part)\n                        # Convert to full channel ID format\n                        full_channel_id = -1000000000000 - channel_id\n                        return {\n                            'valid': True,\n                            'type': 'id',\n                            'value': full_channel_id,\n                            'input': url\n                        }\n                    except ValueError:\n                        return {\n                            'valid': False,\n                            'error': 'Invalid channel ID in URL'\n                        }\n            \n            elif path and not any(x in path for x in ['/', '?', '#']):\n                # Simple username: t.me/username\n                username = path\n                if self._is_valid_username(username):\n                    return {\n                        'valid': True,\n                        'type': 'username',\n                        'value': username,\n                        'input': url\n                    }\n                else:\n                    return {\n                        'valid': False,\n                        'error': 'Invalid username in URL'\n                    }\n            \n            elif '/' in path:\n                # Username with possible message ID: t.me/username/123\n                username = path.split('/')[0]\n                if username and self._is_valid_username(username):\n                    return {\n                        'valid': True,\n                        'type': 'username',\n                        'value': username,\n                        'input': url\n                    }\n                else:\n                    return {\n                        'valid': False,\n                        'error': 'Invalid username in URL'\n                    }\n            \n            return {\n                'valid': False,\n                'error': 'Could not parse Telegram URL format'\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error parsing Telegram URL: {e}\")\n            return {\n                'valid': False,\n                'error': 'Failed to parse URL'\n            }\n\n    def _is_valid_username(self, username: str) -> bool:\n        \"\"\"Check if username format is valid\"\"\"\n        # Username rules: 4-32 characters, alphanumeric + underscores, can't start with number\n        # Made more lenient to handle more valid usernames\n        if not username or len(username) < 4 or len(username) > 32:\n            return False\n        \n        if username[0].isdigit():\n            return False\n        \n        # Allow letters, numbers, and underscores\n        return re.match(r'^[a-zA-Z][a-zA-Z0-9_]*$', username) is not None\n    \n    async def _get_channel_entity_with_details(self, client: TelegramClient, channel_info: Dict[str, Any], account: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Get channel entity with detailed error reporting\"\"\"\n        try:\n            entity = None\n            \n            if channel_info['type'] == 'id':\n                entity = await client.get_entity(channel_info['value'])\n            elif channel_info['type'] == 'username':\n                # Try both with and without @ symbol\n                username = channel_info['value']\n                try:\n                    entity = await client.get_entity(username)\n                except Exception:\n                    # Try with @ prefix if not already there\n                    if not username.startswith('@'):\n                        entity = await client.get_entity('@' + username)\n                    else:\n                        raise\n            elif channel_info['type'] == 'invite_link':\n                entity = await self._resolve_invite_link(client, channel_info['value'])\n            \n            if not entity:\n                return {\n                    'success': False,\n                    'error': 'Channel not found or invalid'\n                }\n            \n            # Check if it's a channel or group\n            if not isinstance(entity, (types.Channel, types.Chat)):\n                return {\n                    'success': False,\n                    'error': f'This is a {type(entity).__name__}, not a channel or group'\n                }\n            \n            # Get additional channel information\n            try:\n                if isinstance(entity, types.Channel):\n                    full_channel = await client(functions.channels.GetFullChannelRequest(entity))\n                    full_chat = full_channel.full_chat\n                else:\n                    # For regular chats\n                    full_chat_request = functions.messages.GetFullChatRequest(entity.id)\n                    full_chat_result = await client(full_chat_request)\n                    full_chat = full_chat_result.full_chat\n            except Exception as e:\n                logger.warning(f\"Could not get full channel info: {e}\")\n                full_chat = None\n            \n            channel_data = {\n                'channel_id': entity.id,\n                'access_hash': getattr(entity, 'access_hash', None),\n                'title': entity.title,\n                'username': getattr(entity, 'username', None),\n                'description': getattr(full_chat, 'about', '') if full_chat else '',\n                'member_count': getattr(full_chat, 'participants_count', 0) if full_chat else 0,\n                'is_megagroup': getattr(entity, 'megagroup', False),\n                'is_broadcast': getattr(entity, 'broadcast', False),\n                'is_public': bool(getattr(entity, 'username', None)),\n                'created_date': getattr(entity, 'date', None),\n                'is_private': channel_info['type'] == 'invite_link'\n            }\n            \n            return {\n                'success': True,\n                'data': channel_data\n            }\n            \n        except ChannelPrivateError:\n            return {\n                'success': False,\n                'error': 'Channel is private and you are not a member'\n            }\n        except FloodWaitError as e:\n            return {\n                'success': False,\n                'error': f'Rate limited, wait {e.seconds} seconds'\n            }\n        except ValueError as e:\n            if 'username' in str(e).lower():\n                return {\n                    'success': False,\n                    'error': 'Username not found or invalid'\n                }\n            return {\n                'success': False,\n                'error': f'Invalid format: {str(e)}'\n            }\n        except Exception as e:\n            error_type = type(e).__name__\n            return {\n                'success': False,\n                'error': f'{error_type}: {str(e)}'\n            }\n    \n    async def _get_channel_entity(self, client: TelegramClient, channel_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        \"\"\"Get channel entity from Telegram\"\"\"\n        try:\n            entity = None\n            \n            if channel_info['type'] == 'id':\n                entity = await client.get_entity(channel_info['value'])\n            elif channel_info['type'] == 'username':\n                entity = await client.get_entity(channel_info['value'])\n            elif channel_info['type'] == 'invite_link':\n                # Handle invite links\n                entity = await self._resolve_invite_link(client, channel_info['value'])\n            \n            if not entity:\n                return None\n            \n            # Check if it's a channel or group\n            if not isinstance(entity, (types.Channel, types.Chat)):\n                return None\n            \n            # Get additional channel information\n            try:\n                if isinstance(entity, types.Channel):\n                    full_channel = await client(functions.channels.GetFullChannelRequest(entity))\n                    full_chat = full_channel.full_chat\n                else:\n                    # For regular chats\n                    full_chat_request = functions.messages.GetFullChatRequest(entity.id)\n                    full_chat_result = await client(full_chat_request)\n                    full_chat = full_chat_result.full_chat\n            except Exception as e:\n                logger.warning(f\"Could not get full channel info: {e}\")\n                # Fallback to basic info\n                full_chat = None\n            \n            return {\n                'channel_id': entity.id,\n                'access_hash': getattr(entity, 'access_hash', None),\n                'title': entity.title,\n                'username': getattr(entity, 'username', None),\n                'description': getattr(full_chat, 'about', '') if full_chat else '',\n                'member_count': getattr(full_chat, 'participants_count', 0) if full_chat else 0,\n                'is_megagroup': getattr(entity, 'megagroup', False),\n                'is_broadcast': getattr(entity, 'broadcast', False),\n                'is_public': bool(getattr(entity, 'username', None)),\n                'created_date': getattr(entity, 'date', None),\n                'is_private': channel_info['type'] == 'invite_link'\n            }\n            \n        except ChannelPrivateError:\n            logger.warning(\"Channel is private or doesn't exist\")\n            return None\n        except FloodWaitError as e:\n            logger.warning(f\"Rate limited, need to wait {e.seconds} seconds\")\n            return None\n        except Exception as e:\n            logger.error(f\"Error getting channel entity: {e}\")\n            return None\n    \n    async def _check_channel_existence(self, channel_info: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Check if channel exists using public methods\"\"\"\n        try:\n            if channel_info['type'] == 'username':\n                username = channel_info['value']\n                return {\n                    'exists': 'unknown',\n                    'message': f\"üí° **Troubleshooting Tips:**\\n‚Ä¢ Make sure '@{username}' is spelled correctly\\n‚Ä¢ Check if the channel is public (has a username)\\n‚Ä¢ Verify your accounts are active and connected\\n‚Ä¢ Try adding the channel using its invite link instead\"\n                }\n            elif channel_info['type'] == 'invite_link':\n                return {\n                    'exists': 'unknown', \n                    'message': f\"üí° **For Private Channels:**\\n‚Ä¢ Make sure the invite link is valid and not expired\\n‚Ä¢ Your account needs to join the channel first\\n‚Ä¢ Some private channels restrict access\"\n                }\n            else:\n                return {\n                    'exists': 'unknown',\n                    'message': f\"üí° **Channel ID Issues:**\\n‚Ä¢ Verify the channel ID format is correct\\n‚Ä¢ Channel might be deleted or restricted\\n‚Ä¢ Your accounts may not have access\"\n                }\n        except Exception as e:\n            return {\n                'exists': 'unknown',\n                'message': f\"üí° **General Tips:**\\n‚Ä¢ Try refreshing your account connections\\n‚Ä¢ Make sure the channel exists and is accessible\\n‚Ä¢ Contact channel admin if it's a private channel\"\n            }\n\n    async def _resolve_invite_link(self, client: TelegramClient, invite_hash: str) -> Optional[types.Channel]:\n        \"\"\"Resolve invite link to get channel entity\"\"\"\n        try:\n            # First, try to check the invite without joining\n            invite_info = await client(functions.messages.CheckChatInviteRequest(invite_hash))\n            \n            if hasattr(invite_info, 'chat'):\n                # We can see the chat info without joining\n                return invite_info.chat\n            elif hasattr(invite_info, 'channel'):\n                # We can see the channel info without joining\n                return invite_info.channel\n            else:\n                # We need to join to access the channel\n                logger.info(\"Attempting to join channel via invite link...\")\n                result = await client(functions.messages.ImportChatInviteRequest(invite_hash))\n                \n                if hasattr(result, 'chats') and result.chats:\n                    return result.chats[0]\n                elif hasattr(result, 'chat'):\n                    return result.chat\n                \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error resolving invite link: {e}\")\n            return None\n    \n    async def _check_user_permissions(self, account: Dict[str, Any], \n                                    channel_data: Dict[str, Any], user_id: int) -> Dict[str, Any]:\n        \"\"\"Check if user has necessary permissions in the channel\"\"\"\n        try:\n            client = await self.bot_core.get_client(account['id'])\n            if not client:\n                return {\n                    'valid': False,\n                    'error': 'Could not connect to Telegram account'\n                }\n            \n            # Get user's participation status in the channel\n            try:\n                channel_entity = await client.get_entity(channel_data['channel_id'])\n                participant = await client(functions.channels.GetParticipantRequest(\n                    channel=channel_entity,\n                    participant=await client.get_me()\n                ))\n                \n                # Check if user is admin or has necessary permissions\n                if hasattr(participant.participant, 'admin_rights'):\n                    admin_rights = participant.participant.admin_rights\n                    can_post = getattr(admin_rights, 'post_messages', False)\n                    can_edit = getattr(admin_rights, 'edit_messages', False)\n                    \n                    return {\n                        'valid': True,\n                        'role': 'admin',\n                        'permissions': {\n                            'can_post': can_post,\n                            'can_edit': can_edit,\n                            'can_view': True\n                        }\n                    }\n                elif hasattr(participant.participant, 'creator'):\n                    return {\n                        'valid': True,\n                        'role': 'creator',\n                        'permissions': {\n                            'can_post': True,\n                            'can_edit': True,\n                            'can_view': True\n                        }\n                    }\n                else:\n                    # Regular member - check if channel allows this\n                    return {\n                        'valid': True,\n                        'role': 'member',\n                        'permissions': {\n                            'can_post': False,\n                            'can_edit': False,\n                            'can_view': True\n                        },\n                        'warning': 'Limited permissions - some features may not work'\n                    }\n                    \n            except Exception as e:\n                # If we can't check permissions but can access the channel,\n                # assume basic access is available\n                logger.warning(f\"Could not check detailed permissions: {e}\")\n                return {\n                    'valid': True,\n                    'role': 'unknown',\n                    'permissions': {\n                        'can_post': False,\n                        'can_edit': False,\n                        'can_view': True\n                    },\n                    'warning': 'Could not verify permissions'\n                }\n                \n        except Exception as e:\n            logger.error(f\"Error checking permissions: {e}\")\n            return {\n                'valid': False,\n                'error': 'Failed to verify channel permissions'\n            }\n    \n    async def _add_channel_to_database(self, user_id: int, channel_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Add channel to database\"\"\"\n        try:\n            # Check if channel already exists\n            existing_channel = await self.db.get_channel_by_channel_id(channel_data['channel_id'])\n            if existing_channel:\n                if existing_channel['user_id'] == user_id:\n                    return {\n                        'success': False,\n                        'error': 'Channel is already in your list'\n                    }\n                else:\n                    return {\n                        'success': False,\n                        'error': 'Channel is already managed by another user'\n                    }\n            \n            # Add new channel\n            db_channel_id = await self.db.add_channel(\n                user_id=user_id,\n                channel_id=channel_data['channel_id'],\n                username=channel_data.get('username'),\n                title=channel_data['title'],\n                description=channel_data.get('description')\n            )\n            \n            if not db_channel_id:\n                return {\n                    'success': False,\n                    'error': 'Failed to add channel to database'\n                }\n            \n            # Update member count\n            await self.db.update_channel_info(\n                db_channel_id,\n                member_count=channel_data.get('member_count', 0)\n            )\n            \n            # Store initial analytics data\n            await self.db.store_analytics_data(\n                'channel', db_channel_id, 'member_count', \n                channel_data.get('member_count', 0),\n                {'event': 'channel_added'}\n            )\n            \n            return {\n                'success': True,\n                'db_channel_id': db_channel_id\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error adding channel to database: {e}\")\n            return {\n                'success': False,\n                'error': 'Database error while adding channel'\n            }\n    \n    async def refresh_channel_info(self, channel_db_id: int) -> Dict[str, Any]:\n        \"\"\"Refresh channel information from Telegram\"\"\"\n        try:\n            # Get channel from database\n            channel = await self.db.get_channel_by_id(channel_db_id)\n            if not channel:\n                return {\n                    'success': False,\n                    'error': 'Channel not found'\n                }\n            \n            # Get user's accounts\n            user_accounts = await self.db.get_user_accounts(channel['user_id'], active_only=True)\n            if not user_accounts:\n                return {\n                    'success': False,\n                    'error': 'No active accounts available'\n                }\n            \n            # Try to refresh with available accounts\n            for account in user_accounts:\n                try:\n                    client = await self.bot_core.get_client(account['id'])\n                    if not client:\n                        continue\n                    \n                    # Get updated channel info\n                    entity = await client.get_entity(channel['channel_id'])\n                    full_channel = await client(functions.channels.GetFullChannelRequest(entity))\n                    \n                    # Update database\n                    updated = await self.db.update_channel_info(\n                        channel_db_id,\n                        title=entity.title,\n                        description=getattr(full_channel.full_chat, 'about', ''),\n                        member_count=getattr(full_channel.full_chat, 'participants_count', 0)\n                    )\n                    \n                    if updated:\n                        # Store analytics update\n                        await self.db.store_analytics_data(\n                            'channel', channel_db_id, 'member_count',\n                            getattr(full_channel.full_chat, 'participants_count', 0),\n                            {'event': 'info_refresh'}\n                        )\n                    \n                    return {\n                        'success': True,\n                        'updated_info': {\n                            'title': entity.title,\n                            'member_count': getattr(full_channel.full_chat, 'participants_count', 0),\n                            'description': getattr(full_channel.full_chat, 'about', '')\n                        }\n                    }\n                    \n                except Exception as e:\n                    logger.warning(f\"Failed to refresh with account {account['id']}: {e}\")\n                    continue\n            \n            return {\n                'success': False,\n                'error': 'Could not refresh channel information'\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error refreshing channel info: {e}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    async def validate_channel_access(self, channel_db_id: int, account_id: int) -> bool:\n        \"\"\"Validate that an account can access a channel\"\"\"\n        try:\n            channel = await self.db.get_channel_by_id(channel_db_id)\n            if not channel:\n                return False\n            \n            client = await self.bot_core.get_client(account_id)\n            if not client:\n                return False\n            \n            # Try to get channel entity\n            entity = await client.get_entity(channel['channel_id'])\n            return entity is not None\n            \n        except Exception as e:\n            logger.warning(f\"Channel access validation failed: {e}\")\n            return False\n","size_bytes":31411},"features/emoji_reactions/__init__.py":{"content":"\"\"\"\nEmoji Reactions Feature\nHandles emoji reactions management for posts\n\"\"\"\n\nfrom .handler import EmojiReactionsHandler\n\n__all__ = ['EmojiReactionsHandler']\n","size_bytes":158},"features/emoji_reactions/handler.py":{"content":"\"\"\"\nEmoji Reactions Handler\nManages emoji reactions on channel posts\n\"\"\"\n\nimport asyncio\nimport logging\nimport random\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime, timedelta\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import CallbackQuery, Message\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\nfrom core.database.universal_access import UniversalDatabaseAccess\nfrom core.bot.telegram_bot import TelegramBotCore\nfrom telethon.tl import functions, types\n\nlogger = logging.getLogger(__name__)\n\n\nclass EmojiReactionsHandler:\n    \"\"\"Handler for emoji reactions management\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config, bot_core=None):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.universal_db = UniversalDatabaseAccess(db_manager)\n        self.bot_core = bot_core if bot_core else TelegramBotCore(config, db_manager)\n        self._reaction_workers = []\n        self._running = False\n        \n        # Common emoji sets\n        self.emoji_sets = {\n            'positive': ['üëç', '‚ù§Ô∏è', 'üî•', 'üíØ', '‚ú®', 'üéâ', 'üòç', 'üëè', 'üí™'],\n            'engagement': ['üëÄ', 'üí≠', 'ü§î', 'üòÆ', 'üòä', 'üëå', 'üôå', 'üíù'],\n            'support': ['‚ù§Ô∏è', 'üí™', 'üôè', '‚úä', 'üíØ', 'üëç', 'üî•', '‚ö°'],\n            'mixed': ['üëç', '‚ù§Ô∏è', 'üòä', 'üî•', 'üíØ', 'üëè', 'üòÆ', 'ü§î', '‚ú®']\n        }\n    \n    async def initialize(self):\n        \"\"\"Initialize emoji reactions handler\"\"\"\n        try:\n            # Only initialize bot_core if it wasn't passed in (backward compatibility)\n            if hasattr(self, 'bot_core') and self.bot_core and not hasattr(self.bot_core, '_initialized'):\n                await self.bot_core.initialize()\n            # Wait for database schema to be ready before starting workers  \n            await asyncio.sleep(20)\n            await self._start_reaction_workers()\n            self._running = True\n            logger.info(\"‚úÖ Emoji reactions handler initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize emoji reactions handler: {e}\")\n            raise\n    \n    async def shutdown(self):\n        \"\"\"Shutdown emoji reactions handler\"\"\"\n        try:\n            self._running = False\n            \n            # Stop all reaction workers\n            for worker in self._reaction_workers:\n                if not worker.done():\n                    worker.cancel()\n            \n            # Wait for workers to finish\n            if self._reaction_workers:\n                await asyncio.gather(*self._reaction_workers, return_exceptions=True)\n            \n            # Shutdown bot_core if we own it\n            if hasattr(self, 'bot_core') and self.bot_core and not hasattr(self.bot_core, '_shared'):\n                await self.bot_core.shutdown()\n            \n            logger.info(\"‚úÖ Emoji reactions handler shut down\")\n        except Exception as e:\n            logger.error(f\"Error during emoji reactions shutdown: {e}\")\n    \n    def register_handlers(self, dp: Dispatcher):\n        \"\"\"Register handlers with dispatcher\"\"\"\n        # Callback registration handled by central inline_handler\n        # dp.callback_query.register(\n        #     self.handle_callback,\n        #     lambda c: c.data.startswith('er_')\n        # )\n        \n        logger.info(\"‚úÖ Emoji reactions handlers registered\")\n    \n    async def handle_callback(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle emoji reactions callbacks\"\"\"\n        try:\n            callback_data = callback.data\n            user_id = callback.from_user.id\n            \n            # Ensure user exists\n            await self.universal_db.ensure_user_exists(\n                user_id,\n                callback.from_user.username,\n                callback.from_user.first_name,\n                callback.from_user.last_name\n            )\n            \n            # Emoji Reactions callbacks\n            if callback_data == \"er_configure\":\n                await self._handle_configure_emojis(callback, state)\n            elif callback_data == \"er_schedule\":\n                await self._handle_reaction_schedule(callback, state)\n            elif callback_data == \"er_stats\":\n                await self._handle_reaction_stats(callback, state)\n            elif callback_data == \"er_react_messages\":\n                await self._handle_react_messages(callback, state)\n            elif callback_data == \"er_settings\":\n                await self._handle_reaction_settings(callback, state)\n            elif callback_data.startswith(\"er_channel_\"):\n                await self._handle_channel_reactions(callback, state)\n            elif callback_data.startswith(\"er_set_\"):\n                await self._handle_emoji_set_selection(callback, state)\n            elif callback_data.startswith(\"er_enable_\"):\n                await self._handle_enable_reactions(callback, state)\n            # Poll Manager callbacks moved to dedicated handler\n            else:\n                await callback.answer(\"‚ùå Unknown reaction action\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error in emoji reactions callback: {e}\")\n            await callback.answer(\"‚ùå An error occurred\", show_alert=True)\n    \n    async def _handle_configure_emojis(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle emoji configuration\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user channels\n            channels = await self.db.get_user_channels(user_id)\n            if not channels:\n                await callback.message.edit_text(\n                    \"üì≠ <b>No Channels Available</b>\\n\\n\"\n                    \"Please add channels first before configuring emoji reactions.\",\n                    reply_markup=self._get_no_channels_keyboard()\n                )\n                return\n            \n            # Get current reaction settings\n            reaction_summary = await self._get_reaction_summary(user_id)\n            \n            text = f\"\"\"\nüòä <b>Configure Emoji Reactions</b>\n\nAutomatically add emoji reactions to posts in your channels.\n\n<b>üìä Current Status:</b>\n‚Ä¢ Active Channels: {reaction_summary['active_channels']}\n‚Ä¢ Total Reactions Today: {reaction_summary['reactions_today']:,}\n‚Ä¢ Success Rate: {reaction_summary['success_rate']:.1f}%\n\n<b>üé≠ Available Emoji Sets:</b>\n‚Ä¢ Positive - Encouraging reactions\n‚Ä¢ Engagement - Discussion starters  \n‚Ä¢ Support - Supportive reactions\n‚Ä¢ Mixed - Variety of reactions\n\n<b>‚öôÔ∏è Features:</b>\n‚Ä¢ Custom emoji selection\n‚Ä¢ Smart timing patterns\n‚Ä¢ Account rotation\n‚Ä¢ Natural reaction patterns\n\nSelect how to configure reactions:\n            \"\"\"\n            \n            keyboard = self._get_configure_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üòä Emoji configuration loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error configuring emojis: {e}\")\n            await callback.answer(\"‚ùå Failed to load configuration\", show_alert=True)\n    \n    async def _handle_reaction_schedule(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle reaction scheduling\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get scheduled reactions\n            scheduled_reactions = await self.db.fetch_all(\n                \"\"\"\n                SELECT er.*, c.title as channel_title\n                FROM emoji_reactions er\n                JOIN telegram_channels c ON er.channel_id = c.id\n                WHERE er.user_id = $1 AND er.auto_react_enabled = TRUE\n                ORDER BY er.created_at DESC\n                \"\"\",\n                user_id\n            )\n            \n            text = f\"\"\"\n‚è∞ <b>Reaction Scheduling</b>\n\nConfigure when and how reactions are automatically added.\n\n<b>üìä Active Schedules:</b> {len(scheduled_reactions)}\n\n<b>‚è±Ô∏è Timing Options:</b>\n‚Ä¢ Immediate - React within 1-3 minutes\n‚Ä¢ Natural - React within 5-15 minutes  \n‚Ä¢ Delayed - React within 30-60 minutes\n‚Ä¢ Peak Hours - React during peak engagement\n\n<b>üìà Smart Features:</b>\n‚Ä¢ Avoid reaction flooding\n‚Ä¢ Respect rate limits\n‚Ä¢ Natural reaction patterns\n‚Ä¢ Account rotation\n\nCurrent scheduled reactions:\n            \"\"\"\n            \n            if scheduled_reactions:\n                for reaction in scheduled_reactions[:5]:\n                    text += f\"\\n‚Ä¢ {reaction['channel_title']}: {reaction['emoji']} (Active)\"\n            else:\n                text += \"\\nNo active reaction schedules.\"\n            \n            keyboard = self._get_schedule_keyboard(len(scheduled_reactions) > 0)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚è∞ Reaction schedule loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in reaction schedule: {e}\")\n            await callback.answer(\"‚ùå Failed to load schedule\", show_alert=True)\n    \n    async def _handle_reaction_stats(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle reaction statistics\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get comprehensive reaction statistics\n            stats = await self._get_reaction_statistics(user_id)\n            \n            text = f\"\"\"\nüìä <b>Emoji Reactions Statistics</b>\n\n<b>üìà Overall Performance:</b>\n‚Ä¢ Total Reactions: {stats['total_reactions']:,}\n‚Ä¢ Reactions Today: {stats['reactions_today']:,}\n‚Ä¢ Success Rate: {stats['success_rate']:.1f}%\n‚Ä¢ Active Channels: {stats['active_channels']}\n\n<b>üé≠ Popular Emojis:</b>\n\"\"\"\n            \n            for emoji, count in stats['top_emojis'][:5]:\n                text += f\"‚Ä¢ {emoji}: {count:,} reactions\\n\"\n            \n            text += f\"\"\"\n<b>üìä Channel Performance:</b>\n\"\"\"\n            \n            for channel in stats['channel_stats'][:3]:\n                text += f\"‚Ä¢ {channel['title']}: {channel['reactions']:,} reactions\\n\"\n            \n            text += f\"\"\"\n<b>üìÖ Recent Activity:</b>\n‚Ä¢ Last 7 days: {stats['weekly_reactions']:,}\n‚Ä¢ Last 30 days: {stats['monthly_reactions']:,}\n‚Ä¢ Average per day: {stats['avg_daily']:,.0f}\n\n<b>üïê Peak Hours:</b>\nMost active: {stats['peak_hour']}:00 - {stats['peak_hour'] + 1}:00\n            \"\"\"\n            \n            keyboard = self._get_stats_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üìä Reaction statistics loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in reaction stats: {e}\")\n            await callback.answer(\"‚ùå Failed to load statistics\", show_alert=True)\n    \n    async def _handle_channel_reactions(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle channel-specific reactions\"\"\"\n        try:\n            # Extract channel ID\n            channel_id = int(callback.data.split(\"_\")[-1])\n            \n            # Get channel and current reactions\n            channel = await self.db.get_channel_by_id(channel_id)\n            if not channel:\n                await callback.answer(\"‚ùå Channel not found\", show_alert=True)\n                return\n            \n            reactions = await self.db.fetch_all(\n                \"SELECT * FROM emoji_reactions WHERE channel_id = $1 ORDER BY created_at DESC\",\n                channel_id\n            )\n            \n            text = f\"\"\"\nüé≠ <b>{channel['title']} - Reactions</b>\n\n<b>üìä Channel Reaction Status:</b>\n‚Ä¢ Active Reactions: {len([r for r in reactions if r['auto_react_enabled']])}\n‚Ä¢ Total Reactions Set: {len(reactions)}\n‚Ä¢ Channel Members: {channel.get('member_count', 'Unknown'):,}\n\n<b>üéØ Current Reaction Setup:</b>\n\"\"\"\n            \n            if reactions:\n                for reaction in reactions[:5]:\n                    status = \"üü¢ Active\" if reaction['auto_react_enabled'] else \"üî¥ Inactive\"\n                    text += f\"‚Ä¢ {reaction['emoji']} - {status}\\n\"\n            else:\n                text += \"No reactions configured for this channel.\\n\"\n            \n            text += \"\\nWhat would you like to do?\"\n            \n            keyboard = self._get_channel_reactions_keyboard(channel_id, len(reactions) > 0)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(f\"üé≠ {channel['title']} reactions\")\n            \n        except Exception as e:\n            logger.error(f\"Error in channel reactions: {e}\")\n            await callback.answer(\"‚ùå Failed to load channel reactions\", show_alert=True)\n    \n    async def _handle_emoji_set_selection(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle emoji set selection\"\"\"\n        try:\n            # Extract set name\n            set_name = callback.data.split(\"_\")[-1]\n            \n            if set_name not in self.emoji_sets:\n                await callback.answer(\"‚ùå Invalid emoji set\", show_alert=True)\n                return\n            \n            emoji_list = self.emoji_sets[set_name]\n            \n            text = f\"\"\"\nüé≠ <b>{set_name.title()} Emoji Set</b>\n\n<b>üìù Emojis in this set:</b>\n{' '.join(emoji_list)}\n\n<b>üìä Set Details:</b>\n‚Ä¢ Total Emojis: {len(emoji_list)}\n‚Ä¢ Type: {set_name.title()}\n‚Ä¢ Usage: {\"High engagement\" if set_name == \"positive\" else \"Balanced reactions\"}\n\n<b>‚öôÔ∏è Application Options:</b>\n‚Ä¢ Apply to all channels\n‚Ä¢ Apply to selected channels\n‚Ä¢ Use as default for new posts\n‚Ä¢ Combine with other sets\n\nSelect how to use this emoji set:\n            \"\"\"\n            \n            keyboard = self._get_emoji_set_keyboard(set_name)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(f\"üé≠ {set_name.title()} emoji set\")\n            \n        except Exception as e:\n            logger.error(f\"Error in emoji set selection: {e}\")\n            await callback.answer(\"‚ùå Failed to load emoji set\", show_alert=True)\n    \n    async def _handle_enable_reactions(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle enabling reactions for a channel\"\"\"\n        try:\n            # Extract channel ID\n            channel_id = int(callback.data.split(\"_\")[-1])\n            user_id = callback.from_user.id\n            \n            # Get channel\n            channel = await self.db.get_channel_by_id(channel_id)\n            if not channel or channel['user_id'] != user_id:\n                await callback.answer(\"‚ùå Channel not found or access denied\", show_alert=True)\n                return\n            \n            # Enable default reactions for the channel\n            default_emojis = self.emoji_sets['mixed'][:5]  # Use first 5 from mixed set\n            \n            enabled_count = 0\n            for emoji in default_emojis:\n                # Check if reaction already exists\n                existing = await self.db.fetch_one(\n                    \"SELECT id FROM emoji_reactions WHERE channel_id = $1 AND emoji = $2\",\n                    channel_id, emoji\n                )\n                \n                if not existing:\n                    # Add new reaction\n                    await self.db.execute_query(\n                        \"\"\"\n                        INSERT INTO emoji_reactions \n                        (user_id, channel_id, message_id, emoji, auto_react_enabled, created_at, updated_at)\n                        VALUES ($1, $2, 0, $3, TRUE, NOW(), NOW())\n                        \"\"\",\n                        user_id, channel_id, emoji\n                    )\n                    enabled_count += 1\n                else:\n                    # Enable existing reaction\n                    await self.db.execute_query(\n                        \"UPDATE emoji_reactions SET auto_react_enabled = TRUE, updated_at = NOW() WHERE id = $1\",\n                        existing['id']\n                    )\n                    enabled_count += 1\n            \n            await callback.message.edit_text(\n                f\"‚úÖ <b>Reactions Enabled!</b>\\n\\n\"\n                f\"Channel: <b>{channel['title']}</b>\\n\"\n                f\"Enabled Reactions: {' '.join(default_emojis)}\\n\"\n                f\"Count: {enabled_count} reactions\\n\\n\"\n                f\"ü§ñ Auto reactions are now active for new posts in this channel!\",\n                reply_markup=self._get_reactions_enabled_keyboard(channel_id)\n            )\n            \n            await callback.answer(\"‚úÖ Reactions enabled successfully!\")\n            \n        except Exception as e:\n            logger.error(f\"Error enabling reactions: {e}\")\n            await callback.answer(\"‚ùå Failed to enable reactions\", show_alert=True)\n    \n    async def _start_reaction_workers(self):\n        \"\"\"Start background workers for automatic reactions\"\"\"\n        try:\n            # Start reaction monitoring workers\n            worker_count = min(2, self.config.MAX_ACTIVE_CLIENTS // 30)\n            \n            for i in range(worker_count):\n                worker = asyncio.create_task(self._reaction_worker(f\"reaction-{i}\"))\n                self._reaction_workers.append(worker)\n            \n            logger.info(f\"‚úÖ Started {worker_count} reaction workers\")\n            \n        except Exception as e:\n            logger.error(f\"Error starting reaction workers: {e}\")\n            raise\n    \n    async def _reaction_worker(self, worker_name: str):\n        \"\"\"Background worker for processing reactions\"\"\"\n        logger.info(f\"üîß Started reaction worker: {worker_name}\")\n        \n        while self._running:\n            try:\n                # Get channels with active reactions\n                active_channels = await self.db.fetch_all(\n                    \"\"\"\n                    SELECT DISTINCT c.id, er.channel_id, er.user_id, c.title\n                    FROM telegram_channels c\n                    JOIN emoji_reactions er ON c.id = er.channel_id\n                    WHERE er.auto_react_enabled = TRUE\n                    \"\"\"\n                )\n                \n                # Process each channel\n                for channel in active_channels:\n                    try:\n                        await self._process_channel_reactions(channel)\n                    except Exception as e:\n                        logger.error(f\"Error processing reactions for channel {channel['id']}: {e}\")\n                \n                # Wait before next check\n                await asyncio.sleep(300)  # Check every 5 minutes\n                \n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Error in reaction worker {worker_name}: {e}\")\n                await asyncio.sleep(60)\n    \n    async def _process_channel_reactions(self, channel: Dict[str, Any]):\n        \"\"\"Process reactions for a specific channel\"\"\"\n        try:\n            user_id = channel['user_id']\n            channel_id = channel['id']\n            \n            # Get user accounts\n            accounts = await self.db.get_user_accounts(user_id, active_only=True)\n            if not accounts:\n                return\n            \n            # Check for new posts that need reactions\n            new_posts = await self._get_posts_needing_reactions(channel, accounts[0])\n            \n            if new_posts:\n                # Get channel's active reactions\n                active_reactions = await self.db.fetch_all(\n                    \"SELECT * FROM emoji_reactions WHERE channel_id = $1 AND auto_react_enabled = TRUE\",\n                    channel_id\n                )\n                \n                for post in new_posts:\n                    for reaction in active_reactions:\n                        # Add reaction with delay\n                        await self._add_reaction_to_post(channel, post, reaction, accounts)\n                        \n                        # Random delay between reactions\n                        delay = random.uniform(\n                            self.config.REACTION_DELAY_MIN,\n                            self.config.REACTION_DELAY_MAX\n                        )\n                        await asyncio.sleep(delay)\n            \n        except Exception as e:\n            logger.error(f\"Error processing channel reactions: {e}\")\n    \n    async def _get_posts_needing_reactions(self, channel: Dict[str, Any], \n                                         account: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Get posts that need reactions\"\"\"\n        try:\n            client = await self.bot_core.get_client(account['id'])\n            if not client:\n                return []\n            \n            # Check rate limits\n            if not await self.bot_core.check_rate_limit(account['id']):\n                return []\n            \n            # Get recent messages\n            messages = await client.get_messages(channel['channel_id'], limit=5)\n            \n            # Update rate limiter\n            await self.bot_core.increment_rate_limit(account['id'])\n            \n            # Filter for posts that need reactions (within last 2 hours, no existing reactions)\n            posts_needing_reactions = []\n            cutoff_time = datetime.now() - timedelta(hours=2)\n            \n            for message in messages:\n                if message.date and message.date.replace(tzinfo=None) > cutoff_time:\n                    # Check if we already reacted to this message\n                    existing_reaction = await self.db.fetch_one(\n                        \"\"\"\n                        SELECT id FROM emoji_reactions \n                        WHERE channel_id = $1 AND message_id = $2 AND reaction_count > 0\n                        \"\"\",\n                        channel['id'], message.id\n                    )\n                    \n                    if not existing_reaction:\n                        posts_needing_reactions.append({\n                            'message_id': message.id,\n                            'date': message.date.replace(tzinfo=None),\n                            'text': message.text or ''\n                        })\n            \n            return posts_needing_reactions\n            \n        except Exception as e:\n            logger.error(f\"Error getting posts needing reactions: {e}\")\n            return []\n    \n    async def _add_reaction_to_post(self, channel: Dict[str, Any], post: Dict[str, Any],\n                                  reaction: Dict[str, Any], accounts: List[Dict[str, Any]]):\n        \"\"\"Add reaction to a specific post\"\"\"\n        try:\n            # Select random account\n            account = random.choice(accounts)\n            \n            client = await self.bot_core.get_client(account['id'])\n            if not client:\n                return\n            \n            # Check rate limits\n            if not await self.bot_core.check_rate_limit(account['id']):\n                return\n            \n            # Get channel entity\n            channel_entity = await client.get_entity(channel['channel_id'])\n            \n            # Add emoji reaction\n            await client(functions.messages.SendReactionRequest(\n                peer=channel_entity,\n                msg_id=post['message_id'],\n                reaction=[types.ReactionEmoji(emoticon=reaction['emoji'])]\n            ))\n            \n            # Update rate limiter\n            await self.bot_core.increment_rate_limit(account['id'])\n            \n            # Update reaction count in database\n            await self.db.execute_query(\n                \"\"\"\n                UPDATE emoji_reactions \n                SET reaction_count = reaction_count + 1, updated_at = NOW()\n                WHERE id = $1\n                \"\"\",\n                reaction['id']\n            )\n            \n            # Also insert specific reaction record\n            await self.db.execute_query(\n                \"\"\"\n                INSERT INTO emoji_reactions \n                (user_id, channel_id, message_id, emoji, reaction_count, created_at, updated_at)\n                VALUES ($1, $2, $3, $4, 1, NOW(), NOW())\n                ON CONFLICT (channel_id, message_id, emoji) \n                DO UPDATE SET reaction_count = emoji_reactions.reaction_count + 1, updated_at = NOW()\n                \"\"\",\n                channel['user_id'], channel['id'], post['message_id'], reaction['emoji']\n            )\n            \n            logger.info(f\"‚úÖ Added reaction {reaction['emoji']} to post {post['message_id']}\")\n            \n        except Exception as e:\n            logger.error(f\"Error adding reaction to post: {e}\")\n    \n    async def _get_reaction_summary(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get reaction summary for user\"\"\"\n        try:\n            # Get active channels with reactions\n            active_channels = await self.db.fetch_one(\n                \"\"\"\n                SELECT COUNT(DISTINCT c.id) as count\n                FROM telegram_channels c\n                JOIN emoji_reactions er ON c.id = er.channel_id\n                WHERE er.user_id = $1 AND er.auto_react_enabled = TRUE\n                \"\"\",\n                user_id\n            )\n            \n            # Get reactions today\n            reactions_today = await self.db.fetch_one(\n                \"\"\"\n                SELECT COALESCE(SUM(reaction_count), 0) as count\n                FROM emoji_reactions\n                WHERE user_id = $1 AND DATE(updated_at) = DATE(NOW())\n                \"\"\",\n                user_id\n            )\n            \n            # Calculate success rate (placeholder)\n            success_rate = 95.0  # Would be calculated based on actual success/failure logs\n            \n            return {\n                'active_channels': active_channels['count'] if active_channels else 0,\n                'reactions_today': reactions_today['count'] if reactions_today else 0,\n                'success_rate': success_rate\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting reaction summary: {e}\")\n            return {'active_channels': 0, 'reactions_today': 0, 'success_rate': 0}\n    \n    async def _get_reaction_statistics(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get comprehensive reaction statistics\"\"\"\n        try:\n            # Total reactions\n            total_reactions = await self.db.fetch_one(\n                \"SELECT COALESCE(SUM(reaction_count), 0) as total FROM emoji_reactions WHERE user_id = $1\",\n                user_id\n            )\n            \n            # Reactions today\n            reactions_today = await self.db.fetch_one(\n                \"\"\"\n                SELECT COALESCE(SUM(reaction_count), 0) as count\n                FROM emoji_reactions \n                WHERE user_id = $1 AND DATE(updated_at) = DATE(NOW())\n                \"\"\",\n                user_id\n            )\n            \n            # Weekly and monthly reactions\n            weekly_reactions = await self.db.fetch_one(\n                \"\"\"\n                SELECT COALESCE(SUM(reaction_count), 0) as count\n                FROM emoji_reactions \n                WHERE user_id = $1 AND updated_at >= NOW() - INTERVAL '7 days'\n                \"\"\",\n                user_id\n            )\n            \n            monthly_reactions = await self.db.fetch_one(\n                \"\"\"\n                SELECT COALESCE(SUM(reaction_count), 0) as count\n                FROM emoji_reactions \n                WHERE user_id = $1 AND updated_at >= NOW() - INTERVAL '30 days'\n                \"\"\",\n                user_id\n            )\n            \n            # Top emojis\n            top_emojis = await self.db.fetch_all(\n                \"\"\"\n                SELECT emoji, SUM(reaction_count) as total\n                FROM emoji_reactions \n                WHERE user_id = $1 \n                GROUP BY emoji \n                ORDER BY total DESC \n                LIMIT 5\n                \"\"\",\n                user_id\n            )\n            \n            # Channel stats\n            channel_stats = await self.db.fetch_all(\n                \"\"\"\n                SELECT c.title, SUM(er.reaction_count) as reactions\n                FROM emoji_reactions er\n                JOIN telegram_channels c ON er.channel_id = c.id\n                WHERE er.user_id = $1\n                GROUP BY c.id, c.title\n                ORDER BY reactions DESC\n                LIMIT 5\n                \"\"\",\n                user_id\n            )\n            \n            # Active channels\n            active_channels = await self.db.fetch_one(\n                \"\"\"\n                SELECT COUNT(DISTINCT channel_id) as count\n                FROM emoji_reactions \n                WHERE user_id = $1 AND auto_react_enabled = TRUE\n                \"\"\",\n                user_id\n            )\n            \n            return {\n                'total_reactions': total_reactions['total'] if total_reactions else 0,\n                'reactions_today': reactions_today['count'] if reactions_today else 0,\n                'weekly_reactions': weekly_reactions['count'] if weekly_reactions else 0,\n                'monthly_reactions': monthly_reactions['count'] if monthly_reactions else 0,\n                'success_rate': 95.0,  # Placeholder\n                'active_channels': active_channels['count'] if active_channels else 0,\n                'top_emojis': [(r['emoji'], r['total']) for r in top_emojis],\n                'channel_stats': [{'title': r['title'], 'reactions': r['reactions']} for r in channel_stats],\n                'avg_daily': monthly_reactions['count'] / 30 if monthly_reactions else 0,\n                'peak_hour': 19  # Placeholder - would be calculated from actual data\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting reaction statistics: {e}\")\n            return {\n                'total_reactions': 0, 'reactions_today': 0, 'weekly_reactions': 0,\n                'monthly_reactions': 0, 'success_rate': 0, 'active_channels': 0,\n                'top_emojis': [], 'channel_stats': [], 'avg_daily': 0, 'peak_hour': 19\n            }\n    \n    def _get_configure_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get configure emoji keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üéØ Select Channels\", callback_data=\"er_select_channels\"),\n                InlineKeyboardButton(text=\"üé≠ Choose Emojis\", callback_data=\"er_choose_emojis\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üì¶ Positive Set\", callback_data=\"er_set_positive\"),\n                InlineKeyboardButton(text=\"üí¨ Engagement Set\", callback_data=\"er_set_engagement\")\n            ],\n            [\n                InlineKeyboardButton(text=\"ü§ù Support Set\", callback_data=\"er_set_support\"),\n                InlineKeyboardButton(text=\"üîÄ Mixed Set\", callback_data=\"er_set_mixed\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚öôÔ∏è Advanced Settings\", callback_data=\"er_advanced\"),\n                InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_schedule_keyboard(self, has_scheduled: bool) -> InlineKeyboardMarkup:\n        \"\"\"Get schedule keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"‚ö° Immediate Reactions\", callback_data=\"er_timing_immediate\"),\n                InlineKeyboardButton(text=\"üïê Natural Timing\", callback_data=\"er_timing_natural\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚è≥ Delayed Reactions\", callback_data=\"er_timing_delayed\"),\n                InlineKeyboardButton(text=\"üìà Peak Hours Only\", callback_data=\"er_timing_peak\")\n            ]\n        ]\n        \n        if has_scheduled:\n            buttons.extend([\n                [\n                    InlineKeyboardButton(text=\"‚úèÔ∏è Edit Schedule\", callback_data=\"er_edit_schedule\"),\n                    InlineKeyboardButton(text=\"üóëÔ∏è Clear Schedule\", callback_data=\"er_clear_schedule\")\n                ]\n            ])\n        \n        buttons.append([\n            InlineKeyboardButton(text=\"üîô Back to Reactions\", callback_data=\"emoji_reactions\")\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_stats_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get stats keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìä Detailed Stats\", callback_data=\"er_detailed_stats\"),\n                InlineKeyboardButton(text=\"üìà Performance Chart\", callback_data=\"er_performance\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üé≠ Emoji Analysis\", callback_data=\"er_emoji_analysis\"),\n                InlineKeyboardButton(text=\"üì± Channel Breakdown\", callback_data=\"er_channel_breakdown\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üìã Export Report\", callback_data=\"er_export\"),\n                InlineKeyboardButton(text=\"üîÑ Refresh Stats\", callback_data=\"er_stats\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Reactions\", callback_data=\"emoji_reactions\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_channel_reactions_keyboard(self, channel_id: int, has_reactions: bool) -> InlineKeyboardMarkup:\n        \"\"\"Get channel reactions keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"‚ûï Add Reactions\", callback_data=f\"er_add_{channel_id}\"),\n                InlineKeyboardButton(text=\"‚úÖ Enable Auto\", callback_data=f\"er_enable_{channel_id}\")\n            ]\n        ]\n        \n        if has_reactions:\n            buttons.extend([\n                [\n                    InlineKeyboardButton(text=\"‚úèÔ∏è Edit Reactions\", callback_data=f\"er_edit_{channel_id}\"),\n                    InlineKeyboardButton(text=\"‚è∏Ô∏è Disable Auto\", callback_data=f\"er_disable_{channel_id}\")\n                ],\n                [\n                    InlineKeyboardButton(text=\"üóëÔ∏è Remove All\", callback_data=f\"er_remove_{channel_id}\")\n                ]\n            ])\n        \n        buttons.append([\n            InlineKeyboardButton(text=\"üîô Back to Configure\", callback_data=\"er_configure\")\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_emoji_set_keyboard(self, set_name: str) -> InlineKeyboardMarkup:\n        \"\"\"Get emoji set application keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"‚úÖ Apply to All Channels\", callback_data=f\"er_apply_all_{set_name}\"),\n                InlineKeyboardButton(text=\"üéØ Select Channels\", callback_data=f\"er_apply_select_{set_name}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚≠ê Set as Default\", callback_data=f\"er_set_default_{set_name}\"),\n                InlineKeyboardButton(text=\"üîó Combine Sets\", callback_data=f\"er_combine_{set_name}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üëÄ Preview Reactions\", callback_data=f\"er_preview_{set_name}\"),\n                InlineKeyboardButton(text=\"‚öôÔ∏è Customize Set\", callback_data=f\"er_customize_{set_name}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Configure\", callback_data=\"er_configure\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_reactions_enabled_keyboard(self, channel_id: int) -> InlineKeyboardMarkup:\n        \"\"\"Get reactions enabled keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"‚öôÔ∏è Configure Settings\", callback_data=f\"er_channel_{channel_id}\"),\n                InlineKeyboardButton(text=\"üìä View Stats\", callback_data=\"er_stats\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚ûï Enable More Channels\", callback_data=\"er_configure\"),\n                InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_no_channels_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get no channels keyboard\"\"\"\n        buttons = [\n            [InlineKeyboardButton(text=\"‚ûï Add Channel\", callback_data=\"channel_management\")],\n            [InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    async def _handle_react_messages(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle react to messages\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user channels\n            channels = await self.db.get_user_channels(user_id)\n            if not channels:\n                await callback.message.edit_text(\n                    \"üì≠ <b>No Channels Available</b>\\n\\n\"\n                    \"Please add channels first before reacting to messages.\",\n                    reply_markup=self._get_no_channels_keyboard()\n                )\n                return\n            \n            text = f\"\"\"\nüòÄ <b>React to Messages</b>\n\nAdd emoji reactions to recent messages in your channels automatically.\n\n<b>üéØ Quick Actions:</b>\n‚Ä¢ React to latest 10 messages\n‚Ä¢ React to last hour's posts\n‚Ä¢ React to specific message count\n‚Ä¢ Custom emoji selection\n\n<b>üì± Available Accounts:</b> {await self._get_available_accounts_count(user_id)}\n<b>üì∫ Available Channels:</b> {len(channels)}\n\n<b>üé≠ Reaction Options:</b>\n‚Ä¢ Use positive emoji set\n‚Ä¢ Use engagement emojis\n‚Ä¢ Use support reactions\n‚Ä¢ Custom emoji selection\n\nSelect how many messages to react to:\n            \"\"\"\n            \n            keyboard = self._get_react_messages_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üòÄ Message reactions loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in react messages: {e}\")\n            await callback.answer(\"‚ùå Failed to load reactions\", show_alert=True)\n    \n    async def _handle_reaction_settings(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle reaction settings\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get current settings\n            user = await self.db.get_user(user_id)\n            settings = user.get('settings', {}) if user else {}\n            reaction_settings = settings.get('emoji_reactions', {})\n            \n            text = f\"\"\"\n‚öôÔ∏è <b>Emoji Reaction Settings</b>\n\nConfigure how emoji reactions work across your channels.\n\n<b>üé≠ Current Settings:</b>\n‚Ä¢ Default Emoji Set: {reaction_settings.get('default_set', 'Mixed')}\n‚Ä¢ Reaction Delay: {reaction_settings.get('delay_min', 5)}-{reaction_settings.get('delay_max', 30)} seconds\n‚Ä¢ Max Reactions per Post: {reaction_settings.get('max_reactions', 3)}\n‚Ä¢ Account Rotation: {'‚úÖ Enabled' if reaction_settings.get('rotation_enabled', True) else '‚ùå Disabled'}\n\n<b>‚ö° Timing Settings:</b>\n‚Ä¢ Auto React: {'‚úÖ Enabled' if reaction_settings.get('auto_enabled', False) else '‚ùå Disabled'}\n‚Ä¢ Check Interval: {reaction_settings.get('check_interval', 60)} seconds\n‚Ä¢ Skip Old Messages: {'‚úÖ Yes' if reaction_settings.get('skip_old', True) else '‚ùå No'}\n\n<b>üîí Safety Settings:</b>\n‚Ä¢ Rate Limiting: {'‚úÖ Enabled' if reaction_settings.get('rate_limit', True) else '‚ùå Disabled'}\n‚Ä¢ Random Patterns: {'‚úÖ Enabled' if reaction_settings.get('random_patterns', True) else '‚ùå Disabled'}\n‚Ä¢ Detection Avoidance: {'‚úÖ Enabled' if reaction_settings.get('avoid_detection', True) else '‚ùå Disabled'}\n\nCustomize your reaction behavior:\n            \"\"\"\n            \n            keyboard = self._get_settings_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚öôÔ∏è Reaction settings loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in reaction settings: {e}\")\n            await callback.answer(\"‚ùå Failed to load settings\", show_alert=True)\n    \n    async def _handle_vote_poll(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle poll voting (Poll Manager feature)\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            text = \"\"\"\nüó≥Ô∏è <b>Vote on Polls</b>\n\nAutomatically vote on polls in your channels with multiple accounts.\n\n<b>üìä Poll Voting Features:</b>\n‚Ä¢ Auto-detect new polls\n‚Ä¢ Vote with multiple accounts\n‚Ä¢ Smart vote distribution\n‚Ä¢ Custom voting patterns\n‚Ä¢ Real-time progress tracking\n\n<b>‚öôÔ∏è Voting Options:</b>\n‚Ä¢ Vote on latest polls\n‚Ä¢ Search for specific polls\n‚Ä¢ Configure voting preferences\n‚Ä¢ Set vote distribution ratios\n\n<b>üîß Setup:</b>\n1. Enter poll link or select from channels\n2. Choose voting options and distribution\n3. Select accounts for voting\n4. Start automated voting\n\nüìå Send a poll link or select from detected polls below:\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"üîç Scan for Polls\", callback_data=\"pm_scan_polls\")],\n                [InlineKeyboardButton(text=\"‚öôÔ∏è Vote Settings\", callback_data=\"pm_vote_settings\")],\n                [InlineKeyboardButton(text=\"üìã Paste Poll Link\", callback_data=\"pm_paste_link\")],\n                [InlineKeyboardButton(text=\"üîô Back\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üó≥Ô∏è Poll voting loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in vote poll: {e}\")\n            await callback.answer(\"‚ùå Failed to load poll voting\", show_alert=True)\n    \n    async def _handle_poll_stats(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle poll statistics (Poll Manager feature)\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get poll statistics from database\n            poll_stats = await self.db.fetch_all(\n                \"\"\"\n                SELECT COUNT(*) as total_polls, \n                       SUM(votes_cast) as total_votes,\n                       AVG(votes_cast) as avg_votes_per_poll\n                FROM emoji_reactions \n                WHERE user_id = $1 AND reaction_type = 'poll_vote'\n                \"\"\",\n                user_id\n            )\n            \n            stats = poll_stats[0] if poll_stats else {'total_polls': 0, 'total_votes': 0, 'avg_votes_per_poll': 0}\n            \n            text = f\"\"\"\nüìä <b>Poll Statistics</b>\n\nYour automated poll voting performance and analytics.\n\n<b>üìà Overall Performance:</b>\n‚Ä¢ Total Polls Voted: {stats.get('total_polls', 0):,}\n‚Ä¢ Total Votes Cast: {stats.get('total_votes', 0):,}\n‚Ä¢ Average Votes per Poll: {stats.get('avg_votes_per_poll', 0):.1f}\n\n<b>üéØ Today's Activity:</b>\n‚Ä¢ Polls Found: 0\n‚Ä¢ Votes Cast: 0\n‚Ä¢ Success Rate: 100%\n‚Ä¢ Accounts Used: 0\n\n<b>‚ö° Performance Metrics:</b>\n‚Ä¢ Response Time: < 2 seconds\n‚Ä¢ Detection Accuracy: 98.5%\n‚Ä¢ Vote Distribution: Balanced\n‚Ä¢ Error Rate: < 1%\n\n<b>üì± Account Usage:</b>\n‚Ä¢ Available Accounts: {await self._get_available_accounts_count(user_id)}\n‚Ä¢ Active Voting: 0 accounts\n‚Ä¢ Rotation Status: ‚úÖ Optimal\n\n<b>üîß Recent Polls:</b>\n‚Ä¢ No recent polls detected\n‚Ä¢ Scan channels for new polls\n‚Ä¢ Configure auto-detection settings\n\nSelect an option to view detailed analytics:\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"üìà Detailed Analytics\", callback_data=\"pm_detailed_stats\")],\n                [InlineKeyboardButton(text=\"üìä Vote Distribution\", callback_data=\"pm_distribution\")],\n                [InlineKeyboardButton(text=\"üéØ Success Rates\", callback_data=\"pm_success_rates\")],\n                [InlineKeyboardButton(text=\"üîÑ Refresh Stats\", callback_data=\"pm_stats\")],\n                [InlineKeyboardButton(text=\"üîô Back\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üìä Poll statistics loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in poll stats: {e}\")\n            await callback.answer(\"‚ùå Failed to load poll statistics\", show_alert=True)\n    \n    def _get_react_messages_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get react to messages keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìù React to 10 Latest\", callback_data=\"er_react_10\"),\n                InlineKeyboardButton(text=\"üì∞ React to Last Hour\", callback_data=\"er_react_hour\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üéØ Custom Count\", callback_data=\"er_react_custom\"),\n                InlineKeyboardButton(text=\"‚öôÔ∏è Select Channels\", callback_data=\"er_react_channels\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üé≠ Choose Emojis\", callback_data=\"er_choose_emojis\"),\n                InlineKeyboardButton(text=\"üöÄ Start Reacting\", callback_data=\"er_start_reacting\")\n            ],\n            [InlineKeyboardButton(text=\"üîô Back\", callback_data=\"refresh_main\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_settings_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get reaction settings keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üé≠ Default Emoji Set\", callback_data=\"er_set_default_emojis\"),\n                InlineKeyboardButton(text=\"‚è±Ô∏è Timing Settings\", callback_data=\"er_timing_settings\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîÑ Account Rotation\", callback_data=\"er_rotation_settings\"),\n                InlineKeyboardButton(text=\"üîí Safety Settings\", callback_data=\"er_safety_settings\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üìä Auto React\", callback_data=\"er_auto_settings\"),\n                InlineKeyboardButton(text=\"üéØ Detection Settings\", callback_data=\"er_detection_settings\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üíæ Save Settings\", callback_data=\"er_save_settings\"),\n                InlineKeyboardButton(text=\"üîÑ Reset to Default\", callback_data=\"er_reset_settings\")\n            ],\n            [InlineKeyboardButton(text=\"üîô Back\", callback_data=\"refresh_main\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    async def _get_available_accounts_count(self, user_id: int) -> int:\n        \"\"\"Get count of available accounts for user\"\"\"\n        try:\n            accounts = await self.db.fetch_all(\n                \"SELECT COUNT(*) as count FROM telegram_accounts WHERE user_id = $1 AND is_active = TRUE\",\n                user_id\n            )\n            return accounts[0]['count'] if accounts else 0\n        except Exception as e:\n            logger.error(f\"Error getting accounts count: {e}\")\n            return 0\n    \n    async def shutdown(self):\n        \"\"\"Shutdown emoji reactions handler\"\"\"\n        try:\n            logger.info(\"‚èπÔ∏è Shutting down emoji reactions handler...\")\n            \n            self._running = False\n            \n            # Cancel all workers\n            for worker in self._reaction_workers:\n                worker.cancel()\n            \n            # Wait for workers to finish\n            if self._reaction_workers:\n                await asyncio.gather(*self._reaction_workers, return_exceptions=True)\n            \n            logger.info(\"‚úÖ Emoji reactions handler shut down\")\n            \n        except Exception as e:\n            logger.error(f\"Error shutting down emoji reactions handler: {e}\")\n","size_bytes":48492},"features/live_management/__init__.py":{"content":"\"\"\"\nLive Management Feature\nHandles live stream management and automatic group call joining\n\"\"\"\n\nfrom .handler import LiveManagementHandler\n\n__all__ = ['LiveManagementHandler']\n","size_bytes":177},"features/live_management/handler.py":{"content":"\"\"\"\nLive Management Handler\nMain handler for live stream management and automatic joining\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime, timedelta\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import CallbackQuery, Message\nfrom aiogram.fsm.context import FSMContext\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\nfrom core.database.universal_access import UniversalDatabaseAccess\nfrom core.bot.telegram_bot import TelegramBotCore\nfrom .keyboards import LiveManagementKeyboards\nfrom .states import LiveManagementStates\nfrom .utils import LiveStreamUtils\n\nlogger = logging.getLogger(__name__)\n\n\nclass LiveManagementHandler:\n    \"\"\"Main live stream management handler\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config, bot_core=None):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.universal_db = UniversalDatabaseAccess(db_manager)\n        self.bot_core = bot_core if bot_core else TelegramBotCore(config, db_manager)\n        self.keyboards = LiveManagementKeyboards()\n        self.utils = LiveStreamUtils(bot, db_manager, config)\n        \n        # Initialize joiner components as placeholders for now\n        self.auto_joiner = None\n        self.manual_joiner = None\n        \n        self._monitoring_task: Optional[asyncio.Task] = None\n        self._running = False\n        \n    async def initialize(self):\n        \"\"\"Initialize live management handler\"\"\"\n        try:\n            # Only initialize bot_core if it wasn't passed in (backward compatibility)\n            if hasattr(self, 'bot_core') and self.bot_core and not hasattr(self.bot_core, '_initialized'):\n                await self.bot_core.initialize()\n            # Wait for database schema to be ready before starting monitoring\n            await asyncio.sleep(15)\n            await self._start_live_monitoring()\n            self._running = True\n            logger.info(\"‚úÖ Live management handler initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize live management handler: {e}\")\n            raise\n    \n    async def shutdown(self):\n        \"\"\"Shutdown live management handler\"\"\"\n        try:\n            self._running = False\n            \n            # Stop monitoring task\n            if self._monitoring_task and not self._monitoring_task.done():\n                self._monitoring_task.cancel()\n                try:\n                    await self._monitoring_task\n                except asyncio.CancelledError:\n                    pass\n            \n            # Shutdown bot_core if we own it\n            if hasattr(self, 'bot_core') and self.bot_core and not hasattr(self.bot_core, '_shared'):\n                await self.bot_core.shutdown()\n            \n            logger.info(\"‚úÖ Live management handler shut down\")\n        except Exception as e:\n            logger.error(f\"Error during live management shutdown: {e}\")\n    \n    def register_handlers(self, dp: Dispatcher):\n        \"\"\"Register handlers with dispatcher\"\"\"\n        # Callback registration handled by central inline_handler\n        # dp.callback_query.register(\n        #     self.handle_callback,\n        #     lambda c: c.data.startswith('lm_')\n        # )\n        \n        # Register sub-handlers when available\n        if hasattr(self.auto_joiner, 'register_handlers'):\n            self.auto_joiner.register_handlers(dp)\n        if hasattr(self.manual_joiner, 'register_handlers'):\n            self.manual_joiner.register_handlers(dp)\n        \n        logger.info(\"‚úÖ Live management handlers registered\")\n    \n    async def handle_callback(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle live management callbacks\"\"\"\n        try:\n            callback_data = callback.data\n            user_id = callback.from_user.id\n            \n            # Ensure user exists\n            await self.universal_db.ensure_user_exists(\n                user_id,\n                callback.from_user.username,\n                callback.from_user.first_name,\n                callback.from_user.last_name\n            )\n            \n            if callback_data == \"lm_auto_join\":\n                await self._handle_auto_join_menu(callback, state)\n            elif callback_data == \"lm_manual_join\":\n                await self._handle_manual_join_menu(callback, state)\n            elif callback_data == \"lm_monitor\":\n                await self._handle_live_monitor(callback, state)\n            elif callback_data == \"lm_settings\":\n                await self._handle_voice_settings(callback, state)\n            elif callback_data == \"lm_active_streams\":\n                await self._handle_active_streams(callback, state)\n            elif callback_data == \"lm_stream_history\":\n                await self._handle_stream_history(callback, state)\n            elif callback_data == \"lm_select_channels\":\n                await self._handle_select_channels(callback, state)\n            elif callback_data == \"lm_start_monitoring\":\n                await self._handle_start_monitoring(callback, state)\n            elif callback_data == \"lm_stop_monitoring\":\n                await self._handle_stop_monitoring(callback, state)\n            elif callback_data.startswith(\"lm_stream_\"):\n                await self._handle_specific_stream(callback, state)\n            # Auto-join handlers\n            elif callback_data.startswith(\"aj_\"):\n                await self._handle_auto_join_callbacks(callback, state)\n            # Manual-join handlers  \n            elif callback_data.startswith(\"mj_\"):\n                await self._handle_manual_join_callbacks(callback, state)\n            # Voice settings handlers\n            elif callback_data.startswith(\"vs_\"):\n                await self._handle_voice_settings_callbacks(callback, state)\n            # Live scanner handlers\n            elif callback_data.startswith(\"ls_\"):\n                await self._handle_live_scanner_callbacks(callback, state)\n            else:\n                await callback.answer(\"‚ùå Unknown live management action\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error in live management callback: {e}\")\n            await callback.answer(\"‚ùå An error occurred\", show_alert=True)\n    \n    async def _handle_auto_join_menu(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle auto join menu\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user channels\n            channels = await self.db.get_user_channels(user_id)\n            if not channels:\n                await callback.message.edit_text(\n                    \"üì≠ <b>No Channels Available</b>\\n\\n\"\n                    \"Please add channels first before setting up auto-join for live streams.\",\n                    reply_markup=self.keyboards.get_no_channels_keyboard()\n                )\n                return\n            \n            # Get auto-join status\n            auto_join_status = await self._get_auto_join_status(user_id)\n            \n            text = f\"\"\"\nü§ñ <b>Auto Join Live Streams</b>\n\nAutomatically join live streams and voice chats when they start in your channels.\n\n<b>üìä Current Status:</b>\n‚Ä¢ Enabled Channels: {auto_join_status['enabled_channels']}\n‚Ä¢ Active Monitoring: {auto_join_status['active_monitoring']}\n‚Ä¢ Streams Joined Today: {auto_join_status['streams_today']}\n‚Ä¢ Success Rate: {auto_join_status['success_rate']:.1f}%\n\n<b>ü§ñ Auto Join Features:</b>\n‚Ä¢ Detect live streams automatically\n‚Ä¢ Join within configurable delay\n‚Ä¢ Smart account selection\n‚Ä¢ Avoid detection patterns\n‚Ä¢ Real-time monitoring\n\n<b>‚öôÔ∏è Configuration:</b>\n‚Ä¢ Join Delay: {auto_join_status['join_delay_min']}-{auto_join_status['join_delay_max']} minutes\n‚Ä¢ Max Concurrent Joins: {auto_join_status['max_concurrent']}\n‚Ä¢ Account Rotation: {'‚úÖ Enabled' if auto_join_status['rotation_enabled'] else '‚ùå Disabled'}\n\nSelect an option below:\n            \"\"\"\n            \n            keyboard = self.keyboards.get_auto_join_keyboard(auto_join_status['enabled_channels'] > 0)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"ü§ñ Auto join menu loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in auto join menu: {e}\")\n            await callback.answer(\"‚ùå Failed to load auto join menu\", show_alert=True)\n    \n    async def _handle_manual_join_menu(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle manual join menu\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user channels\n            channels = await self.db.get_user_channels(user_id)\n            if not channels:\n                await callback.message.edit_text(\n                    \"üì≠ <b>No Channels Available</b>\\n\\n\"\n                    \"Please add channels first before manually joining live streams.\",\n                    reply_markup=self.keyboards.get_no_channels_keyboard()\n                )\n                return\n            \n            # Get currently active streams\n            active_streams = await self._get_active_streams(user_id)\n            \n            text = f\"\"\"\nüëÜ <b>Manual Join Live Streams</b>\n\nManually join specific live streams and voice chats with custom settings.\n\n<b>üìä Available Options:</b>\n‚Ä¢ Join specific streams by link\n‚Ä¢ Join from your channels\n‚Ä¢ Custom participant count\n‚Ä¢ Account selection\n‚Ä¢ Timing control\n\n<b>üéôÔ∏è Currently Active Streams:</b>\n\"\"\"\n            \n            if active_streams:\n                for stream in active_streams[:5]:\n                    participants = stream.get('participant_count', 0)\n                    text += f\"‚Ä¢ {stream['channel_title']}: {participants} participants\\n\"\n            else:\n                text += \"‚Ä¢ No active streams detected\\n\"\n            \n            text += f\"\"\"\n<b>üì± Available Accounts:</b> {await self._get_available_accounts_count(user_id)}\n\n<b>‚ö° Quick Actions:</b>\n‚Ä¢ Join latest detected stream\n‚Ä¢ Scan channels for streams\n‚Ä¢ Set up stream alerts\n‚Ä¢ Configure join settings\n\nSelect how you'd like to join streams:\n            \"\"\"\n            \n            keyboard = self.keyboards.get_manual_join_keyboard(len(active_streams) > 0)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üëÜ Manual join menu loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in manual join menu: {e}\")\n            await callback.answer(\"‚ùå Failed to load manual join menu\", show_alert=True)\n    \n    async def _handle_live_monitor(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle live stream monitoring\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get monitoring data\n            monitoring_data = await self._get_monitoring_data(user_id)\n            \n            text = f\"\"\"\nüìä <b>Live Stream Monitor</b>\n\nReal-time monitoring of live streams across your channels.\n\n<b>üéôÔ∏è Active Streams ({monitoring_data['active_count']}):</b>\n\"\"\"\n            \n            for stream in monitoring_data['active_streams']:\n                status_emoji = \"üî¥\" if stream['is_live'] else \"‚ö™\"\n                joined_emoji = \"‚úÖ\" if stream['joined'] else \"‚ùå\"\n                \n                text += (\n                    f\"{status_emoji} <b>{stream['channel_title']}</b>\\n\"\n                    f\"   üë• {stream['participant_count']} participants\\n\"\n                    f\"   {joined_emoji} Joined: {'Yes' if stream['joined'] else 'No'}\\n\"\n                    f\"   ‚è±Ô∏è Duration: {stream['duration']}\\n\\n\"\n                )\n            \n            if not monitoring_data['active_streams']:\n                text += \"‚Ä¢ No active streams at the moment\\n\\n\"\n            \n            text += f\"\"\"\n<b>üìà Today's Statistics:</b>\n‚Ä¢ Streams Detected: {monitoring_data['streams_detected']}\n‚Ä¢ Successful Joins: {monitoring_data['successful_joins']}\n‚Ä¢ Failed Joins: {monitoring_data['failed_joins']}\n‚Ä¢ Average Participants: {monitoring_data['avg_participants']:.0f}\n\n<b>‚ö° System Status:</b>\n‚Ä¢ Monitoring: {'üü¢ Active' if monitoring_data['monitoring_active'] else 'üî¥ Inactive'}\n‚Ä¢ Auto Join: {'üü¢ Enabled' if monitoring_data['auto_join_enabled'] else 'üî¥ Disabled'}\n‚Ä¢ Last Check: {monitoring_data['last_check']}\n‚Ä¢ Next Check: {monitoring_data['next_check']}\n\n<b>üîç Detection Settings:</b>\n‚Ä¢ Check Interval: {monitoring_data['check_interval']} seconds\n‚Ä¢ Monitored Channels: {monitoring_data['monitored_channels']}\n‚Ä¢ Alert Threshold: {monitoring_data['alert_threshold']} participants\n            \"\"\"\n            \n            keyboard = self.keyboards.get_monitor_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üìä Live monitor loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in live monitor: {e}\")\n            await callback.answer(\"‚ùå Failed to load monitor\", show_alert=True)\n    \n    async def _handle_voice_settings(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle voice call settings\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get current voice settings\n            user = await self.db.get_user(user_id)\n            settings = user.get('settings', {}) if user else {}\n            voice_settings = settings.get('live_management', {})\n            \n            text = f\"\"\"\n‚öôÔ∏è <b>Voice Call Settings</b>\n\nConfigure how the bot joins and behaves in live streams and voice chats.\n\n<b>ü§ñ Auto Join Settings:</b>\n‚Ä¢ Auto Join Enabled: {'‚úÖ Yes' if voice_settings.get('auto_join', False) else '‚ùå No'}\n‚Ä¢ Join Delay: {voice_settings.get('join_delay_min', 5)}-{voice_settings.get('join_delay_max', 15)} minutes\n‚Ä¢ Max Concurrent: {voice_settings.get('max_concurrent', 10)} streams\n‚Ä¢ Account Rotation: {'‚úÖ Enabled' if voice_settings.get('rotation', True) else '‚ùå Disabled'}\n\n<b>üéôÔ∏è Audio Settings:</b>\n‚Ä¢ Microphone: {'üîá Muted' if voice_settings.get('mute_mic', True) else 'üé§ Unmuted'}\n‚Ä¢ Camera: {'üì∑ Off' if voice_settings.get('camera_off', True) else 'üìπ On'}\n‚Ä¢ Audio Quality: {voice_settings.get('audio_quality', 'Medium')}\n‚Ä¢ Background Audio: {'‚úÖ Enabled' if voice_settings.get('background_audio', False) else '‚ùå Disabled'}\n\n<b>üîç Detection Settings:</b>\n‚Ä¢ Detection Interval: {voice_settings.get('detection_interval', 60)} seconds\n‚Ä¢ Minimum Participants: {voice_settings.get('min_participants', 5)}\n‚Ä¢ Auto Leave Empty: {'‚úÖ Yes' if voice_settings.get('auto_leave_empty', True) else '‚ùå No'}\n‚Ä¢ Leave Delay: {voice_settings.get('leave_delay', 300)} seconds\n\n<b>üö® Alert Settings:</b>\n‚Ä¢ Stream Start Alerts: {'‚úÖ Enabled' if voice_settings.get('start_alerts', True) else '‚ùå Disabled'}\n‚Ä¢ Join Success Alerts: {'‚úÖ Enabled' if voice_settings.get('success_alerts', False) else '‚ùå Disabled'}\n‚Ä¢ Error Alerts: {'‚úÖ Enabled' if voice_settings.get('error_alerts', True) else '‚ùå Disabled'}\n\n<b>üîê Privacy Settings:</b>\n‚Ä¢ Anonymous Mode: {'‚úÖ Enabled' if voice_settings.get('anonymous', True) else '‚ùå Disabled'}\n‚Ä¢ Hide Phone Number: {'‚úÖ Yes' if voice_settings.get('hide_phone', True) else '‚ùå No'}\n‚Ä¢ Randomize Join Order: {'‚úÖ Yes' if voice_settings.get('randomize_order', True) else '‚ùå No'}\n            \"\"\"\n            \n            keyboard = self.keyboards.get_voice_settings_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚öôÔ∏è Voice settings loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in voice settings: {e}\")\n            await callback.answer(\"‚ùå Failed to load settings\", show_alert=True)\n    \n    async def _start_live_monitoring(self):\n        \"\"\"Start background live stream monitoring\"\"\"\n        try:\n            self._monitoring_task = asyncio.create_task(self._monitoring_loop())\n            logger.info(\"‚úÖ Live stream monitoring started\")\n        except Exception as e:\n            logger.error(f\"Error starting live monitoring: {e}\")\n            raise\n    \n    async def _monitoring_loop(self):\n        \"\"\"Background monitoring loop for live streams\"\"\"\n        logger.info(\"üîß Started live stream monitoring loop\")\n        \n        while self._running:\n            try:\n                # Get all channels with live monitoring enabled\n                channels_to_monitor = await self.db.fetch_all(\n                    \"\"\"\n                    SELECT c.*, u.settings\n                    FROM telegram_channels c\n                    JOIN users u ON c.user_id = u.user_id\n                    WHERE c.is_active = TRUE AND u.is_active = TRUE\n                    \"\"\"\n                )\n                \n                # Monitor each channel\n                for channel in channels_to_monitor:\n                    try:\n                        await self._monitor_channel_for_streams(channel)\n                    except Exception as e:\n                        logger.error(f\"Error monitoring channel {channel['id']}: {e}\")\n                \n                # Wait before next check\n                await asyncio.sleep(60)  # Check every minute\n                \n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Error in live monitoring loop: {e}\")\n                await asyncio.sleep(30)\n    \n    async def _monitor_channel_for_streams(self, channel: Dict[str, Any]):\n        \"\"\"Monitor specific channel for live streams\"\"\"\n        try:\n            user_id = channel['user_id']\n            \n            # Get user accounts\n            accounts = await self.db.get_user_accounts(user_id, active_only=True)\n            if not accounts:\n                return\n            \n            # Check for live streams using first available account\n            client = await self.bot_core.get_client(accounts[0]['id'])\n            if not client:\n                return\n            \n            # Check rate limits\n            if not await self.bot_core.check_rate_limit(accounts[0]['id']):\n                return\n            \n            # Get channel entity and check for active calls\n            try:\n                channel_entity = await client.get_entity(channel['channel_id'])\n                \n                # This would use actual Telegram API to check for group calls\n                # For now, we'll simulate detection\n                has_active_call = False  # Would check actual call status\n                \n                if has_active_call:\n                    # Stream detected, process auto-join if enabled\n                    await self._process_detected_stream(channel, accounts)\n                \n                # Update rate limiter\n                await self.bot_core.increment_rate_limit(accounts[0]['id'])\n                \n            except Exception as e:\n                logger.warning(f\"Could not check stream status for channel {channel['id']}: {e}\")\n                \n        except Exception as e:\n            logger.error(f\"Error monitoring channel for streams: {e}\")\n    \n    async def _process_detected_stream(self, channel: Dict[str, Any], accounts: List[Dict[str, Any]]):\n        \"\"\"Process a detected live stream\"\"\"\n        try:\n            user_id = channel['user_id']\n            \n            # Check if auto-join is enabled for this user\n            user = await self.db.get_user(user_id)\n            settings = user.get('settings', {}) if user else {}\n            live_settings = settings.get('live_management', {})\n            \n            if not live_settings.get('auto_join', False):\n                return\n            \n            # Check if we already have a record of this stream\n            existing_stream = await self.db.fetch_one(\n                \"\"\"\n                SELECT id FROM live_streams \n                WHERE channel_id = $1 AND is_active = TRUE \n                AND start_time >= NOW() - INTERVAL '1 hour'\n                \"\"\",\n                channel['id']\n            )\n            \n            if existing_stream:\n                return  # Already tracking this stream\n            \n            # Create stream record\n            stream_id = await self.db.execute_query(\n                \"\"\"\n                INSERT INTO live_streams \n                (channel_id, stream_id, title, is_active, auto_join_enabled, start_time, settings, created_at, updated_at)\n                VALUES ($1, $2, $3, TRUE, TRUE, NOW(), $4, NOW(), NOW())\n                RETURNING id\n                \"\"\",\n                channel['id'],\n                0,  # Would get actual stream ID\n                f\"Live stream in {channel['title']}\",\n                live_settings\n            )\n            \n            # Trigger auto-join when available\n            if hasattr(self.auto_joiner, 'join_stream'):\n                await self.auto_joiner.join_stream(stream_id, accounts)\n            \n            logger.info(f\"‚úÖ Detected and processing live stream in {channel['title']}\")\n            \n        except Exception as e:\n            logger.error(f\"Error processing detected stream: {e}\")\n    \n    async def _get_auto_join_status(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get auto-join status for user\"\"\"\n        try:\n            # Get user settings\n            user = await self.db.get_user(user_id)\n            settings = user.get('settings', {}) if user else {}\n            live_settings = settings.get('live_management', {})\n            \n            # Count enabled channels\n            channels = await self.db.get_user_channels(user_id)\n            enabled_channels = len([c for c in channels if live_settings.get('auto_join', False)])\n            \n            # Get today's statistics\n            streams_today = await self.db.fetch_one(\n                \"\"\"\n                SELECT COUNT(*) as count\n                FROM live_stream_participants lsp\n                JOIN live_streams ls ON lsp.stream_id = ls.id\n                JOIN telegram_channels c ON ls.channel_id = c.id\n                WHERE u.user_id = $1 AND lsp.joined_at >= DATE(NOW())\n                \"\"\",\n                user_id\n            )\n            \n            return {\n                'enabled_channels': enabled_channels,\n                'active_monitoring': len(channels) > 0,\n                'streams_today': streams_today['count'] if streams_today else 0,\n                'success_rate': 95.0,  # Would calculate from actual data\n                'join_delay_min': live_settings.get('join_delay_min', 5),\n                'join_delay_max': live_settings.get('join_delay_max', 15),\n                'max_concurrent': live_settings.get('max_concurrent', 10),\n                'rotation_enabled': live_settings.get('rotation', True)\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting auto-join status: {e}\")\n            return {\n                'enabled_channels': 0, 'active_monitoring': False, 'streams_today': 0,\n                'success_rate': 0, 'join_delay_min': 5, 'join_delay_max': 15,\n                'max_concurrent': 10, 'rotation_enabled': True\n            }\n    \n    async def _get_active_streams(self, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get currently active streams for user\"\"\"\n        try:\n            active_streams = await self.db.fetch_all(\n                \"\"\"\n                SELECT ls.*, c.title as channel_title, c.username as channel_username\n                FROM live_streams ls\n                JOIN telegram_channels c ON ls.channel_id = c.id\n                WHERE u.user_id = $1 AND ls.is_active = TRUE\n                ORDER BY ls.start_time DESC\n                \"\"\",\n                user_id\n            )\n            \n            return active_streams\n            \n        except Exception as e:\n            logger.error(f\"Error getting active streams: {e}\")\n            return []\n    \n    async def _get_available_accounts_count(self, user_id: int) -> int:\n        \"\"\"Get count of available accounts for user\"\"\"\n        try:\n            result = await self.db.fetch_one(\n                \"SELECT COUNT(*) as count FROM telegram_accounts WHERE user_id = $1 AND is_active = TRUE\",\n                user_id\n            )\n            return result['count'] if result else 0\n        except Exception as e:\n            logger.error(f\"Error getting available accounts count: {e}\")\n            return 0\n    \n    async def _get_monitoring_data(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get monitoring data for user\"\"\"\n        try:\n            # Get active streams\n            active_streams = await self._get_active_streams(user_id)\n            \n            # Get today's statistics\n            today_stats = await self.db.fetch_all(\n                \"\"\"\n                SELECT \n                    COUNT(DISTINCT ls.id) as streams_detected,\n                    COUNT(DISTINCT lsp.id) as joins_attempted,\n                    COUNT(DISTINCT CASE WHEN lsp.is_active THEN lsp.id END) as successful_joins\n                FROM live_streams ls\n                JOIN telegram_channels c ON ls.channel_id = c.id\n                LEFT JOIN live_stream_participants lsp ON ls.id = lsp.stream_id\n                WHERE u.user_id = $1 AND ls.start_time >= DATE(NOW())\n                \"\"\",\n                user_id\n            )\n            \n            stats = today_stats[0] if today_stats else {}\n            \n            # Process active streams for display\n            processed_streams = []\n            for stream in active_streams:\n                processed_streams.append({\n                    'channel_title': stream['channel_title'],\n                    'is_live': stream['is_active'],\n                    'joined': True,  # Would check actual participation\n                    'participant_count': stream.get('participant_count', 0),\n                    'duration': self._format_duration(stream['start_time'])\n                })\n            \n            return {\n                'active_count': len(active_streams),\n                'active_streams': processed_streams,\n                'streams_detected': stats.get('streams_detected', 0),\n                'successful_joins': stats.get('successful_joins', 0),\n                'failed_joins': max(0, stats.get('joins_attempted', 0) - stats.get('successful_joins', 0)),\n                'avg_participants': 25,  # Would calculate from actual data\n                'monitoring_active': True,\n                'auto_join_enabled': True,  # Would get from user settings\n                'last_check': '2 minutes ago',\n                'next_check': '58 seconds',\n                'check_interval': 60,\n                'monitored_channels': len(await self.db.get_user_channels(user_id)),\n                'alert_threshold': 10\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting monitoring data: {e}\")\n            return {}\n    \n    def _format_duration(self, start_time: datetime) -> str:\n        \"\"\"Format stream duration\"\"\"\n        try:\n            if not start_time:\n                return \"Unknown\"\n            \n            delta = datetime.now() - start_time.replace(tzinfo=None)\n            \n            if delta.days > 0:\n                return f\"{delta.days}d {delta.seconds // 3600}h\"\n            elif delta.seconds >= 3600:\n                return f\"{delta.seconds // 3600}h {(delta.seconds % 3600) // 60}m\"\n            else:\n                return f\"{delta.seconds // 60}m\"\n                \n        except Exception:\n            return \"Unknown\"\n    \n    # Placeholder implementations for the new handlers\n    async def _handle_auto_join_setup(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Auto-join setup coming soon\", show_alert=True)\n    \n    async def _handle_auto_join_manage_channels(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Channel management coming soon\", show_alert=True)\n    \n    async def _handle_auto_join_statistics(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Auto-join statistics coming soon\", show_alert=True)\n    \n    async def _handle_auto_join_schedule(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Schedule settings coming soon\", show_alert=True)\n    \n    async def _handle_auto_join_pause(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"‚è∏Ô∏è Auto-join paused\")\n    \n    async def _handle_auto_join_resume(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"‚ñ∂Ô∏è Auto-join resumed\")\n    \n    async def _handle_auto_join_advanced(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Advanced settings coming soon\", show_alert=True)\n    \n    async def _handle_manual_join_by_link(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Join by link coming soon\", show_alert=True)\n    \n    async def _handle_manual_join_select_channel(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Channel selection coming soon\", show_alert=True)\n    \n    async def _handle_manual_join_active(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Join active streams coming soon\", show_alert=True)\n    \n    async def _handle_manual_view_active(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß View active streams coming soon\", show_alert=True)\n    \n    async def _handle_manual_scan(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Manual scan coming soon\", show_alert=True)\n    \n    async def _handle_manual_join_settings(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Join settings coming soon\", show_alert=True)\n    \n    async def _handle_manual_join_history(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Join history coming soon\", show_alert=True)\n    \n    async def _handle_manual_join_alerts(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Stream alerts coming soon\", show_alert=True)\n    \n    async def _handle_voice_auto_join_settings(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Auto-join voice settings coming soon\", show_alert=True)\n    \n    async def _handle_voice_audio_settings(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Audio settings coming soon\", show_alert=True)\n    \n    async def _handle_voice_detection_settings(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Detection settings coming soon\", show_alert=True)\n    \n    async def _handle_voice_alerts_settings(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Voice alerts settings coming soon\", show_alert=True)\n    \n    async def _handle_voice_privacy_settings(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Privacy settings coming soon\", show_alert=True)\n    \n    async def _handle_voice_performance_settings(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Performance settings coming soon\", show_alert=True)\n    \n    async def _handle_voice_save_settings(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üíæ Settings saved\")\n    \n    async def _handle_voice_reset_settings(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üîÑ Settings reset to default\")\n    \n    async def _handle_live_quick_scan(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Quick scan coming soon\", show_alert=True)\n    \n    async def _handle_live_deep_scan(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Deep scan coming soon\", show_alert=True)\n    \n    async def _handle_live_realtime_scan(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Real-time scan coming soon\", show_alert=True)\n    \n    async def _handle_live_scan_all(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Scan all channels coming soon\", show_alert=True)\n    \n    async def _handle_live_custom_scan(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Custom scan coming soon\", show_alert=True)\n    \n    async def _handle_live_scan_results(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Scan results coming soon\", show_alert=True)\n    \n    async def _handle_live_scanner_settings(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Scanner settings coming soon\", show_alert=True)\n    \n    async def _handle_live_export_scan(self, callback: CallbackQuery, state: FSMContext):\n        await callback.answer(\"üöß Export scan coming soon\", show_alert=True)\n    \n    async def _handle_select_channels(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle select channels for live monitoring\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user channels\n            channels = await self.db.get_user_channels(user_id)\n            if not channels:\n                await callback.message.edit_text(\n                    \"üì≠ <b>No Channels Available</b>\\n\\n\"\n                    \"Please add channels first before selecting them for live monitoring.\",\n                    reply_markup=self.keyboards.get_no_channels_keyboard()\n                )\n                return\n            \n            text = \"‚öôÔ∏è <b>Select Channels for Live Monitoring</b>\\n\\n\"\n            text += \"Choose channels to monitor for live streams and voice chats:\\n\\n\"\n            \n            for i, channel in enumerate(channels[:10], 1):\n                status = \"‚úÖ\" if channel.get('monitoring_enabled', False) else \"‚ùå\"\n                text += f\"{status} {i}. {channel['title']}\\n\"\n            \n            text += \"\\nüìã Select channels to enable/disable monitoring:\"\n            \n            keyboard = self.keyboards.get_channel_selection_keyboard(channels[:10])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚öôÔ∏è Channel selection loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in select channels: {e}\")\n            await callback.answer(\"‚ùå Failed to load channel selection\", show_alert=True)\n    \n    async def _handle_start_monitoring(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle start monitoring command\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user channels\n            channels = await self.db.get_user_channels(user_id)\n            if not channels:\n                await callback.answer(\"‚ùå No channels available for monitoring\", show_alert=True)\n                return\n            \n            # Start monitoring for user channels\n            enabled_count = 0\n            for channel in channels:\n                if channel.get('monitoring_enabled', True):\n                    enabled_count += 1\n            \n            if enabled_count == 0:\n                await callback.answer(\"‚ùå No channels enabled for monitoring. Select channels first.\", show_alert=True)\n                return\n            \n            # Update monitoring status in database\n            await self.db.update_user_monitoring_status(user_id, True)\n            \n            text = f\"\"\"\n‚ñ∂Ô∏è <b>Live Monitoring Started</b>\n\nüéØ <b>Monitoring Status:</b>\n‚Ä¢ Channels: {enabled_count} enabled\n‚Ä¢ Status: üü¢ Active\n‚Ä¢ Started: Now\n‚Ä¢ Mode: Automatic detection\n\n‚ö° <b>What's Being Monitored:</b>\n‚Ä¢ Live video streams\n‚Ä¢ Voice chats  \n‚Ä¢ Audio calls\n‚Ä¢ Screen sharing\n\nThe system is now actively scanning your selected channels for live streams.\nYou'll be notified when streams are detected and auto-join is available.\n            \"\"\"\n            \n            await callback.message.edit_text(text, reply_markup=self.keyboards.get_monitor_keyboard())\n            await callback.answer(\"‚ñ∂Ô∏è Live monitoring started!\")\n            \n        except Exception as e:\n            logger.error(f\"Error starting monitoring: {e}\")\n            await callback.answer(\"‚ùå Failed to start monitoring\", show_alert=True)\n    \n    async def _handle_stop_monitoring(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle stop monitoring command\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Update monitoring status in database\n            await self.db.update_user_monitoring_status(user_id, False)\n            \n            text = \"\"\"\n‚èπÔ∏è <b>Live Monitoring Stopped</b>\n\nüéØ <b>Monitoring Status:</b>\n‚Ä¢ Status: üî¥ Inactive\n‚Ä¢ Stopped: Now\n‚Ä¢ Mode: Manual only\n\n‚ö° <b>What Was Stopped:</b>\n‚Ä¢ Automatic stream detection\n‚Ä¢ Live stream notifications\n‚Ä¢ Auto-join functionality\n‚Ä¢ Background scanning\n\nLive monitoring has been stopped. You can restart it anytime or use manual join options.\n            \"\"\"\n            \n            await callback.message.edit_text(text, reply_markup=self.keyboards.get_monitor_keyboard())\n            await callback.answer(\"‚èπÔ∏è Live monitoring stopped!\")\n            \n        except Exception as e:\n            logger.error(f\"Error stopping monitoring: {e}\")\n            await callback.answer(\"‚ùå Failed to stop monitoring\", show_alert=True)\n    \n    async def shutdown(self):\n        \"\"\"Shutdown live management handler\"\"\"\n        try:\n            logger.info(\"‚èπÔ∏è Shutting down live management handler...\")\n            \n            self._running = False\n            \n            # Cancel monitoring task\n            if self._monitoring_task:\n                self._monitoring_task.cancel()\n                try:\n                    await self._monitoring_task\n                except asyncio.CancelledError:\n                    pass\n            \n            # Shutdown sub-handlers\n            if hasattr(self.auto_joiner, 'shutdown'):\n                await self.auto_joiner.shutdown()\n            if hasattr(self.manual_joiner, 'shutdown'):\n                await self.manual_joiner.shutdown()\n            \n            logger.info(\"‚úÖ Live management handler shut down\")\n            \n        except Exception as e:\n            logger.error(f\"Error shutting down live management handler: {e}\")\n","size_bytes":38987},"features/live_management/keyboards.py":{"content":"\"\"\"\nLive Management Keyboards\nInline keyboards for live stream management operations\n\"\"\"\n\nfrom typing import List, Dict, Any\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n\n\nclass LiveManagementKeyboards:\n    \"\"\"Keyboards for live management\"\"\"\n    \n    def get_auto_join_keyboard(self, has_enabled: bool) -> InlineKeyboardMarkup:\n        \"\"\"Get auto join keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"‚öôÔ∏è Setup Auto Join\", callback_data=\"aj_setup\"),\n                InlineKeyboardButton(text=\"üìã Manage Channels\", callback_data=\"aj_manage_channels\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üìä Join Statistics\", callback_data=\"aj_statistics\"),\n                InlineKeyboardButton(text=\"‚è∞ Schedule Settings\", callback_data=\"aj_schedule\")\n            ]\n        ]\n        \n        if has_enabled:\n            buttons.append([\n                InlineKeyboardButton(text=\"‚è∏Ô∏è Pause Auto Join\", callback_data=\"aj_pause\"),\n                InlineKeyboardButton(text=\"üîÑ Resume Auto Join\", callback_data=\"aj_resume\")\n            ])\n        \n        buttons.extend([\n            [InlineKeyboardButton(text=\"‚öôÔ∏è Advanced Settings\", callback_data=\"aj_advanced\")],\n            [InlineKeyboardButton(text=\"üîô Back to Live Management\", callback_data=\"live_management\")]\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_manual_join_keyboard(self, has_active_streams: bool) -> InlineKeyboardMarkup:\n        \"\"\"Get manual join keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üîó Join by Link\", callback_data=\"mj_by_link\"),\n                InlineKeyboardButton(text=\"üìã Select Channel\", callback_data=\"mj_select_channel\")\n            ]\n        ]\n        \n        if has_active_streams:\n            buttons.append([\n                InlineKeyboardButton(text=\"üéôÔ∏è Join Active Stream\", callback_data=\"mj_join_active\"),\n                InlineKeyboardButton(text=\"üëÅÔ∏è View Active Streams\", callback_data=\"mj_view_active\")\n            ])\n        \n        buttons.extend([\n            [\n                InlineKeyboardButton(text=\"üîç Scan for Streams\", callback_data=\"mj_scan\"),\n                InlineKeyboardButton(text=\"‚öôÔ∏è Join Settings\", callback_data=\"mj_settings\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üìä Join History\", callback_data=\"mj_history\"),\n                InlineKeyboardButton(text=\"üö® Stream Alerts\", callback_data=\"mj_alerts\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Live Management\", callback_data=\"live_management\")\n            ]\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_monitor_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get monitor keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üîÑ Refresh Monitor\", callback_data=\"lm_monitor\"),\n                InlineKeyboardButton(text=\"‚ö° Real-time View\", callback_data=\"lm_realtime\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üìä Detailed Analytics\", callback_data=\"lm_analytics\"),\n                InlineKeyboardButton(text=\"üìà Performance Charts\", callback_data=\"lm_charts\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîç Stream Scanner\", callback_data=\"lm_scanner\"),\n                InlineKeyboardButton(text=\"üö® Alert Settings\", callback_data=\"lm_alerts\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üì§ Export Report\", callback_data=\"lm_export\"),\n                InlineKeyboardButton(text=\"‚öôÔ∏è Monitor Settings\", callback_data=\"lm_monitor_settings\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Live Management\", callback_data=\"live_management\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_voice_settings_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get voice settings keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"ü§ñ Auto Join Settings\", callback_data=\"vs_auto_join\"),\n                InlineKeyboardButton(text=\"üéôÔ∏è Audio Settings\", callback_data=\"vs_audio\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîç Detection Settings\", callback_data=\"vs_detection\"),\n                InlineKeyboardButton(text=\"üö® Alert Settings\", callback_data=\"vs_alerts\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîê Privacy Settings\", callback_data=\"vs_privacy\"),\n                InlineKeyboardButton(text=\"‚ö° Performance Settings\", callback_data=\"vs_performance\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üíæ Save Settings\", callback_data=\"vs_save\"),\n                InlineKeyboardButton(text=\"üîÑ Reset to Default\", callback_data=\"vs_reset\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Live Management\", callback_data=\"live_management\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_no_channels_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get no channels keyboard\"\"\"\n        buttons = [\n            [InlineKeyboardButton(text=\"‚ûï Add Channel\", callback_data=\"channel_management\")],\n            [InlineKeyboardButton(text=\"üîô Back to Live Management\", callback_data=\"live_management\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_stream_details_keyboard(self, stream_id: int) -> InlineKeyboardMarkup:\n        \"\"\"Get stream details keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üöÄ Join Stream\", callback_data=f\"lm_join_{stream_id}\"),\n                InlineKeyboardButton(text=\"üë• View Participants\", callback_data=f\"lm_participants_{stream_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üìä Stream Stats\", callback_data=f\"lm_stats_{stream_id}\"),\n                InlineKeyboardButton(text=\"üîî Set Alert\", callback_data=f\"lm_alert_{stream_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üì§ Share Stream\", callback_data=f\"lm_share_{stream_id}\"),\n                InlineKeyboardButton(text=\"‚öôÔ∏è Stream Settings\", callback_data=f\"lm_stream_settings_{stream_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Monitor\", callback_data=\"lm_monitor\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_join_confirmation_keyboard(self, stream_id: int) -> InlineKeyboardMarkup:\n        \"\"\"Get join confirmation keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"‚úÖ Confirm Join\", callback_data=f\"lm_confirm_join_{stream_id}\"),\n                InlineKeyboardButton(text=\"‚ùå Cancel\", callback_data=\"lm_monitor\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚öôÔ∏è Join Settings\", callback_data=f\"lm_join_settings_{stream_id}\"),\n                InlineKeyboardButton(text=\"üì± Select Accounts\", callback_data=f\"lm_select_accounts_{stream_id}\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_stream_history_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get stream history keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìä Today's Streams\", callback_data=\"lm_history_today\"),\n                InlineKeyboardButton(text=\"üìà This Week\", callback_data=\"lm_history_week\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üìÖ This Month\", callback_data=\"lm_history_month\"),\n                InlineKeyboardButton(text=\"üìã All Time\", callback_data=\"lm_history_all\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üéØ Filter by Channel\", callback_data=\"lm_filter_channel\"),\n                InlineKeyboardButton(text=\"üîç Search Streams\", callback_data=\"lm_search_streams\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üì§ Export History\", callback_data=\"lm_export_history\"),\n                InlineKeyboardButton(text=\"üìä Statistics\", callback_data=\"lm_history_stats\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Live Management\", callback_data=\"live_management\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_auto_join_setup_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get auto join setup keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìã Select Channels\", callback_data=\"aj_select_channels\"),\n                InlineKeyboardButton(text=\"‚è∞ Set Timing\", callback_data=\"aj_set_timing\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üì± Choose Accounts\", callback_data=\"aj_choose_accounts\"),\n                InlineKeyboardButton(text=\"üéØ Set Conditions\", callback_data=\"aj_set_conditions\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚úÖ Enable Auto Join\", callback_data=\"aj_enable\"),\n                InlineKeyboardButton(text=\"üß™ Test Setup\", callback_data=\"aj_test\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Auto Join\", callback_data=\"lm_auto_join\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_account_selection_keyboard(self, accounts: List[Dict[str, Any]]) -> InlineKeyboardMarkup:\n        \"\"\"Get account selection keyboard\"\"\"\n        buttons = []\n        \n        # Add account buttons (max 6)\n        for account in accounts[:6]:\n            status_emoji = \"üü¢\" if account['is_active'] else \"üî¥\"\n            buttons.append([\n                InlineKeyboardButton(\n                    text=f\"{status_emoji} {account['phone_number']}\",\n                    callback_data=f\"lm_account_{account['id']}\"\n                )\n            ])\n        \n        # Control buttons\n        buttons.extend([\n            [\n                InlineKeyboardButton(text=\"‚úÖ Select All\", callback_data=\"lm_select_all_accounts\"),\n                InlineKeyboardButton(text=\"‚ùå Deselect All\", callback_data=\"lm_deselect_all_accounts\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üé≤ Random Selection\", callback_data=\"lm_random_accounts\"),\n                InlineKeyboardButton(text=\"üíö Healthy Only\", callback_data=\"lm_healthy_accounts\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚úÖ Confirm Selection\", callback_data=\"lm_confirm_accounts\"),\n                InlineKeyboardButton(text=\"üîô Back\", callback_data=\"lm_manual_join\")\n            ]\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def get_stream_scanner_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get stream scanner keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üîç Quick Scan\", callback_data=\"ls_quick_scan\"),\n                InlineKeyboardButton(text=\"üî¨ Deep Scan\", callback_data=\"ls_deep_scan\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚ö° Real-time Scan\", callback_data=\"ls_realtime_scan\"),\n                InlineKeyboardButton(text=\"üìã Scan All Channels\", callback_data=\"ls_scan_all\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üéØ Custom Scan\", callback_data=\"ls_custom_scan\"),\n                InlineKeyboardButton(text=\"üìä Scan Results\", callback_data=\"ls_scan_results\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚öôÔ∏è Scanner Settings\", callback_data=\"ls_scanner_settings\"),\n                InlineKeyboardButton(text=\"üì§ Export Results\", callback_data=\"ls_export_scan\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Monitor\", callback_data=\"lm_monitor\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n","size_bytes":12327},"features/live_management/states.py":{"content":"\"\"\"\nLive Management FSM States\nFinite State Machine states for live stream management operations\n\"\"\"\n\nfrom aiogram.fsm.state import State, StatesGroup\n\n\nclass LiveManagementStates(StatesGroup):\n    \"\"\"FSM states for live management operations\"\"\"\n    \n    # Auto join setup states\n    setting_up_auto_join = State()\n    selecting_auto_channels = State()\n    configuring_auto_timing = State()\n    setting_auto_conditions = State()\n    \n    # Manual join states\n    waiting_for_stream_link = State()\n    selecting_accounts_for_join = State()\n    configuring_join_settings = State()\n    confirming_manual_join = State()\n    \n    # Stream monitoring states\n    configuring_monitor_settings = State()\n    setting_alert_conditions = State()\n    customizing_monitor_view = State()\n    \n    # Voice settings states\n    configuring_audio_settings = State()\n    setting_privacy_options = State()\n    configuring_detection_params = State()\n    setting_performance_options = State()\n\n\nclass AutoJoinStates(StatesGroup):\n    \"\"\"FSM states specific to auto join functionality\"\"\"\n    \n    # Channel selection\n    selecting_channels_for_auto = State()\n    configuring_channel_priorities = State()\n    setting_channel_specific_rules = State()\n    \n    # Timing configuration\n    setting_join_delays = State()\n    configuring_peak_hours = State()\n    setting_blackout_periods = State()\n    \n    # Account management\n    assigning_accounts_to_channels = State()\n    configuring_account_rotation = State()\n    setting_account_limits = State()\n    \n    # Conditions and filters\n    setting_participant_thresholds = State()\n    configuring_stream_filters = State()\n    setting_quality_requirements = State()\n\n\nclass ManualJoinStates(StatesGroup):\n    \"\"\"FSM states specific to manual join operations\"\"\"\n    \n    # Stream identification\n    entering_stream_link = State()\n    scanning_for_streams = State()\n    selecting_detected_stream = State()\n    \n    # Join configuration\n    selecting_join_accounts = State()\n    setting_join_timing = State()\n    configuring_join_behavior = State()\n    \n    # Advanced options\n    setting_custom_parameters = State()\n    configuring_leave_conditions = State()\n    setting_interaction_rules = State()\n\n\nclass StreamMonitorStates(StatesGroup):\n    \"\"\"FSM states for stream monitoring\"\"\"\n    \n    # Monitor configuration\n    setting_monitor_channels = State()\n    configuring_check_intervals = State()\n    setting_detection_sensitivity = State()\n    \n    # Alert configuration\n    setting_alert_types = State()\n    configuring_notification_methods = State()\n    setting_alert_thresholds = State()\n    \n    # Data management\n    configuring_data_retention = State()\n    setting_export_preferences = State()\n    configuring_analytics_options = State()\n\n\nclass VoiceSettingsStates(StatesGroup):\n    \"\"\"FSM states for voice and audio settings\"\"\"\n    \n    # Audio configuration\n    setting_audio_quality = State()\n    configuring_microphone_settings = State()\n    setting_speaker_options = State()\n    \n    # Privacy configuration\n    setting_anonymity_level = State()\n    configuring_identity_protection = State()\n    setting_interaction_limits = State()\n    \n    # Performance optimization\n    setting_connection_quality = State()\n    configuring_bandwidth_limits = State()\n    setting_resource_usage = State()\n","size_bytes":3321},"features/live_management/utils.py":{"content":"\"\"\"\nLive Stream Management Utilities\nUtility functions for live stream detection and management\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime, timedelta\n\nfrom aiogram import Bot\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\n\nlogger = logging.getLogger(__name__)\n\n\nclass LiveStreamUtils:\n    \"\"\"Utilities for live stream management\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        \n    async def detect_live_streams(self, channel_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Detect active live streams in a channel\"\"\"\n        try:\n            # Placeholder implementation for live stream detection\n            # This would integrate with Telegram's API to detect voice chats/live streams\n            logger.info(f\"Checking for live streams in channel {channel_id}\")\n            return []\n            \n        except Exception as e:\n            logger.error(f\"Error detecting live streams: {e}\")\n            return []\n    \n    async def is_live_stream_active(self, channel_id: int) -> bool:\n        \"\"\"Check if a live stream is currently active\"\"\"\n        try:\n            streams = await self.detect_live_streams(channel_id)\n            return len(streams) > 0\n        except Exception as e:\n            logger.error(f\"Error checking live stream status: {e}\")\n            return False\n    \n    async def get_stream_info(self, channel_id: int, stream_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get information about a specific stream\"\"\"\n        try:\n            # Placeholder for stream information retrieval\n            return {\n                'id': stream_id,\n                'channel_id': channel_id,\n                'status': 'active',\n                'participants': 0,\n                'started_at': datetime.now()\n            }\n        except Exception as e:\n            logger.error(f\"Error getting stream info: {e}\")\n            return None\n    \n    async def validate_stream_access(self, user_id: int, channel_id: int) -> bool:\n        \"\"\"Validate if user has access to join streams in channel\"\"\"\n        try:\n            # Check if user has accounts configured\n            accounts = await self.db.get_user_accounts(user_id, active_only=True)\n            if not accounts:\n                return False\n                \n            # Check if channel is in user's managed channels\n            channels = await self.db.get_user_channels(user_id)\n            channel_ids = [ch['channel_id'] for ch in channels]\n            \n            return channel_id in channel_ids\n            \n        except Exception as e:\n            logger.error(f\"Error validating stream access: {e}\")\n            return False\n    \n    async def log_stream_activity(self, user_id: int, channel_id: int, action: str, details: Dict[str, Any] = None):\n        \"\"\"Log stream-related activity\"\"\"\n        try:\n            await self.db.execute_query(\n                \"\"\"\n                INSERT INTO live_stream_logs (user_id, channel_id, action, details, created_at)\n                VALUES ($1, $2, $3, $4, NOW())\n                \"\"\",\n                user_id, channel_id, action, details or {}\n            )\n        except Exception as e:\n            logger.error(f\"Error logging stream activity: {e}\")","size_bytes":3425},"features/system_health/__init__.py":{"content":"\"\"\"\nSystem Health Feature\nMonitors and reports on bot system health and performance\n\"\"\"\n\nfrom .handler import SystemHealthHandler\n\n__all__ = ['SystemHealthHandler']\n","size_bytes":165},"features/system_health/handler.py":{"content":"\"\"\"\nSystem Health Handler\nMonitors bot performance, database health, and system metrics\n\"\"\"\n\nimport asyncio\nimport logging\nimport psutil\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime, timedelta\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import CallbackQuery, Message\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\nfrom core.database.universal_access import UniversalDatabaseAccess\n\nlogger = logging.getLogger(__name__)\n\n\nclass SystemHealthHandler:\n    \"\"\"Handler for system health monitoring\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.universal_db = UniversalDatabaseAccess(db_manager)\n        self._monitoring_task: Optional[asyncio.Task] = None\n        self._running = False\n        self._health_history = []\n        \n    async def initialize(self):\n        \"\"\"Initialize system health handler\"\"\"\n        try:\n            await self._start_monitoring()\n            self._running = True\n            logger.info(\"‚úÖ System health handler initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize system health handler: {e}\")\n            raise\n    \n    def register_handlers(self, dp: Dispatcher):\n        \"\"\"Register handlers with dispatcher\"\"\"\n        # Callback registration handled by central inline_handler\n        # dp.callback_query.register(\n        #     self.handle_callback,\n        #     lambda c: c.data.startswith('sh_')\n        # )\n        \n        logger.info(\"‚úÖ System health handlers registered\")\n    \n    async def handle_callback(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle system health callbacks\"\"\"\n        try:\n            callback_data = callback.data\n            user_id = callback.from_user.id\n            \n            # Check admin access\n            if user_id not in self.config.ADMIN_IDS:\n                await callback.answer(\"‚ùå Admin access required!\", show_alert=True)\n                return\n            \n            if callback_data == \"sh_performance\":\n                await self._handle_performance_overview(callback, state)\n            elif callback_data == \"sh_database\":\n                await self._handle_database_health(callback, state)\n            elif callback_data == \"sh_accounts\":\n                await self._handle_accounts_status(callback, state)\n            elif callback_data == \"sh_errors\":\n                await self._handle_error_monitor(callback, state)\n            elif callback_data == \"sh_realtime\":\n                await self._handle_realtime_monitor(callback, state)\n            elif callback_data == \"sh_alerts\":\n                await self._handle_alerts_config(callback, state)\n            elif callback_data == \"sh_maintenance\":\n                await self._handle_maintenance_mode(callback, state)\n            else:\n                await callback.answer(\"‚ùå Unknown system health action\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error in system health callback: {e}\")\n            await callback.answer(\"‚ùå An error occurred\", show_alert=True)\n    \n    async def _handle_performance_overview(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle performance overview\"\"\"\n        try:\n            # Get current system metrics\n            performance_data = await self._get_system_performance()\n            \n            text = f\"\"\"\nüìä <b>System Performance Overview</b>\n\n<b>üñ•Ô∏è System Resources:</b>\n‚Ä¢ CPU Usage: {performance_data['cpu_usage']:.1f}%\n‚Ä¢ Memory Usage: {performance_data['memory_usage']:.1f}%\n‚Ä¢ Disk Usage: {performance_data['disk_usage']:.1f}%\n‚Ä¢ Network I/O: ‚Üë{performance_data['network_sent']:.1f}MB ‚Üì{performance_data['network_recv']:.1f}MB\n\n<b>üöÄ Bot Performance:</b>\n‚Ä¢ Uptime: {performance_data['uptime']}\n‚Ä¢ Active Connections: {performance_data['active_connections']}\n‚Ä¢ Requests/Hour: {performance_data['requests_per_hour']:,}\n‚Ä¢ Response Time: {performance_data['avg_response_time']:.2f}s\n\n<b>üìä Operation Statistics:</b>\n‚Ä¢ View Boosts Today: {performance_data['boosts_today']:,}\n‚Ä¢ Successful Operations: {performance_data['success_rate']:.1f}%\n‚Ä¢ Failed Operations: {performance_data['failed_operations']}\n‚Ä¢ Rate Limit Hits: {performance_data['rate_limits']}\n\n<b>üóÑÔ∏è Database Performance:</b>\n‚Ä¢ Query Response Time: {performance_data['db_response_time']:.2f}ms\n‚Ä¢ Active Connections: {performance_data['db_connections']}\n‚Ä¢ Queries/Second: {performance_data['queries_per_sec']:.1f}\n‚Ä¢ Cache Hit Rate: {performance_data['cache_hit_rate']:.1f}%\n\n<b>‚ö° Performance Score: {performance_data['performance_score']}/100</b>\n\n<b>üéØ Status:</b> {performance_data['status']}\n            \"\"\"\n            \n            keyboard = self._get_performance_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üìä Performance overview loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in performance overview: {e}\")\n            await callback.answer(\"‚ùå Failed to load performance data\", show_alert=True)\n    \n    async def _handle_database_health(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle database health\"\"\"\n        try:\n            # Get database health information\n            db_health = await self._get_database_health()\n            \n            text = f\"\"\"\nüóÑÔ∏è <b>Database Health Report</b>\n\n<b>üìä Connection Status:</b>\n‚Ä¢ Status: {db_health['status']}\n‚Ä¢ Pool Size: {db_health['pool_size']}/{db_health['max_pool_size']}\n‚Ä¢ Active Connections: {db_health['active_connections']}\n‚Ä¢ Idle Connections: {db_health['idle_connections']}\n\n<b>‚ö° Performance Metrics:</b>\n‚Ä¢ Average Query Time: {db_health['avg_query_time']:.2f}ms\n‚Ä¢ Slow Queries: {db_health['slow_queries']}\n‚Ä¢ Failed Queries: {db_health['failed_queries']}\n‚Ä¢ Transaction Rate: {db_health['transaction_rate']:.1f}/sec\n\n<b>üìà Database Statistics:</b>\n‚Ä¢ Total Records: {db_health['total_records']:,}\n‚Ä¢ Daily Growth: {db_health['daily_growth']:+,} records\n‚Ä¢ Database Size: {db_health['db_size']:.1f}MB\n‚Ä¢ Index Efficiency: {db_health['index_efficiency']:.1f}%\n\n<b>üîß Table Statistics:</b>\n\"\"\"\n            \n            for table in db_health['table_stats']:\n                text += f\"‚Ä¢ {table['name']}: {table['rows']:,} rows, {table['size']:.1f}MB\\n\"\n            \n            text += f\"\"\"\n<b>üö® Health Issues:</b>\n\"\"\"\n            if db_health['issues']:\n                for issue in db_health['issues']:\n                    text += f\"‚Ä¢ ‚ö†Ô∏è {issue}\\n\"\n            else:\n                text += \"‚Ä¢ ‚úÖ No issues detected\\n\"\n            \n            text += f\"\"\"\n<b>üí° Recommendations:</b>\n\"\"\"\n            for recommendation in db_health['recommendations']:\n                text += f\"‚Ä¢ {recommendation}\\n\"\n            \n            keyboard = self._get_database_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üóÑÔ∏è Database health loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in database health: {e}\")\n            await callback.answer(\"‚ùå Failed to load database health\", show_alert=True)\n    \n    async def _handle_accounts_status(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle accounts status overview\"\"\"\n        try:\n            # Get system-wide account statistics\n            account_status = await self._get_accounts_system_status()\n            \n            text = f\"\"\"\nüì± <b>System-wide Account Status</b>\n\n<b>üìä Account Overview:</b>\n‚Ä¢ Total Accounts: {account_status['total_accounts']}\n‚Ä¢ Active Accounts: {account_status['active_accounts']}\n‚Ä¢ Verified Accounts: {account_status['verified_accounts']}\n‚Ä¢ Online Accounts: {account_status['online_accounts']}\n\n<b>üíö Health Distribution:</b>\n‚Ä¢ Healthy (80-100): {account_status['healthy_count']} accounts\n‚Ä¢ Warning (50-79): {account_status['warning_count']} accounts\n‚Ä¢ Critical (<50): {account_status['critical_count']} accounts\n‚Ä¢ Average Health: {account_status['avg_health']:.1f}/100\n\n<b>‚ö° Performance Metrics:</b>\n‚Ä¢ Total API Calls: {account_status['total_api_calls']:,}\n‚Ä¢ Success Rate: {account_status['success_rate']:.1f}%\n‚Ä¢ Rate Limit Hits: {account_status['rate_limit_hits']}\n‚Ä¢ Account Utilization: {account_status['utilization']:.1f}%\n\n<b>üö® Issues Summary:</b>\n‚Ä¢ Inactive Accounts: {account_status['inactive_accounts']}\n‚Ä¢ Rate Limited: {account_status['rate_limited']}\n‚Ä¢ Authentication Issues: {account_status['auth_issues']}\n‚Ä¢ Connection Problems: {account_status['connection_issues']}\n\n<b>üë• User Distribution:</b>\n‚Ä¢ Total Users: {account_status['total_users']}\n‚Ä¢ Active Users: {account_status['active_users']}\n‚Ä¢ Users with Issues: {account_status['users_with_issues']}\n\n<b>üìà Recent Activity (24h):</b>\n‚Ä¢ New Accounts Added: {account_status['new_accounts_24h']}\n‚Ä¢ Accounts Activated: {account_status['activated_24h']}\n‚Ä¢ Accounts Deactivated: {account_status['deactivated_24h']}\n            \"\"\"\n            \n            keyboard = self._get_accounts_status_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üì± Account status loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in accounts status: {e}\")\n            await callback.answer(\"‚ùå Failed to load account status\", show_alert=True)\n    \n    async def _handle_error_monitor(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle error monitoring\"\"\"\n        try:\n            # Get recent errors and system logs\n            error_data = await self._get_error_monitoring_data()\n            \n            text = f\"\"\"\nüö® <b>Error Monitoring Dashboard</b>\n\n<b>üìä Error Summary (Last 24h):</b>\n‚Ä¢ Total Errors: {error_data['total_errors']}\n‚Ä¢ Critical Errors: {error_data['critical_errors']}\n‚Ä¢ Warning Errors: {error_data['warning_errors']}\n‚Ä¢ Error Rate: {error_data['error_rate']:.2f}%\n\n<b>üî• Top Error Types:</b>\n\"\"\"\n            \n            for error_type in error_data['top_errors']:\n                text += f\"‚Ä¢ {error_type['type']}: {error_type['count']} occurrences\\n\"\n            \n            text += f\"\"\"\n<b>üìà Error Trends:</b>\n‚Ä¢ Errors vs Yesterday: {error_data['trend_change']:+.1f}%\n‚Ä¢ Peak Error Hour: {error_data['peak_hour']}:00\n‚Ä¢ Most Affected Module: {error_data['most_affected_module']}\n\n<b>üö® Recent Critical Errors:</b>\n\"\"\"\n            \n            for error in error_data['recent_critical']:\n                text += f\"‚Ä¢ [{error['timestamp']}] {error['module']}: {error['message'][:50]}...\\n\"\n            \n            text += f\"\"\"\n<b>‚ö° System Health Impact:</b>\n‚Ä¢ Performance Impact: {error_data['performance_impact']}\n‚Ä¢ User Experience Impact: {error_data['ux_impact']}\n‚Ä¢ Availability: {error_data['availability']:.1f}%\n\n<b>üîß Automated Actions:</b>\n‚Ä¢ Auto-restarts: {error_data['auto_restarts']}\n‚Ä¢ Failover Triggers: {error_data['failovers']}\n‚Ä¢ Rate Limit Adjustments: {error_data['rate_adjustments']}\n            \"\"\"\n            \n            keyboard = self._get_error_monitor_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üö® Error monitoring loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in error monitoring: {e}\")\n            await callback.answer(\"‚ùå Failed to load error data\", show_alert=True)\n    \n    async def _handle_realtime_monitor(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle real-time monitoring\"\"\"\n        try:\n            # Get real-time metrics\n            realtime_data = await self._get_realtime_metrics()\n            \n            text = f\"\"\"\n‚ö° <b>Real-time System Monitor</b>\nüìÖ Last Updated: {datetime.now().strftime('%H:%M:%S')}\n\n<b>üîÑ Live Operations:</b>\n‚Ä¢ Active View Boosts: {realtime_data['active_boosts']}\n‚Ä¢ Queue Size: {realtime_data['queue_size']}\n‚Ä¢ Operations/Minute: {realtime_data['ops_per_minute']}\n‚Ä¢ Success Rate (5min): {realtime_data['recent_success_rate']:.1f}%\n\n<b>üåê Network Activity:</b>\n‚Ä¢ Telegram API Calls: {realtime_data['api_calls_per_min']}/min\n‚Ä¢ Rate Limit Status: {realtime_data['rate_limit_status']}\n‚Ä¢ Connection Pool: {realtime_data['connection_pool_usage']:.1f}%\n‚Ä¢ Latency: {realtime_data['network_latency']:.0f}ms\n\n<b>üíæ Resource Usage:</b>\n‚Ä¢ CPU: {realtime_data['current_cpu']:.1f}%\n‚Ä¢ Memory: {realtime_data['current_memory']:.1f}%\n‚Ä¢ Threads: {realtime_data['active_threads']}\n‚Ä¢ File Handles: {realtime_data['file_handles']}\n\n<b>üìä Performance Indicators:</b>\n‚Ä¢ Response Time: {realtime_data['current_response_time']:.2f}s\n‚Ä¢ Throughput: {realtime_data['throughput']:.1f} ops/sec\n‚Ä¢ Error Rate: {realtime_data['current_error_rate']:.2f}%\n‚Ä¢ Cache Efficiency: {realtime_data['cache_efficiency']:.1f}%\n\n<b>üéØ Active Users:</b>\n‚Ä¢ Online Users: {realtime_data['online_users']}\n‚Ä¢ Active Sessions: {realtime_data['active_sessions']}\n‚Ä¢ Concurrent Operations: {realtime_data['concurrent_ops']}\n\n<b>üöÄ System Status: {realtime_data['overall_status']}</b>\n            \"\"\"\n            \n            keyboard = self._get_realtime_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚ö° Real-time data refreshed\")\n            \n        except Exception as e:\n            logger.error(f\"Error in real-time monitor: {e}\")\n            await callback.answer(\"‚ùå Failed to load real-time data\", show_alert=True)\n    \n    async def _start_monitoring(self):\n        \"\"\"Start background system monitoring\"\"\"\n        try:\n            self._monitoring_task = asyncio.create_task(self._monitoring_loop())\n            logger.info(\"‚úÖ System health monitoring started\")\n        except Exception as e:\n            logger.error(f\"Error starting monitoring: {e}\")\n            raise\n    \n    async def _monitoring_loop(self):\n        \"\"\"Background monitoring loop\"\"\"\n        while self._running:\n            try:\n                # Collect system metrics\n                metrics = await self._collect_system_metrics()\n                \n                # Store metrics in history\n                self._health_history.append({\n                    'timestamp': datetime.now(),\n                    'metrics': metrics\n                })\n                \n                # Keep only last 24 hours of data\n                cutoff_time = datetime.now() - timedelta(hours=24)\n                self._health_history = [\n                    h for h in self._health_history \n                    if h['timestamp'] > cutoff_time\n                ]\n                \n                # Check for alerts\n                await self._check_health_alerts(metrics)\n                \n                # Sleep for monitoring interval\n                await asyncio.sleep(self.config.HEALTH_CHECK_INTERVAL)\n                \n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Error in monitoring loop: {e}\")\n                await asyncio.sleep(60)\n    \n    async def _collect_system_metrics(self) -> Dict[str, Any]:\n        \"\"\"Collect comprehensive system metrics\"\"\"\n        try:\n            # System resource metrics\n            cpu_percent = psutil.cpu_percent(interval=1)\n            memory = psutil.virtual_memory()\n            disk = psutil.disk_usage('/')\n            network = psutil.net_io_counters()\n            \n            # Database metrics\n            db_health = await self.db.get_health_status()\n            \n            # Application metrics\n            app_metrics = await self._get_application_metrics()\n            \n            return {\n                'cpu_usage': cpu_percent,\n                'memory_usage': memory.percent,\n                'memory_available': memory.available,\n                'disk_usage': disk.percent,\n                'disk_free': disk.free,\n                'network_sent': network.bytes_sent,\n                'network_recv': network.bytes_recv,\n                'database_status': db_health.get('status', 'unknown'),\n                'db_connections': db_health.get('pool', {}).get('size', 0),\n                'app_metrics': app_metrics,\n                'timestamp': datetime.now()\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error collecting system metrics: {e}\")\n            return {}\n    \n    async def _get_application_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get application-specific metrics\"\"\"\n        try:\n            # Get recent operation counts\n            recent_campaigns = await self.db.fetch_one(\n                \"SELECT COUNT(*) as count FROM view_boost_campaigns WHERE created_at >= NOW() - INTERVAL '1 hour'\"\n            )\n            \n            recent_errors = await self.db.fetch_one(\n                \"SELECT COUNT(*) as count FROM system_logs WHERE log_level = 'ERROR' AND timestamp >= NOW() - INTERVAL '1 hour'\"\n            )\n            \n            return {\n                'recent_campaigns': recent_campaigns['count'] if recent_campaigns else 0,\n                'recent_errors': recent_errors['count'] if recent_errors else 0,\n                'uptime_hours': self._calculate_uptime_hours()\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting application metrics: {e}\")\n            return {}\n    \n    def _calculate_uptime_hours(self) -> float:\n        \"\"\"Calculate application uptime in hours\"\"\"\n        try:\n            # This would track actual start time\n            # For now, return a placeholder\n            return 24.5\n        except Exception:\n            return 0.0\n    \n    async def _check_health_alerts(self, metrics: Dict[str, Any]):\n        \"\"\"Check metrics for alert conditions\"\"\"\n        try:\n            alerts = []\n            \n            # CPU usage alert\n            if metrics.get('cpu_usage', 0) > 90:\n                alerts.append({\n                    'type': 'HIGH_CPU',\n                    'severity': 'CRITICAL',\n                    'message': f\"High CPU usage: {metrics['cpu_usage']:.1f}%\"\n                })\n            \n            # Memory usage alert\n            if metrics.get('memory_usage', 0) > 85:\n                alerts.append({\n                    'type': 'HIGH_MEMORY',\n                    'severity': 'WARNING',\n                    'message': f\"High memory usage: {metrics['memory_usage']:.1f}%\"\n                })\n            \n            # Disk usage alert\n            if metrics.get('disk_usage', 0) > 90:\n                alerts.append({\n                    'type': 'HIGH_DISK',\n                    'severity': 'CRITICAL',\n                    'message': f\"High disk usage: {metrics['disk_usage']:.1f}%\"\n                })\n            \n            # Log alerts if any\n            for alert in alerts:\n                await self.db.log_system_event(\n                    alert['severity'], 'system_health',\n                    f\"ALERT: {alert['message']}\",\n                    {'alert_type': alert['type'], 'metrics': metrics}\n                )\n            \n        except Exception as e:\n            logger.error(f\"Error checking health alerts: {e}\")\n    \n    async def _get_system_performance(self) -> Dict[str, Any]:\n        \"\"\"Get system performance data\"\"\"\n        try:\n            # Current system metrics\n            cpu_percent = psutil.cpu_percent()\n            memory = psutil.virtual_memory()\n            disk = psutil.disk_usage('/')\n            network = psutil.net_io_counters()\n            \n            # Application performance metrics\n            performance_score = 100\n            if cpu_percent > 80:\n                performance_score -= 20\n            if memory.percent > 80:\n                performance_score -= 15\n            if disk.percent > 90:\n                performance_score -= 25\n            \n            status = \"Excellent\" if performance_score >= 90 else \"Good\" if performance_score >= 70 else \"Warning\" if performance_score >= 50 else \"Critical\"\n            \n            return {\n                'cpu_usage': cpu_percent,\n                'memory_usage': memory.percent,\n                'disk_usage': disk.percent,\n                'network_sent': network.bytes_sent / 1024 / 1024,  # MB\n                'network_recv': network.bytes_recv / 1024 / 1024,  # MB\n                'uptime': self._format_uptime(),\n                'active_connections': 25,  # Would get from actual data\n                'requests_per_hour': 1500,  # Would calculate from logs\n                'avg_response_time': 1.25,  # Would calculate from metrics\n                'boosts_today': 450,  # Would get from database\n                'success_rate': 96.5,  # Would calculate from operations\n                'failed_operations': 12,  # Would get from logs\n                'rate_limits': 3,  # Would get from monitoring\n                'db_response_time': 15.5,  # Would get from database\n                'db_connections': 8,  # Would get from database pool\n                'queries_per_sec': 12.3,  # Would calculate from metrics\n                'cache_hit_rate': 85.2,  # Would get from cache metrics\n                'performance_score': performance_score,\n                'status': status\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting system performance: {e}\")\n            return {}\n    \n    def _format_uptime(self) -> str:\n        \"\"\"Format system uptime\"\"\"\n        try:\n            # This would calculate actual uptime\n            return \"2d 14h 32m\"\n        except Exception:\n            return \"Unknown\"\n    \n    async def _get_database_health(self) -> Dict[str, Any]:\n        \"\"\"Get database health information\"\"\"\n        try:\n            # Get database health from coordinator\n            db_health = await self.db.get_health_status()\n            \n            # Get table statistics\n            table_stats = await self.db.fetch_all(\n                \"\"\"\n                SELECT \n                    schemaname,\n                    relname as tablename,\n                    n_tup_ins + n_tup_upd + n_tup_del as total_ops,\n                    n_tup_ins as inserts,\n                    n_tup_upd as updates,\n                    n_tup_del as deletes\n                FROM pg_stat_user_tables \n                WHERE schemaname = 'public'\n                ORDER BY total_ops DESC\n                LIMIT 10\n                \"\"\"\n            )\n            \n            formatted_tables = []\n            for table in table_stats:\n                formatted_tables.append({\n                    'name': table['tablename'],\n                    'rows': table['total_ops'],\n                    'size': 1.5  # Would calculate actual size\n                })\n            \n            issues = []\n            recommendations = []\n            \n            # Check for issues\n            pool_info = db_health.get('pool', {})\n            if pool_info.get('size', 0) > pool_info.get('max_size', 20) * 0.8:\n                issues.append(\"Connection pool nearing capacity\")\n                recommendations.append(\"Consider increasing max pool size\")\n            \n            if not issues:\n                recommendations.append(\"Database is running optimally\")\n            \n            return {\n                'status': 'üü¢ Connected',\n                'pool_size': pool_info.get('size', 0),\n                'max_pool_size': pool_info.get('max_size', 20),\n                'active_connections': pool_info.get('size', 0) - pool_info.get('idle_connections', 0),\n                'idle_connections': pool_info.get('idle_connections', 0),\n                'avg_query_time': 15.2,  # Would calculate from metrics\n                'slow_queries': 2,  # Would get from logs\n                'failed_queries': 1,  # Would get from logs\n                'transaction_rate': 45.8,  # Would calculate\n                'total_records': 15420,  # Would calculate\n                'daily_growth': 245,  # Would calculate\n                'db_size': 125.6,  # Would calculate actual size\n                'index_efficiency': 94.2,  # Would calculate\n                'table_stats': formatted_tables,\n                'issues': issues,\n                'recommendations': recommendations\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting database health: {e}\")\n            return {}\n    \n    async def _get_accounts_system_status(self) -> Dict[str, Any]:\n        \"\"\"Get system-wide account status\"\"\"\n        try:\n            # Get all accounts across all users\n            all_accounts = await self.db.fetch_all(\"SELECT * FROM telegram_accounts\")\n            all_users = await self.db.fetch_all(\"SELECT * FROM users\")\n            \n            total_accounts = len(all_accounts)\n            active_accounts = len([a for a in all_accounts if a['is_active']])\n            verified_accounts = len([a for a in all_accounts if a['is_verified']])\n            \n            # Calculate health distribution\n            healthy_count = 0\n            warning_count = 0\n            critical_count = 0\n            \n            for account in all_accounts:\n                # Simple health calculation\n                health_score = 100\n                if not account['is_verified']:\n                    health_score -= 30\n                if not account['is_active']:\n                    health_score -= 50\n                if not account['last_login'] or (datetime.now() - account['last_login']).days > 7:\n                    health_score -= 20\n                \n                if health_score >= 80:\n                    healthy_count += 1\n                elif health_score >= 50:\n                    warning_count += 1\n                else:\n                    critical_count += 1\n            \n            avg_health = (healthy_count * 90 + warning_count * 65 + critical_count * 25) / total_accounts if total_accounts > 0 else 0\n            \n            return {\n                'total_accounts': total_accounts,\n                'active_accounts': active_accounts,\n                'verified_accounts': verified_accounts,\n                'online_accounts': active_accounts,  # Approximation\n                'healthy_count': healthy_count,\n                'warning_count': warning_count,\n                'critical_count': critical_count,\n                'avg_health': avg_health,\n                'total_api_calls': total_accounts * 1000,  # Estimate\n                'success_rate': 95.5,  # Would calculate from logs\n                'rate_limit_hits': 8,  # Would get from monitoring\n                'utilization': 75.2,  # Would calculate\n                'inactive_accounts': total_accounts - active_accounts,\n                'rate_limited': 2,  # Would calculate\n                'auth_issues': 1,  # Would get from logs\n                'connection_issues': 0,  # Would get from monitoring\n                'total_users': len(all_users),\n                'active_users': len([u for u in all_users if u['is_active']]),\n                'users_with_issues': 3,  # Would calculate\n                'new_accounts_24h': 5,  # Would calculate from timestamps\n                'activated_24h': 2,  # Would calculate\n                'deactivated_24h': 1   # Would calculate\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting accounts system status: {e}\")\n            return {}\n    \n    async def _get_error_monitoring_data(self) -> Dict[str, Any]:\n        \"\"\"Get error monitoring data\"\"\"\n        try:\n            # Get recent errors\n            recent_errors = await self.db.get_system_logs('ERROR', limit=100)\n            recent_warnings = await self.db.get_system_logs('WARNING', limit=50)\n            \n            total_errors = len(recent_errors)\n            critical_errors = len([e for e in recent_errors if 'CRITICAL' in e['message']])\n            warning_errors = len(recent_warnings)\n            \n            # Calculate error rate (errors per total operations)\n            error_rate = 2.5  # Would calculate from actual metrics\n            \n            # Get top error types\n            error_types = {}\n            for error in recent_errors:\n                error_type = error['module']\n                error_types[error_type] = error_types.get(error_type, 0) + 1\n            \n            top_errors = [\n                {'type': k, 'count': v} \n                for k, v in sorted(error_types.items(), key=lambda x: x[1], reverse=True)\n            ][:5]\n            \n            return {\n                'total_errors': total_errors,\n                'critical_errors': critical_errors,\n                'warning_errors': warning_errors,\n                'error_rate': error_rate,\n                'top_errors': top_errors,\n                'trend_change': -15.2,  # Would calculate from historical data\n                'peak_hour': 14,  # Would calculate from timestamps\n                'most_affected_module': top_errors[0]['type'] if top_errors else 'None',\n                'recent_critical': recent_errors[:5],\n                'performance_impact': 'Low',  # Would assess based on error types\n                'ux_impact': 'Minimal',  # Would assess\n                'availability': 99.2,  # Would calculate\n                'auto_restarts': 2,  # Would track\n                'failovers': 0,  # Would track\n                'rate_adjustments': 5  # Would track\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting error monitoring data: {e}\")\n            return {}\n    \n    async def _get_realtime_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get real-time system metrics\"\"\"\n        try:\n            # Current system state\n            cpu_percent = psutil.cpu_percent()\n            memory = psutil.virtual_memory()\n            \n            # Would get these from actual monitoring\n            return {\n                'active_boosts': 12,\n                'queue_size': 5,\n                'ops_per_minute': 45,\n                'recent_success_rate': 97.2,\n                'api_calls_per_min': 150,\n                'rate_limit_status': 'Normal',\n                'connection_pool_usage': 65.5,\n                'network_latency': 125,\n                'current_cpu': cpu_percent,\n                'current_memory': memory.percent,\n                'active_threads': 8,\n                'file_handles': 245,\n                'current_response_time': 1.15,\n                'throughput': 12.5,\n                'current_error_rate': 1.8,\n                'cache_efficiency': 88.5,\n                'online_users': 15,\n                'active_sessions': 23,\n                'concurrent_ops': 7,\n                'overall_status': 'üü¢ Healthy'\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting real-time metrics: {e}\")\n            return {}\n    \n    # Keyboard methods\n    def _get_performance_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get performance keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìä Detailed Metrics\", callback_data=\"sh_detailed_perf\"),\n                InlineKeyboardButton(text=\"üìà Performance History\", callback_data=\"sh_perf_history\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚ö° Real-time Monitor\", callback_data=\"sh_realtime\"),\n                InlineKeyboardButton(text=\"üîß Optimization\", callback_data=\"sh_optimization\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîÑ Refresh\", callback_data=\"sh_performance\"),\n                InlineKeyboardButton(text=\"üì§ Export Report\", callback_data=\"sh_export_perf\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to System Health\", callback_data=\"system_health\")\n            ]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_database_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get database keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìä Query Analysis\", callback_data=\"sh_query_analysis\"),\n                InlineKeyboardButton(text=\"üîß Optimize Queries\", callback_data=\"sh_optimize_db\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üíæ Backup Status\", callback_data=\"sh_backup_status\"),\n                InlineKeyboardButton(text=\"üìà Growth Trends\", callback_data=\"sh_db_growth\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîÑ Refresh\", callback_data=\"sh_database\"),\n                InlineKeyboardButton(text=\"‚öôÔ∏è DB Settings\", callback_data=\"sh_db_settings\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to System Health\", callback_data=\"system_health\")\n            ]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_accounts_status_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get accounts status keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìä Detailed Analysis\", callback_data=\"sh_account_analysis\"),\n                InlineKeyboardButton(text=\"üö® Problem Accounts\", callback_data=\"sh_problem_accounts\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üìà Usage Patterns\", callback_data=\"sh_usage_patterns\"),\n                InlineKeyboardButton(text=\"‚ö° Performance By User\", callback_data=\"sh_user_performance\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîÑ Refresh\", callback_data=\"sh_accounts\"),\n                InlineKeyboardButton(text=\"üîß Mass Operations\", callback_data=\"sh_mass_ops\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to System Health\", callback_data=\"system_health\")\n            ]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_error_monitor_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get error monitor keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üìä Error Analysis\", callback_data=\"sh_error_analysis\"),\n                InlineKeyboardButton(text=\"üîç Error Search\", callback_data=\"sh_error_search\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üö® Alert Rules\", callback_data=\"sh_alert_rules\"),\n                InlineKeyboardButton(text=\"üìà Error Trends\", callback_data=\"sh_error_trends\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîÑ Refresh\", callback_data=\"sh_errors\"),\n                InlineKeyboardButton(text=\"üóëÔ∏è Clear Old Logs\", callback_data=\"sh_clear_logs\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to System Health\", callback_data=\"system_health\")\n            ]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_realtime_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get real-time keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üîÑ Auto-Refresh\", callback_data=\"sh_auto_refresh\"),\n                InlineKeyboardButton(text=\"üìä Detailed View\", callback_data=\"sh_detailed_realtime\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚ö° Performance Mode\", callback_data=\"sh_performance_mode\"),\n                InlineKeyboardButton(text=\"üéØ Custom Metrics\", callback_data=\"sh_custom_metrics\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîÑ Refresh Now\", callback_data=\"sh_realtime\"),\n                InlineKeyboardButton(text=\"üì± Mobile View\", callback_data=\"sh_mobile_view\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to System Health\", callback_data=\"system_health\")\n            ]\n        ]\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    async def shutdown(self):\n        \"\"\"Shutdown system health handler\"\"\"\n        try:\n            logger.info(\"‚èπÔ∏è Shutting down system health handler...\")\n            \n            self._running = False\n            \n            if self._monitoring_task:\n                self._monitoring_task.cancel()\n                try:\n                    await self._monitoring_task\n                except asyncio.CancelledError:\n                    pass\n            \n            logger.info(\"‚úÖ System health handler shut down\")\n            \n        except Exception as e:\n            logger.error(f\"Error shutting down system health handler: {e}\")\n","size_bytes":37000},"features/view_manager/__init__.py":{"content":"\"\"\"\nView Manager Feature\nHandles view boosting operations - both automatic and manual\n\"\"\"\n\nfrom .handler import ViewManagerHandler\n\n__all__ = ['ViewManagerHandler']\n","size_bytes":165},"features/view_manager/handler.py":{"content":"\"\"\"\nViews Manager Handler - ArcX Bot\nAuto Boost system with channel selection and configuration\n\"\"\"\n\nimport asyncio\nimport logging\nimport uuid\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime, timedelta\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import CallbackQuery, Message\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\nfrom aiogram.fsm.state import State, StatesGroup\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\n\nlogger = logging.getLogger(__name__)\n\n\nclass ViewBoostStates(StatesGroup):\n    \"\"\"FSM states for view boosting\"\"\"\n    waiting_for_boost_config = State()\n\n\nclass ViewManagerHandler:\n    \"\"\"Simplified Views Manager with Auto Boost functionality\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config, bot_core=None):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.bot_core = bot_core\n        self._boost_engines = {}  # Active boost monitoring engines\n        self._pending_configs = {}  # Store temporary configs during setup\n        \n    async def initialize(self):\n        \"\"\"Initialize view manager handler\"\"\"\n        try:\n            # Start the monitoring engine\n            await self._start_monitoring_engine()\n            logger.info(\"‚úÖ View manager handler initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize view manager handler: {e}\")\n            raise\n    \n    async def shutdown(self):\n        \"\"\"Shutdown view manager handler\"\"\"\n        try:\n            # Stop all boost engines\n            for engine_id, engine in self._boost_engines.items():\n                if hasattr(engine, 'stop'):\n                    await engine.stop()\n            \n            self._boost_engines.clear()\n            logger.info(\"‚úÖ View manager handler shut down\")\n        except Exception as e:\n            logger.error(f\"Error during view manager shutdown: {e}\")\n    \n    def register_handlers(self, dp: Dispatcher):\n        \"\"\"Register handlers with dispatcher\"\"\"\n        # FSM message handlers\n        dp.message.register(self.handle_boost_config_input, ViewBoostStates.waiting_for_boost_config)\n        \n        logger.info(\"‚úÖ View manager handlers registered\")\n    \n    async def handle_callback(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle view manager callbacks\"\"\"\n        try:\n            if not callback.data:\n                await callback.answer(\"‚ùå Invalid callback data\", show_alert=True)\n                return\n                \n            callback_data = callback.data\n            user_id = callback.from_user.id\n            \n            # Debug logging for all view manager callbacks\n            logger.info(f\"üîç VIEW MANAGER DEBUG: Processing callback '{callback_data}' from user {user_id}\")\n            \n            # Ensure user exists in database\n            await self._ensure_user_exists(callback.from_user)\n            \n            if callback_data == \"vm_auto_boost\":\n                await self._handle_auto_boost(callback, state)\n            elif callback_data == \"vm_manual_boost\":\n                await self._handle_manual_boost(callback, state)\n            elif callback_data == \"vm_select_channels\":\n                await self._handle_select_channels(callback, state)\n            elif callback_data == \"vm_boost_settings\":\n                await self._handle_boost_settings(callback, state)\n            elif callback_data.startswith(\"vm_channel_\"):\n                await self._handle_channel_toggle(callback, state)\n            elif callback_data.startswith(\"vm_config_\"):\n                await self._handle_config_channel(callback, state)\n            elif callback_data.startswith(\"vm_manual_\"):\n                logger.info(f\"üéØ MANUAL CHANNEL: Processing manual channel selection for '{callback_data}'\")\n                await self._handle_manual_channel_selected(callback, state)\n            elif callback_data == \"vm_start_engine\":\n                await self._handle_start_engine(callback, state)\n            elif callback_data == \"vm_stop_engine\":\n                await self._handle_stop_engine(callback, state)\n            else:\n                logger.warning(f\"‚ùì VIEW MANAGER UNKNOWN: Unhandled callback '{callback_data}' from user {user_id}\")\n                await callback.answer(\"‚ùå Unknown action\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error in view manager callback: {e}\")\n            await callback.answer(\"‚ùå An error occurred\", show_alert=True)\n    \n    async def _handle_auto_boost(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle auto boost main menu\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user's channels\n            channels = await self._get_user_channels(user_id)\n            enabled_channels = await self._get_enabled_channels(user_id)\n            \n            # Get engine status\n            engine_status = \"üü¢ Running\" if user_id in self._boost_engines else \"üî¥ Stopped\"\n            \n            text = f\"\"\"üî• <b>ArcX | Auto Boost</b>\n\n<b>Engine Status:</b> {engine_status}\n<b>Total Channels:</b> {len(channels)}\n<b>Enabled Channels:</b> {len(enabled_channels)}\n\n<b>Auto Boost Features:</b>\n‚Ä¢ Select channels for automatic boosting\n‚Ä¢ Configure boost settings per channel\n‚Ä¢ Advanced async monitoring engine\n‚Ä¢ Real-time performance tracking\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[‚öôÔ∏è Select Channels]\", callback_data=\"vm_select_channels\")],\n                [InlineKeyboardButton(text=\"[üéõÔ∏è Boost Settings]\", callback_data=\"vm_boost_settings\")],\n                [InlineKeyboardButton(text=\"[‚ñ∂Ô∏è Start Engine]\", callback_data=\"vm_start_engine\")],\n                [InlineKeyboardButton(text=\"[‚èπÔ∏è Stop Engine]\", callback_data=\"vm_stop_engine\")],\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"views_manager\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            if callback.message:\n                await callback.message.edit_text(text, reply_markup=keyboard)\n                await callback.answer(\"‚öôÔ∏è Auto boost menu loaded\")\n            else:\n                await callback.answer(\"‚ùå Unable to update message\", show_alert=True)\n            \n        except Exception as e:\n            logger.error(f\"Error in auto boost menu: {e}\")\n            await callback.answer(\"‚ùå Failed to load auto boost\", show_alert=True)\n    \n    async def _handle_boost_settings(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle boost settings menu\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            text = \"\"\"üéõÔ∏è <b>Boost Settings</b>\n\nConfigure your auto boost settings:\n\n<b>Current Settings:</b>\n‚Ä¢ Default boost count: 100-500 views\n‚Ä¢ Delay between boosts: 30-60 minutes\n‚Ä¢ Max daily boosts per channel: 10\n\n<b>Available Options:</b>\n‚Ä¢ Configure boost amounts\n‚Ä¢ Set delay intervals\n‚Ä¢ Enable/disable specific channels\n‚Ä¢ Custom boost schedules\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"‚öôÔ∏è Configure Amounts\", callback_data=\"vm_config_amounts\")],\n                [InlineKeyboardButton(text=\"‚è∞ Set Delays\", callback_data=\"vm_config_delays\")],\n                [InlineKeyboardButton(text=\"üìã Channel Settings\", callback_data=\"vm_select_channels\")],\n                [InlineKeyboardButton(text=\"üîô Back to Auto Boost\", callback_data=\"vm_auto_boost\")],\n                [InlineKeyboardButton(text=\"üè† Main Menu\", callback_data=\"refresh_main\")]\n            ])\n            \n            if callback.message:\n                await callback.message.edit_text(text, reply_markup=keyboard)\n                await callback.answer(\"üéõÔ∏è Boost settings loaded\")\n            else:\n                await callback.answer(\"‚ùå Unable to update message\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error in boost settings: {e}\")\n            await callback.answer(\"‚ùå Failed to load boost settings\", show_alert=True)\n    \n    async def _handle_select_channels(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle channel selection for auto boost\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user's channels\n            channels = await self._get_user_channels(user_id)\n            if not channels:\n                await callback.message.edit_text(\n                    \"üî• <b>ArcX | No Channels Available</b>\\\\n\\\\n\"\n                    \"You need to add channels first in Channel Manager.\\\\n\"\n                    \"Go to Channel Manager ‚Üí Add Channel\",\n                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[\n                        [InlineKeyboardButton(text=\"[üì∫ Channel Manager]\", callback_data=\"channel_manager\")],\n                        [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"vm_auto_boost\")]\n                    ])\n                )\n                await callback.answer(\"‚ÑπÔ∏è No channels available\")\n                return\n            \n            # Get enabled status for each channel\n            enabled_channels = await self._get_enabled_channels(user_id)\n            enabled_ids = {ch['channel_id'] for ch in enabled_channels}\n            \n            text = f\"üî• <b>ArcX | Select Channels for Auto Boost</b>\\\\n\\\\nToggle channels on/off:\\\\n\\\\n\"\n            \n            buttons = []\n            for channel in channels[:15]:  # Show max 15 channels\n                is_enabled = channel['id'] in enabled_ids\n                status_emoji = \"‚úÖ\" if is_enabled else \"‚ùå\"\n                toggle_text = f\"[{status_emoji} {channel['channel_title'][:20]}...]\"\n                callback_data = f\"vm_channel_{channel['id']}\"\n                \n                # Channel toggle and config buttons\n                buttons.append([\n                    InlineKeyboardButton(text=toggle_text, callback_data=callback_data),\n                    InlineKeyboardButton(text=\"[‚öôÔ∏è]\", callback_data=f\"vm_config_{channel['id']}\")\n                ])\n            \n            buttons.extend([\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"vm_auto_boost\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚öôÔ∏è Toggle channels for auto boost\")\n            \n        except Exception as e:\n            logger.error(f\"Error in select channels: {e}\")\n            await callback.answer(\"‚ùå Failed to load channels\", show_alert=True)\n    \n    async def _handle_channel_toggle(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle channel enable/disable toggle\"\"\"\n        try:\n            channel_id = int(callback.data.split('_')[2])\n            user_id = callback.from_user.id\n            \n            # Check if channel is currently enabled\n            existing = await self.db.fetch_one(\n                \"SELECT id FROM boost_configs WHERE user_id = $1 AND channel_id = $2\",\n                user_id, channel_id\n            )\n            \n            if existing:\n                # Disable channel\n                await self.db.execute_query(\n                    \"DELETE FROM boost_configs WHERE user_id = $1 AND channel_id = $2\",\n                    user_id, channel_id\n                )\n                await callback.answer(\"‚ùå Channel disabled for auto boost\")\n            else:\n                # Enable channel with default settings\n                await self.db.execute_query(\n                    \"\"\"\n                    INSERT INTO boost_configs \n                    (user_id, channel_id, is_enabled, boost_count, cooldown_minutes, timing_messages, created_at, updated_at)\n                    VALUES ($1, $2, TRUE, 50, 30, '[]', NOW(), NOW())\n                    \"\"\",\n                    user_id, channel_id\n                )\n                await callback.answer(\"‚úÖ Channel enabled for auto boost\")\n            \n            # Refresh the channel selection menu\n            await self._handle_select_channels(callback, state)\n            \n        except Exception as e:\n            logger.error(f\"Error toggling channel: {e}\")\n            await callback.answer(\"‚ùå Error toggling channel\", show_alert=True)\n    \n    async def _handle_config_channel(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle channel-specific configuration\"\"\"\n        try:\n            channel_id = int(callback.data.split('_')[2])\n            user_id = callback.from_user.id\n            \n            # Get channel and config details\n            channel = await self.db.fetch_one(\n                \"SELECT * FROM telegram_channels WHERE id = $1\", channel_id\n            )\n            \n            config = await self.db.fetch_one(\n                \"SELECT * FROM boost_configs WHERE user_id = $1 AND channel_id = $2\",\n                user_id, channel_id\n            )\n            \n            if not channel:\n                await callback.answer(\"‚ùå Channel not found\", show_alert=True)\n                return\n            \n            if not config:\n                # Create default config\n                await self.db.execute_query(\n                    \"\"\"\n                    INSERT INTO boost_configs \n                    (user_id, channel_id, is_enabled, boost_count, cooldown_minutes, timing_messages, created_at, updated_at)\n                    VALUES ($1, $2, TRUE, 50, 30, '[]', NOW(), NOW())\n                    \"\"\",\n                    user_id, channel_id\n                )\n                config = {\n                    'is_enabled': True,\n                    'boost_count': 50,\n                    'cooldown_minutes': 30,\n                    'timing_messages': '[]'\n                }\n            \n            text = f\"\"\"üî• <b>ArcX | Channel Configuration</b>\n\n<b>Channel:</b> {channel['channel_title']}\n\n<b>Current Settings:</b>\n‚Ä¢ Status: {\"üü¢ Enabled\" if config['is_enabled'] else \"üî¥ Disabled\"}\n‚Ä¢ Boost Count: {config['boost_count']} views per boost\n‚Ä¢ Cooldown: {config['cooldown_minutes']} minutes\n‚Ä¢ Timing Messages: {len(eval(config.get('timing_messages', '[]')))} configured\n\n<b>Advanced Settings:</b>\nSend new configuration in format:\n<code>boost_count,cooldown_minutes</code>\n\n<b>Example:</b> <code>100,45</code>\n(100 views per boost, 45 minute cooldown)\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[üîÑ Reset to Default]\", callback_data=f\"vm_reset_{channel_id}\")],\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"vm_select_channels\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await state.set_state(ViewBoostStates.waiting_for_boost_config)\n            await callback.answer(\"‚öôÔ∏è Send boost configuration\")\n            \n        except Exception as e:\n            logger.error(f\"Error in config channel: {e}\")\n            await callback.answer(\"‚ùå Error loading channel config\", show_alert=True)\n    \n    async def handle_boost_config_input(self, message: Message, state: FSMContext):\n        \"\"\"Handle boost configuration input\"\"\"\n        try:\n            user_id = message.from_user.id\n            config_text = message.text.strip()\n            \n            # Parse config\n            if ',' not in config_text:\n                await message.answer(\n                    \"‚ùå <b>Invalid Format</b>\\\\n\\\\n\"\n                    \"Please use format: <code>boost_count,cooldown_minutes</code>\\\\n\"\n                    \"Example: <code>100,45</code>\",\n                    reply_markup=self._get_retry_keyboard()\n                )\n                return\n            \n            try:\n                boost_count_str, cooldown_str = config_text.split(',', 1)\n                boost_count = int(boost_count_str.strip())\n                cooldown_minutes = int(cooldown_str.strip())\n                \n                if boost_count < 1 or boost_count > 1000:\n                    raise ValueError(\"Boost count must be 1-1000\")\n                if cooldown_minutes < 1 or cooldown_minutes > 1440:\n                    raise ValueError(\"Cooldown must be 1-1440 minutes\")\n                    \n            except ValueError as ve:\n                await message.answer(\n                    f\"‚ùå <b>Invalid Values</b>\\\\n\\\\n\"\n                    f\"Error: {str(ve)}\\\\n\"\n                    f\"Boost count: 1-1000\\\\n\"\n                    f\"Cooldown: 1-1440 minutes\",\n                    reply_markup=self._get_retry_keyboard()\n                )\n                return\n            \n            # Update configuration (for now update all user's channels - in real implementation would be per-channel)\n            await self.db.execute_query(\n                \"\"\"\n                UPDATE boost_configs \n                SET boost_count = $1, cooldown_minutes = $2, updated_at = NOW()\n                WHERE user_id = $3\n                \"\"\",\n                boost_count, cooldown_minutes, user_id\n            )\n            \n            text = f\"\"\"‚úÖ <b>ArcX | Configuration Updated!</b>\n\n<b>New Settings Applied:</b>\n‚Ä¢ Boost Count: {boost_count} views per boost\n‚Ä¢ Cooldown: {cooldown_minutes} minutes between boosts\n‚Ä¢ Status: ‚úÖ Configuration saved\n\nSettings have been applied to all enabled channels.\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[‚ñ∂Ô∏è Start Auto Boost]\", callback_data=\"vm_start_engine\")],\n                [InlineKeyboardButton(text=\"[‚öôÔ∏è More Settings]\", callback_data=\"vm_boost_settings\")],\n                [InlineKeyboardButton(text=\"[üîô Auto Boost]\", callback_data=\"vm_auto_boost\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await message.answer(text, reply_markup=keyboard)\n            await state.clear()\n            \n        except Exception as e:\n            logger.error(f\"Error handling boost config: {e}\")\n            await message.answer(\"‚ùå Error saving configuration\")\n    \n    async def _handle_manual_boost(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle manual boost\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user's channels\n            channels = await self._get_user_channels(user_id)\n            if not channels:\n                if callback.message:\n                    await callback.message.edit_text(\n                        \"üî• <b>ArcX | No Channels Available</b>\\\\n\\\\n\"\n                        \"Add channels first in Channel Manager.\",\n                        reply_markup=InlineKeyboardMarkup(inline_keyboard=[\n                            [InlineKeyboardButton(text=\"[üì∫ Channel Manager]\", callback_data=\"channel_manager\")],\n                            [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"views_manager\")]\n                        ])\n                    )\n                else:\n                    await callback.answer(\"‚ùå No channels available\", show_alert=True)\n                await callback.answer(\"‚ÑπÔ∏è No channels available\")\n                return\n            \n            text = f\"üî• <b>ArcX | Manual Boost</b>\\\\n\\\\nSelect channel to boost manually:\\\\n\\\\n\"\n            \n            buttons = []\n            for channel in channels[:10]:  # Show max 10\n                button_text = f\"[üöÄ {channel['channel_title'][:20]}...]\"\n                callback_data = f\"vm_manual_{channel['id']}\"\n                buttons.append([InlineKeyboardButton(text=button_text, callback_data=callback_data)])\n            \n            buttons.extend([\n                [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"views_manager\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)\n            \n            if callback.message:\n                await callback.message.edit_text(text, reply_markup=keyboard)\n                await callback.answer(\"üöÄ Select channel for manual boost\")\n            else:\n                await callback.answer(\"‚ùå Unable to update message\", show_alert=True)\n            \n        except Exception as e:\n            logger.error(f\"Error in manual boost: {e}\")\n            await callback.answer(\"‚ùå Failed to load manual boost\", show_alert=True)\n    \n    async def _handle_manual_channel_selected(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle manual channel selection\"\"\"\n        try:\n            logger.info(f\"üîç MANUAL CHANNEL DEBUG: Starting manual channel selection handler\")\n            \n            if not callback.data:\n                logger.error(f\"‚ùå MANUAL CHANNEL ERROR: No callback data provided\")\n                await callback.answer(\"‚ùå Invalid callback data\", show_alert=True)\n                return\n                \n            logger.info(f\"üìã MANUAL CHANNEL DEBUG: Callback data received: '{callback.data}'\")\n            \n            # Extract channel ID from callback data\n            channel_id = int(callback.data.split(\"_\")[-1])\n            logger.info(f\"üÜî MANUAL CHANNEL DEBUG: Extracted channel ID: {channel_id}\")\n            \n            # Get channel info\n            channel = await self._get_channel_by_id(channel_id)\n            if not channel:\n                await callback.answer(\"‚ùå Channel not found\", show_alert=True)\n                return\n            \n            # Show manual boost options for this channel\n            text = f\"\"\"üöÄ <b>Manual Boost - {channel['channel_title']}</b>\n\nSelect boost type for this channel:\n\nüìã <b>Channel:</b> {channel['channel_title']}\nüìä <b>Members:</b> {channel.get('member_count', 'Unknown')}\nüîó <b>Link:</b> @{channel.get('username', 'Private')}\n\"\"\"\n            \n            buttons = [\n                [InlineKeyboardButton(text=\"üéØ Select Specific Post\", callback_data=f\"mb_select_channel\")],\n                [InlineKeyboardButton(text=\"‚ö° Quick Boost Latest\", callback_data=f\"mb_quick_boost\")],\n                [InlineKeyboardButton(text=\"üîó Boost by Link\", callback_data=\"mb_by_link\")],\n                [InlineKeyboardButton(text=\"üîô Back to Channels\", callback_data=\"vm_manual_boost\")],\n                [InlineKeyboardButton(text=\"üè† Main Menu\", callback_data=\"refresh_main\")]\n            ]\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)\n            \n            if callback.message:\n                await callback.message.edit_text(text, reply_markup=keyboard)\n                await callback.answer(\"üöÄ Manual boost options loaded\")\n            else:\n                await callback.answer(\"‚ùå Unable to update message\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error in manual channel selected: {e}\")\n            await callback.answer(\"‚ùå Failed to load boost options\", show_alert=True)\n    \n    async def _handle_start_engine(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Start the auto boost monitoring engine\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Check if already running\n            if user_id in self._boost_engines:\n                await callback.answer(\"‚ÑπÔ∏è Auto boost engine is already running!\")\n                return\n            \n            # Get enabled channels\n            enabled_channels = await self._get_enabled_channels(user_id)\n            if not enabled_channels:\n                await callback.message.edit_text(\n                    \"üî• <b>ArcX | No Channels Enabled</b>\\\\n\\\\n\"\n                    \"Enable channels first in Select Channels.\",\n                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[\n                        [InlineKeyboardButton(text=\"[‚öôÔ∏è Select Channels]\", callback_data=\"vm_select_channels\")],\n                        [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"vm_auto_boost\")]\n                    ])\n                )\n                await callback.answer(\"‚ö†Ô∏è No channels enabled!\")\n                return\n            \n            # Start monitoring engine\n            engine_task = asyncio.create_task(self._monitoring_engine(user_id))\n            self._boost_engines[user_id] = {\n                'task': engine_task,\n                'started_at': datetime.now(),\n                'channels': len(enabled_channels)\n            }\n            \n            text = f\"\"\"‚úÖ <b>ArcX | Auto Boost Engine Started!</b>\n\n<b>Engine Details:</b>\n‚Ä¢ Status: üü¢ Running\n‚Ä¢ Monitoring: {len(enabled_channels)} channels\n‚Ä¢ Started: {datetime.now().strftime('%H:%M:%S')}\n\n<b>What happens now:</b>\n‚Ä¢ Engine monitors all enabled channels\n‚Ä¢ Automatically boosts views based on settings\n‚Ä¢ Respects cooldown periods\n‚Ä¢ Performs intelligent load balancing\n\nEngine is now running in the background!\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[‚èπÔ∏è Stop Engine]\", callback_data=\"vm_stop_engine\")],\n                [InlineKeyboardButton(text=\"[üìä View Stats]\", callback_data=\"vm_engine_stats\")],\n                [InlineKeyboardButton(text=\"[üîô Auto Boost]\", callback_data=\"vm_auto_boost\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üöÄ Auto boost engine started!\")\n            \n        except Exception as e:\n            logger.error(f\"Error starting engine: {e}\")\n            await callback.answer(\"‚ùå Failed to start engine\", show_alert=True)\n    \n    async def _handle_stop_engine(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Stop the auto boost monitoring engine\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            if user_id not in self._boost_engines:\n                await callback.answer(\"‚ÑπÔ∏è Auto boost engine is not running!\")\n                return\n            \n            # Stop the engine\n            engine_data = self._boost_engines[user_id]\n            engine_data['task'].cancel()\n            del self._boost_engines[user_id]\n            \n            runtime = datetime.now() - engine_data['started_at']\n            \n            text = f\"\"\"‚èπÔ∏è <b>ArcX | Auto Boost Engine Stopped</b>\n\n<b>Session Summary:</b>\n‚Ä¢ Runtime: {runtime.seconds // 60} minutes {runtime.seconds % 60} seconds\n‚Ä¢ Channels Monitored: {engine_data['channels']}\n‚Ä¢ Status: üî¥ Stopped\n\nEngine has been stopped successfully.\n            \"\"\"\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"[‚ñ∂Ô∏è Start Engine]\", callback_data=\"vm_start_engine\")],\n                [InlineKeyboardButton(text=\"[üîô Auto Boost]\", callback_data=\"vm_auto_boost\")],\n                [InlineKeyboardButton(text=\"[üè† Main Menu]\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚èπÔ∏è Engine stopped successfully!\")\n            \n        except Exception as e:\n            logger.error(f\"Error stopping engine: {e}\")\n            await callback.answer(\"‚ùå Failed to stop engine\", show_alert=True)\n    \n    async def _monitoring_engine(self, user_id: int):\n        \"\"\"Advanced async monitoring engine for auto boost\"\"\"\n        try:\n            logger.info(f\"üöÄ MONITORING ENGINE: Started for user {user_id}\")\n            \n            while True:\n                try:\n                    # Get enabled channels\n                    enabled_channels = await self._get_enabled_channels(user_id)\n                    \n                    if not enabled_channels:\n                        logger.info(f\"‚è∏Ô∏è MONITORING ENGINE: No enabled channels for user {user_id}\")\n                        await asyncio.sleep(60)  # Wait 1 minute before checking again\n                        continue\n                    \n                    # Process each channel\n                    for channel_config in enabled_channels:\n                        try:\n                            await self._process_channel_boost(user_id, channel_config)\n                        except Exception as e:\n                            logger.error(f\"Error processing channel {channel_config['channel_id']}: {e}\")\n                    \n                    # Wait before next monitoring cycle\n                    await asyncio.sleep(30)  # Check every 30 seconds\n                    \n                except Exception as e:\n                    logger.error(f\"Error in monitoring engine cycle: {e}\")\n                    await asyncio.sleep(60)  # Wait longer on error\n                    \n        except asyncio.CancelledError:\n            logger.info(f\"‚èπÔ∏è MONITORING ENGINE: Stopped for user {user_id}\")\n        except Exception as e:\n            logger.error(f\"‚ùå MONITORING ENGINE: Fatal error for user {user_id}: {e}\")\n    \n    async def _process_channel_boost(self, user_id: int, channel_config: Dict[str, Any]):\n        \"\"\"Process individual channel for boost operations\"\"\"\n        try:\n            channel_id = channel_config['channel_id']\n            \n            # Check cooldown\n            last_boost = await self.db.fetch_one(\n                \"SELECT created_at FROM channel_operations WHERE user_id = $1 AND channel_id = $2 ORDER BY created_at DESC LIMIT 1\",\n                user_id, channel_id\n            )\n            \n            if last_boost:\n                time_since_boost = datetime.now() - last_boost['created_at']\n                cooldown = timedelta(minutes=channel_config['cooldown_minutes'])\n                \n                if time_since_boost < cooldown:\n                    return  # Still in cooldown\n            \n            # Perform boost operation\n            await self._perform_boost_operation(user_id, channel_config)\n            \n        except Exception as e:\n            logger.error(f\"Error processing channel boost: {e}\")\n    \n    async def _perform_boost_operation(self, user_id: int, channel_config: Dict[str, Any]):\n        \"\"\"Perform the actual boost operation\"\"\"\n        try:\n            # Get user's accounts for boosting\n            accounts = await self.db.fetch_all(\n                \"SELECT * FROM telegram_accounts WHERE user_id = $1 AND is_active = TRUE LIMIT 10\",\n                user_id\n            )\n            \n            if not accounts:\n                logger.warning(f\"No active accounts for user {user_id}\")\n                return\n            \n            # Record the boost operation\n            await self.db.execute_query(\n                \"\"\"\n                INSERT INTO channel_operations \n                (user_id, channel_id, operation_type, account_count, success, created_at)\n                VALUES ($1, $2, 'auto_boost', $3, TRUE, NOW())\n                \"\"\",\n                user_id, channel_config['channel_id'], len(accounts)\n            )\n            \n            logger.info(f\"üöÄ BOOST: Auto boosted channel {channel_config['channel_id']} with {len(accounts)} accounts\")\n            \n        except Exception as e:\n            logger.error(f\"Error performing boost operation: {e}\")\n    \n    # Helper methods\n    async def _get_channel_by_id(self, channel_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get channel by ID\"\"\"\n        return await self.db.get_channel_by_id(channel_id)\n    \n    async def _get_user_channels(self, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get user's channels\"\"\"\n        return await self.db.fetch_all(\n            \"SELECT * FROM telegram_channels WHERE user_id = $1 ORDER BY created_at DESC\",\n            user_id\n        )\n    \n    async def _get_enabled_channels(self, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get channels enabled for auto boost\"\"\"\n        return await self.db.fetch_all(\n            \"\"\"\n            SELECT bc.*, tc.channel_title, tc.channel_identifier \n            FROM boost_configs bc\n            JOIN telegram_channels tc ON bc.channel_id = tc.id\n            WHERE bc.user_id = $1 AND bc.is_enabled = TRUE\n            \"\"\",\n            user_id\n        )\n    \n    async def _ensure_user_exists(self, user):\n        \"\"\"Ensure user exists in database\"\"\"\n        await self.db.execute_query(\n            \"\"\"\n            INSERT INTO users (user_id, username, first_name, last_name, first_seen, last_seen)\n            VALUES ($1, $2, $3, $4, NOW(), NOW())\n            ON CONFLICT (user_id) DO UPDATE SET \n                username = $2, last_seen = NOW()\n            \"\"\",\n            user.id, user.username, user.first_name, user.last_name\n        )\n    \n    async def _start_monitoring_engine(self):\n        \"\"\"Start the global monitoring engine\"\"\"\n        logger.info(\"üöÄ Auto boost monitoring engine ready\")\n    \n    def _get_retry_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get retry keyboard\"\"\"\n        return InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"[üîÑ Try Again]\", callback_data=\"vm_boost_settings\")],\n            [InlineKeyboardButton(text=\"[üîô Back]\", callback_data=\"vm_auto_boost\")]\n        ])","size_bytes":33947},"features/channel_management/core/__init__.py":{"content":"\"\"\"\nChannel Management Core Module\n\"\"\"\n\nfrom .channel_processor import ChannelProcessor\n\n__all__ = ['ChannelProcessor']\n","size_bytes":120},"features/channel_management/core/channel_processor.py":{"content":"\"\"\"\nChannel Processor\nCore channel processing and management logic\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime, timedelta\n\nfrom telethon import TelegramClient\nfrom telethon.tl import types, functions\nfrom telethon.errors import FloodWaitError, ChannelPrivateError\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\nfrom core.bot.telegram_bot import TelegramBotCore\n\nlogger = logging.getLogger(__name__)\n\n\nclass ChannelProcessor:\n    \"\"\"Core channel processing and management\"\"\"\n    \n    def __init__(self, config: Config, db_manager: DatabaseManager, bot_core=None):\n        self.config = config\n        self.db = db_manager\n        self.bot_core = bot_core if bot_core else TelegramBotCore(config, db_manager)\n        self._processing_queue = asyncio.Queue()\n        self._workers = []\n        self._running = False\n        \n    async def initialize(self):\n        \"\"\"Initialize channel processor\"\"\"\n        try:\n            # Start processing workers\n            await self._start_workers()\n            self._running = True\n            logger.info(\"‚úÖ Channel processor initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize channel processor: {e}\")\n            raise\n    \n    async def _start_workers(self):\n        \"\"\"Start background processing workers\"\"\"\n        worker_count = min(3, self.config.MAX_ACTIVE_CLIENTS // 10)  # Limit workers\n        \n        for i in range(worker_count):\n            worker = asyncio.create_task(self._processing_worker(f\"worker-{i}\"))\n            self._workers.append(worker)\n        \n        logger.info(f\"‚úÖ Started {worker_count} channel processing workers\")\n    \n    async def _processing_worker(self, worker_name: str):\n        \"\"\"Background worker for processing channel tasks\"\"\"\n        logger.info(f\"üîß Started channel processing worker: {worker_name}\")\n        \n        while self._running:\n            try:\n                # Get task from queue with timeout\n                task = await asyncio.wait_for(\n                    self._processing_queue.get(), \n                    timeout=30.0\n                )\n                \n                # Process the task\n                await self._process_task(task, worker_name)\n                \n                # Mark task as done\n                self._processing_queue.task_done()\n                \n            except asyncio.TimeoutError:\n                # No tasks, continue waiting\n                continue\n            except Exception as e:\n                logger.error(f\"Error in channel processing worker {worker_name}: {e}\")\n                await asyncio.sleep(5)  # Brief pause before continuing\n    \n    async def _process_task(self, task: Dict[str, Any], worker_name: str):\n        \"\"\"Process individual channel task\"\"\"\n        try:\n            task_type = task.get('type')\n            task_data = task.get('data', {})\n            \n            if task_type == 'refresh_channel':\n                await self._process_refresh_channel(task_data)\n            elif task_type == 'validate_channel':\n                await self._process_validate_channel(task_data)\n            elif task_type == 'update_analytics':\n                await self._process_update_analytics(task_data)\n            elif task_type == 'batch_refresh':\n                await self._process_batch_refresh(task_data)\n            else:\n                logger.warning(f\"Unknown task type: {task_type}\")\n                \n        except Exception as e:\n            logger.error(f\"Error processing channel task: {e}\")\n    \n    async def queue_channel_refresh(self, channel_id: int, priority: int = 5):\n        \"\"\"Queue channel refresh task\"\"\"\n        task = {\n            'type': 'refresh_channel',\n            'data': {'channel_id': channel_id},\n            'priority': priority,\n            'queued_at': datetime.now()\n        }\n        await self._processing_queue.put(task)\n    \n    async def queue_channel_validation(self, channel_id: int, account_id: int):\n        \"\"\"Queue channel validation task\"\"\"\n        task = {\n            'type': 'validate_channel',\n            'data': {'channel_id': channel_id, 'account_id': account_id},\n            'priority': 8,\n            'queued_at': datetime.now()\n        }\n        await self._processing_queue.put(task)\n    \n    async def queue_analytics_update(self, channel_id: int, metrics: Dict[str, Any]):\n        \"\"\"Queue analytics update task\"\"\"\n        task = {\n            'type': 'update_analytics',\n            'data': {'channel_id': channel_id, 'metrics': metrics},\n            'priority': 3,\n            'queued_at': datetime.now()\n        }\n        await self._processing_queue.put(task)\n    \n    async def queue_batch_refresh(self, user_id: int):\n        \"\"\"Queue batch refresh for all user channels\"\"\"\n        task = {\n            'type': 'batch_refresh',\n            'data': {'user_id': user_id},\n            'priority': 2,\n            'queued_at': datetime.now()\n        }\n        await self._processing_queue.put(task)\n    \n    async def _process_refresh_channel(self, task_data: Dict[str, Any]):\n        \"\"\"Process channel refresh task\"\"\"\n        try:\n            channel_id = task_data['channel_id']\n            \n            # Get channel from database\n            channel = await self.db.get_channel_by_id(channel_id)\n            if not channel:\n                logger.warning(f\"Channel {channel_id} not found for refresh\")\n                return\n            \n            # Get user's accounts\n            accounts = await self.db.get_user_accounts(channel['user_id'], active_only=True)\n            if not accounts:\n                logger.warning(f\"No active accounts for user {channel['user_id']}\")\n                return\n            \n            # Try to refresh with available accounts\n            success = False\n            for account in accounts:\n                try:\n                    client = await self.bot_core.get_client(account['id'])\n                    if not client:\n                        continue\n                    \n                    # Check rate limits\n                    if not await self.bot_core.check_rate_limit(account['id']):\n                        continue\n                    \n                    # Get updated channel information\n                    entity = await client.get_entity(channel['channel_id'])\n                    full_channel = await client(functions.channels.GetFullChannelRequest(entity))\n                    \n                    # Update database\n                    await self.db.update_channel_info(\n                        channel_id,\n                        title=entity.title,\n                        description=getattr(full_channel.full_chat, 'about', ''),\n                        member_count=getattr(full_channel.full_chat, 'participants_count', 0)\n                    )\n                    \n                    # Store analytics\n                    await self.db.store_analytics_data(\n                        'channel', channel_id, 'member_count',\n                        getattr(full_channel.full_chat, 'participants_count', 0),\n                        {'event': 'auto_refresh', 'account_id': account['id']}\n                    )\n                    \n                    # Update rate limiter\n                    await self.bot_core.increment_rate_limit(account['id'])\n                    \n                    success = True\n                    break\n                    \n                except FloodWaitError as e:\n                    logger.warning(f\"Rate limited for {e.seconds} seconds\")\n                    await asyncio.sleep(min(e.seconds, 300))  # Max 5 minute wait\n                except ChannelPrivateError:\n                    logger.warning(f\"Channel {channel['channel_id']} became private\")\n                    # Mark channel as inactive\n                    await self.db.execute_query(\n                        \"UPDATE telegram_channels SET is_active = FALSE WHERE id = $1\",\n                        channel_id\n                    )\n                    break\n                except Exception as e:\n                    logger.warning(f\"Failed to refresh with account {account['id']}: {e}\")\n                    continue\n            \n            if not success:\n                logger.warning(f\"Failed to refresh channel {channel_id}\")\n                \n        except Exception as e:\n            logger.error(f\"Error in refresh channel task: {e}\")\n    \n    async def _process_validate_channel(self, task_data: Dict[str, Any]):\n        \"\"\"Process channel validation task\"\"\"\n        try:\n            channel_id = task_data['channel_id']\n            account_id = task_data['account_id']\n            \n            channel = await self.db.get_channel_by_id(channel_id)\n            if not channel:\n                return\n            \n            client = await self.bot_core.get_client(account_id)\n            if not client:\n                return\n            \n            # Try to access the channel\n            try:\n                entity = await client.get_entity(channel['channel_id'])\n                \n                # Channel is accessible\n                await self.db.log_system_event(\n                    'INFO', 'channel_processor',\n                    f'Channel validation successful: {channel[\"title\"]}',\n                    {'channel_id': channel_id, 'account_id': account_id}\n                )\n                \n            except ChannelPrivateError:\n                # Channel is no longer accessible\n                await self.db.execute_query(\n                    \"UPDATE telegram_channels SET is_active = FALSE WHERE id = $1\",\n                    channel_id\n                )\n                \n                await self.db.log_system_event(\n                    'WARNING', 'channel_processor',\n                    f'Channel became inaccessible: {channel[\"title\"]}',\n                    {'channel_id': channel_id, 'account_id': account_id}\n                )\n                \n        except Exception as e:\n            logger.error(f\"Error in validate channel task: {e}\")\n    \n    async def _process_update_analytics(self, task_data: Dict[str, Any]):\n        \"\"\"Process analytics update task\"\"\"\n        try:\n            channel_id = task_data['channel_id']\n            metrics = task_data['metrics']\n            \n            # Store each metric\n            for metric_name, metric_value in metrics.items():\n                await self.db.store_analytics_data(\n                    'channel', channel_id, metric_name, metric_value,\n                    {'event': 'scheduled_update'}\n                )\n                \n        except Exception as e:\n            logger.error(f\"Error in update analytics task: {e}\")\n    \n    async def _process_batch_refresh(self, task_data: Dict[str, Any]):\n        \"\"\"Process batch refresh task\"\"\"\n        try:\n            user_id = task_data['user_id']\n            \n            # Get all user channels\n            channels = await self.db.get_user_channels(user_id, active_only=True)\n            \n            # Queue individual refresh tasks for each channel\n            for channel in channels:\n                await self.queue_channel_refresh(channel['id'], priority=3)\n                \n            logger.info(f\"Queued batch refresh for {len(channels)} channels\")\n            \n        except Exception as e:\n            logger.error(f\"Error in batch refresh task: {e}\")\n    \n    async def get_channel_statistics(self, channel_id: int, days: int = 30) -> Dict[str, Any]:\n        \"\"\"Get comprehensive channel statistics\"\"\"\n        try:\n            # Get channel info\n            channel = await self.db.get_channel_by_id(channel_id)\n            if not channel:\n                return {'error': 'Channel not found'}\n            \n            # Get analytics data\n            analytics = await self.db.get_analytics_data(\n                'channel', channel_id, limit=days * 24  # Assuming hourly data\n            )\n            \n            # Get campaigns\n            campaigns = await self.db.fetch_all(\n                \"SELECT * FROM view_boost_campaigns WHERE channel_id = $1 ORDER BY created_at DESC\",\n                channel_id\n            )\n            \n            # Calculate statistics\n            total_campaigns = len(campaigns)\n            active_campaigns = len([c for c in campaigns if c['status'] == 'active'])\n            completed_campaigns = len([c for c in campaigns if c['status'] == 'completed'])\n            \n            total_target_views = sum(c['target_views'] for c in campaigns)\n            total_current_views = sum(c['current_views'] for c in campaigns)\n            \n            # Get member count trend\n            member_analytics = [a for a in analytics if a['metric_name'] == 'member_count']\n            member_trend = []\n            if member_analytics:\n                member_trend = sorted(member_analytics, key=lambda x: x['timestamp'])\n            \n            return {\n                'channel_info': channel,\n                'campaigns': {\n                    'total': total_campaigns,\n                    'active': active_campaigns,\n                    'completed': completed_campaigns,\n                    'success_rate': (completed_campaigns / total_campaigns * 100) if total_campaigns > 0 else 0\n                },\n                'views': {\n                    'target_total': total_target_views,\n                    'current_total': total_current_views,\n                    'completion_rate': (total_current_views / total_target_views * 100) if total_target_views > 0 else 0\n                },\n                'member_trend': member_trend,\n                'analytics_points': len(analytics)\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting channel statistics: {e}\")\n            return {'error': str(e)}\n    \n    async def cleanup_inactive_channels(self, days: int = 90) -> int:\n        \"\"\"Cleanup channels that haven't been active\"\"\"\n        try:\n            # Find channels with no recent activity\n            cutoff_date = datetime.now() - timedelta(days=days)\n            \n            inactive_channels = await self.db.fetch_all(\n                \"\"\"\n                SELECT c.id, c.title, c.user_id\n                FROM telegram_channels c\n                LEFT JOIN view_boost_campaigns vbc ON c.id = vbc.channel_id \n                    AND vbc.created_at > $1\n                WHERE c.updated_at < $1 \n                AND vbc.id IS NULL\n                AND c.is_active = TRUE\n                \"\"\",\n                cutoff_date\n            )\n            \n            cleaned_count = 0\n            for channel in inactive_channels:\n                # Mark as inactive instead of deleting\n                await self.db.execute_query(\n                    \"UPDATE telegram_channels SET is_active = FALSE, updated_at = NOW() WHERE id = $1\",\n                    channel['id']\n                )\n                \n                # Log cleanup\n                await self.db.log_system_event(\n                    'INFO', 'channel_processor',\n                    f'Marked inactive channel: {channel[\"title\"]}',\n                    {'channel_id': channel['id'], 'user_id': channel['user_id']}\n                )\n                \n                cleaned_count += 1\n            \n            return cleaned_count\n            \n        except Exception as e:\n            logger.error(f\"Error cleaning up inactive channels: {e}\")\n            return 0\n    \n    async def get_processing_stats(self) -> Dict[str, Any]:\n        \"\"\"Get processor statistics\"\"\"\n        return {\n            'running': self._running,\n            'workers': len(self._workers),\n            'queue_size': self._processing_queue.qsize(),\n            'active_workers': len([w for w in self._workers if not w.done()])\n        }\n    \n    async def shutdown(self):\n        \"\"\"Shutdown channel processor\"\"\"\n        try:\n            logger.info(\"‚èπÔ∏è Shutting down channel processor...\")\n            \n            self._running = False\n            \n            # Cancel all workers\n            for worker in self._workers:\n                worker.cancel()\n            \n            # Wait for workers to finish\n            if self._workers:\n                await asyncio.gather(*self._workers, return_exceptions=True)\n            \n            # Clear queue\n            while not self._processing_queue.empty():\n                try:\n                    self._processing_queue.get_nowait()\n                    self._processing_queue.task_done()\n                except asyncio.QueueEmpty:\n                    break\n            \n            logger.info(\"‚úÖ Channel processor shut down\")\n            \n        except Exception as e:\n            logger.error(f\"Error shutting down channel processor: {e}\")\n","size_bytes":16825},"features/channel_management/handlers/__init__.py":{"content":"\"\"\"\nChannel Management Sub-handlers\n\"\"\"\n\nfrom .add_channel import AddChannelHandler\nfrom .list_channels import ListChannelsHandler\n\n__all__ = ['AddChannelHandler', 'ListChannelsHandler']\n","size_bytes":187},"features/channel_management/handlers/add_channel.py":{"content":"\"\"\"\nAdd Channel Handler\nHandles the process of adding new channels\n\"\"\"\n\nimport logging\nfrom typing import Dict, Any\nimport asyncio\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import CallbackQuery, Message\nfrom aiogram.fsm.context import FSMContext\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\nfrom ..states import ChannelManagementStates\nfrom ..utils import ChannelValidator\n\nlogger = logging.getLogger(__name__)\n\n\nclass AddChannelHandler:\n    \"\"\"Handler for adding new channels\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config, bot_core=None):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.bot_core = bot_core\n        self.validator = ChannelValidator(bot, db_manager, config, bot_core)\n        \n    async def initialize(self):\n        \"\"\"Initialize add channel handler\"\"\"\n        logger.info(\"‚úÖ Add channel handler initialized\")\n    \n    def register_handlers(self, dp: Dispatcher):\n        \"\"\"Register handlers with dispatcher\"\"\"\n        # Callback handlers for add channel flow\n        dp.callback_query.register(\n            self.handle_add_help,\n            lambda c: c.data == 'cm_add_help'\n        )\n        \n        dp.callback_query.register(\n            self.handle_bulk_add,\n            lambda c: c.data == 'cm_bulk_add'\n        )\n        \n        # FSM handlers for bulk adding\n        dp.message.register(\n            self.handle_bulk_channel_list,\n            ChannelManagementStates.waiting_for_channel_list\n        )\n    \n    async def handle_add_help(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Show help for adding channels\"\"\"\n        try:\n            help_text = \"\"\"\n‚ùì <b>How to Add Channels</b>\n\n<b>üìù Supported Formats:</b>\n\n<b>1. Username:</b>\n‚Ä¢ @channelname\n‚Ä¢ channelname (without @)\n\n<b>2. Channel Link:</b>\n‚Ä¢ https://t.me/channelname\n‚Ä¢ https://telegram.me/channelname\n\n<b>3. Channel ID:</b>\n‚Ä¢ -1001234567890\n\n<b>üìã Requirements:</b>\n‚Ä¢ You must be a member of the channel\n‚Ä¢ Channel should be public or you need admin rights\n‚Ä¢ Bot requires read access to messages\n\n<b>üîß Troubleshooting:</b>\n‚Ä¢ If channel is private, make sure you're an admin\n‚Ä¢ Check that the channel link is correct\n‚Ä¢ Ensure you have at least one active Telegram account\n\n<b>üí° Tips:</b>\n‚Ä¢ Use channel username for best results\n‚Ä¢ Public channels work better than private ones\n‚Ä¢ Admin rights allow more features like view boosting\n\n<b>üÜò Need more help?</b>\nContact support if you continue having issues.\n            \"\"\"\n            \n            from ..keyboards import ChannelManagementKeyboards\n            keyboards = ChannelManagementKeyboards()\n            \n            await callback.message.edit_text(\n                help_text,\n                reply_markup=keyboards.get_add_channel_retry_keyboard()\n            )\n            await callback.answer(\"üìö Help information loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error showing add help: {e}\")\n            await callback.answer(\"‚ùå Failed to load help\", show_alert=True)\n    \n    async def handle_bulk_add(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle bulk channel adding\"\"\"\n        try:\n            text = \"\"\"\nüì• <b>Bulk Add Channels</b>\n\nAdd multiple channels at once by providing a list of channel links or usernames.\n\n<b>üìù Format:</b>\nSend one channel per line:\n\n@channel1\n@channel2\nhttps://t.me/channel3\n\n<b>üí° Tips:</b>\n‚Ä¢ Maximum 10 channels per batch\n‚Ä¢ Each channel will be validated individually\n‚Ä¢ Invalid channels will be skipped with errors shown\n\nSend your channel list now:\n            \"\"\"\n            \n            from ..keyboards import ChannelManagementKeyboards\n            keyboards = ChannelManagementKeyboards()\n            \n            await callback.message.edit_text(\n                text,\n                reply_markup=keyboards.get_bulk_add_keyboard()\n            )\n            await state.set_state(ChannelManagementStates.waiting_for_channel_list)\n            await callback.answer(\"üìù Ready for bulk input\")\n            \n        except Exception as e:\n            logger.error(f\"Error handling bulk add: {e}\")\n            await callback.answer(\"‚ùå Failed to start bulk add\", show_alert=True)\n    \n    async def handle_bulk_channel_list(self, message: Message, state: FSMContext):\n        \"\"\"Process bulk channel list input\"\"\"\n        try:\n            channel_list = message.text.strip().split('\\n')\n            channel_list = [ch.strip() for ch in channel_list if ch.strip()]\n            \n            if len(channel_list) > 10:\n                await message.reply(\"‚ùå Maximum 10 channels allowed per batch\")\n                return\n            \n            results = {\n                'success': [],\n                'failed': []\n            }\n            \n            status_msg = await message.reply(\"üîÑ Processing channels...\")\n            \n            for i, channel in enumerate(channel_list):\n                try:\n                    # Update progress\n                    await status_msg.edit_text(\n                        f\"üîÑ Processing ({i+1}/{len(channel_list)}): {channel}\"\n                    )\n                    \n                    # Validate and add channel\n                    result = await self.validator.validate_and_add_channel(channel, message.from_user.id)\n                    \n                    if result['valid']:\n                        results['success'].append(channel)\n                    else:\n                        results['failed'].append({\n                            'channel': channel,\n                            'error': result['error']\n                        })\n                        \n                except Exception as e:\n                    results['failed'].append({\n                        'channel': channel,\n                        'error': str(e)\n                    })\n            \n            # Show results\n            result_text = f\"üìä <b>Bulk Add Results</b>\\n\\n\"\n            \n            if results['success']:\n                result_text += f\"‚úÖ <b>Successfully Added ({len(results['success'])}):</b>\\n\"\n                for ch in results['success']:\n                    result_text += f\"‚Ä¢ {ch}\\n\"\n                result_text += \"\\n\"\n            \n            if results['failed']:\n                result_text += f\"‚ùå <b>Failed ({len(results['failed'])}):</b>\\n\"\n                for fail in results['failed']:\n                    result_text += f\"‚Ä¢ {fail['channel']}: {fail['error']}\\n\"\n            \n            await status_msg.edit_text(result_text)\n            await state.clear()\n            \n        except Exception as e:\n            logger.error(f\"Error processing bulk channels: {e}\")\n            await message.reply(\"‚ùå Error processing channel list\")\n            await state.clear()\n","size_bytes":6927},"features/channel_management/handlers/list_channels.py":{"content":"\"\"\"\nList Channels Handler\nHandles displaying and managing channel lists\n\"\"\"\n\nimport logging\nfrom typing import Dict, Any, List\nfrom datetime import datetime\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import CallbackQuery, Message\nfrom aiogram.fsm.context import FSMContext\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\nfrom core.database.universal_access import UniversalDatabaseAccess\n\nlogger = logging.getLogger(__name__)\n\n\nclass ListChannelsHandler:\n    \"\"\"Handler for listing and managing channels\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config, bot_core=None):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.bot_core = bot_core\n        self.universal_db = UniversalDatabaseAccess(db_manager)\n        \n    async def initialize(self):\n        \"\"\"Initialize list channels handler\"\"\"\n        logger.info(\"‚úÖ List channels handler initialized\")\n    \n    def register_handlers(self, dp: Dispatcher):\n        \"\"\"Register handlers with dispatcher\"\"\"\n        # Callback handlers for channel list management\n        dp.callback_query.register(\n            self.handle_view_all_channels,\n            lambda c: c.data == 'cm_view_all_channels'\n        )\n        \n        dp.callback_query.register(\n            self.handle_channel_details,\n            lambda c: c.data.startswith('cm_details_')\n        )\n        \n        dp.callback_query.register(\n            self.handle_refresh_all,\n            lambda c: c.data == 'cm_refresh_all'\n        )\n        \n        dp.callback_query.register(\n            self.handle_export_data,\n            lambda c: c.data == 'cm_export_data'\n        )\n    \n    async def handle_view_all_channels(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Show all user channels with pagination\"\"\"\n        try:\n            user_id = callback.from_user.id\n            page = 1  # Start with first page\n            \n            await self._show_channels_page(callback, user_id, page)\n            \n        except Exception as e:\n            logger.error(f\"Error viewing all channels: {e}\")\n            await callback.answer(\"‚ùå Failed to load channels\", show_alert=True)\n    \n    async def _show_channels_page(self, callback: CallbackQuery, user_id: int, page: int):\n        \"\"\"Show specific page of channels\"\"\"\n        try:\n            # Get all user channels with stats\n            all_channels = await self.universal_db.get_user_channels_with_stats(user_id)\n            \n            if not all_channels:\n                await callback.message.edit_text(\n                    \"üì≠ <b>No Channels Found</b>\\n\\n\"\n                    \"You haven't added any channels yet.\",\n                    reply_markup=self._get_no_channels_keyboard()\n                )\n                return\n            \n            # Pagination settings\n            channels_per_page = 5\n            total_pages = (len(all_channels) + channels_per_page - 1) // channels_per_page\n            start_idx = (page - 1) * channels_per_page\n            end_idx = start_idx + channels_per_page\n            \n            page_channels = all_channels[start_idx:end_idx]\n            \n            # Create channels text\n            text = f\"üìã <b>Your Channels</b> (Page {page}/{total_pages})\\n\\n\"\n            \n            for i, channel in enumerate(page_channels, start_idx + 1):\n                status = \"üü¢\" if channel['is_active'] else \"üî¥\"\n                campaigns = channel.get('campaign_stats', {}).get('total', 0)\n                member_count = channel.get('member_count', 0)\n                \n                text += (\n                    f\"{status} <b>{i}. {channel['title']}</b>\\n\"\n                    f\"   üÜî ID: {channel['channel_id']}\\n\"\n                    f\"   üë• Members: {member_count:,}\\n\"\n                    f\"   üìà Campaigns: {campaigns}\\n\"\n                )\n                \n                # Show recent activity\n                if channel.get('recent_views'):\n                    latest_views = channel['recent_views'][0]\n                    text += f\"   üëÅÔ∏è Latest Views: {latest_views['metric_value']}\\n\"\n                \n                text += f\"   üìÖ Added: {channel['created_at'].strftime('%m/%d/%Y')}\\n\\n\"\n            \n            # Create keyboard with pagination\n            keyboard = self._get_paginated_keyboard(page, total_pages, page_channels)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(f\"üìÑ Page {page} of {total_pages}\")\n            \n        except Exception as e:\n            logger.error(f\"Error showing channels page: {e}\")\n            await callback.answer(\"‚ùå Failed to load page\", show_alert=True)\n    \n    def _get_paginated_keyboard(self, current_page: int, total_pages: int, \n                               channels: List[Dict[str, Any]]):\n        \"\"\"Create paginated keyboard for channels\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = []\n        \n        # Add quick action buttons for channels on current page\n        for channel in channels[:3]:  # Show first 3 channels\n            status = \"üü¢\" if channel['is_active'] else \"üî¥\"\n            buttons.append([\n                InlineKeyboardButton(\n                    text=f\"{status} {channel['title'][:25]}\",\n                    callback_data=f\"cm_channel_{channel['id']}\"\n                )\n            ])\n        \n        # Pagination controls\n        if total_pages > 1:\n            nav_buttons = []\n            \n            if current_page > 1:\n                nav_buttons.append(\n                    InlineKeyboardButton(text=\"‚¨ÖÔ∏è Previous\", callback_data=f\"cm_page_{current_page-1}\")\n                )\n            \n            nav_buttons.append(\n                InlineKeyboardButton(text=f\"üìÑ {current_page}/{total_pages}\", callback_data=\"cm_page_info\")\n            )\n            \n            if current_page < total_pages:\n                nav_buttons.append(\n                    InlineKeyboardButton(text=\"Next ‚û°Ô∏è\", callback_data=f\"cm_page_{current_page+1}\")\n                )\n            \n            buttons.append(nav_buttons)\n        \n        # Action buttons\n        buttons.extend([\n            [\n                InlineKeyboardButton(text=\"üîÑ Refresh All\", callback_data=\"cm_refresh_all\"),\n                InlineKeyboardButton(text=\"üìä Export Data\", callback_data=\"cm_export_data\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚ûï Add Channel\", callback_data=\"cm_add_channel\"),\n                InlineKeyboardButton(text=\"‚öôÔ∏è Batch Operations\", callback_data=\"cm_batch_ops\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")\n            ]\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_no_channels_keyboard(self):\n        \"\"\"Get keyboard when no channels exist\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [InlineKeyboardButton(text=\"‚ûï Add First Channel\", callback_data=\"cm_add_channel\")],\n            [InlineKeyboardButton(text=\"‚ùì How to Add\", callback_data=\"cm_add_help\")],\n            [InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    async def handle_channel_details(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Show detailed channel information\"\"\"\n        try:\n            # Extract channel ID\n            channel_id = int(callback.data.split(\"_\")[-1])\n            \n            # Get detailed channel information\n            channel_details = await self._get_detailed_channel_info(channel_id)\n            \n            if not channel_details:\n                await callback.answer(\"‚ùå Channel not found\", show_alert=True)\n                return\n            \n            # Create detailed text\n            text = await self._format_channel_details(channel_details)\n            \n            # Create keyboard\n            keyboard = self._get_channel_details_keyboard(channel_id)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"üìã Channel details loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error showing channel details: {e}\")\n            await callback.answer(\"‚ùå Failed to load details\", show_alert=True)\n    \n    async def _get_detailed_channel_info(self, channel_id: int) -> Dict[str, Any]:\n        \"\"\"Get comprehensive channel information\"\"\"\n        try:\n            # Get basic channel info\n            channel = await self.db.get_channel_by_id(channel_id)\n            if not channel:\n                return None\n            \n            # Get campaigns\n            campaigns = await self.db.fetch_all(\n                \"\"\"\n                SELECT status, COUNT(*) as count, SUM(target_views) as target_views, \n                       SUM(current_views) as current_views\n                FROM view_boost_campaigns \n                WHERE channel_id = $1 \n                GROUP BY status\n                \"\"\",\n                channel_id\n            )\n            \n            # Get recent analytics\n            analytics = await self.db.get_analytics_data('channel', channel_id, limit=30)\n            \n            # Get boost logs\n            recent_boosts = await self.db.fetch_all(\n                \"\"\"\n                SELECT vbl.*, vbc.message_id, ta.phone_number\n                FROM view_boost_logs vbl\n                JOIN view_boost_campaigns vbc ON vbl.campaign_id = vbc.id\n                JOIN telegram_accounts ta ON vbl.account_id = ta.id\n                WHERE vbc.channel_id = $1\n                ORDER BY vbl.timestamp DESC\n                LIMIT 10\n                \"\"\",\n                channel_id\n            )\n            \n            return {\n                'channel': channel,\n                'campaigns': campaigns,\n                'analytics': analytics,\n                'recent_boosts': recent_boosts\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting detailed channel info: {e}\")\n            return None\n    \n    async def _format_channel_details(self, details: Dict[str, Any]) -> str:\n        \"\"\"Format detailed channel information\"\"\"\n        channel = details['channel']\n        campaigns = details['campaigns']\n        analytics = details['analytics']\n        recent_boosts = details['recent_boosts']\n        \n        text = f\"üìã <b>{channel['title']}</b>\\n\\n\"\n        \n        # Basic info\n        text += f\"üÜî <b>Channel ID:</b> {channel['channel_id']}\\n\"\n        if channel.get('username'):\n            text += f\"üìß <b>Username:</b> @{channel['username']}\\n\"\n        text += f\"üë• <b>Members:</b> {channel.get('member_count', 'Unknown'):,}\\n\"\n        text += f\"üìÖ <b>Added:</b> {channel['created_at'].strftime('%Y-%m-%d %H:%M')}\\n\"\n        text += f\"üîÑ <b>Status:</b> {'Active' if channel['is_active'] else 'Inactive'}\\n\\n\"\n        \n        # Campaign statistics\n        text += f\"üìà <b>Campaign Statistics:</b>\\n\"\n        total_campaigns = sum(c['count'] for c in campaigns)\n        total_target = sum(c['target_views'] or 0 for c in campaigns)\n        total_current = sum(c['current_views'] or 0 for c in campaigns)\n        \n        text += f\"‚Ä¢ Total Campaigns: {total_campaigns}\\n\"\n        if campaigns:\n            for campaign in campaigns:\n                status_emoji = {\"active\": \"üü¢\", \"completed\": \"‚úÖ\", \"failed\": \"‚ùå\", \"paused\": \"‚è∏Ô∏è\"}.get(campaign['status'], \"‚ö™\")\n                text += f\"‚Ä¢ {status_emoji} {campaign['status'].title()}: {campaign['count']}\\n\"\n        \n        if total_target > 0:\n            completion_rate = (total_current / total_target) * 100\n            text += f\"‚Ä¢ Target Views: {total_target:,}\\n\"\n            text += f\"‚Ä¢ Current Views: {total_current:,}\\n\"\n            text += f\"‚Ä¢ Completion: {completion_rate:.1f}%\\n\"\n        \n        text += \"\\n\"\n        \n        # Recent activity\n        if recent_boosts:\n            text += f\"üöÄ <b>Recent Boost Activity:</b>\\n\"\n            for boost in recent_boosts[:5]:\n                success_emoji = \"‚úÖ\" if boost['success'] else \"‚ùå\"\n                text += f\"‚Ä¢ {success_emoji} +{boost['views_added']} views ({boost['timestamp'].strftime('%m/%d %H:%M')})\\n\"\n        else:\n            text += f\"üöÄ <b>Recent Activity:</b> No recent boosts\\n\"\n        \n        text += \"\\n\"\n        \n        # Analytics summary\n        if analytics:\n            text += f\"üìä <b>Analytics:</b>\\n\"\n            text += f\"‚Ä¢ Data Points: {len(analytics)}\\n\"\n            \n            # Get latest member count if available\n            member_analytics = [a for a in analytics if a['metric_name'] == 'member_count']\n            if member_analytics:\n                latest_count = member_analytics[0]['metric_value']\n                text += f\"‚Ä¢ Latest Member Count: {latest_count:,.0f}\\n\"\n        \n        return text\n    \n    def _get_channel_details_keyboard(self, channel_id: int):\n        \"\"\"Get keyboard for channel details\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üöÄ Boost Views\", callback_data=f\"vm_boost_channel_{channel_id}\"),\n                InlineKeyboardButton(text=\"üìä Full Analytics\", callback_data=f\"an_channel_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üé≠ Reactions\", callback_data=f\"er_channel_{channel_id}\"),\n                InlineKeyboardButton(text=\"üëÅÔ∏è Monitor\", callback_data=f\"vm_monitor_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"‚úèÔ∏è Edit\", callback_data=f\"cm_edit_{channel_id}\"),\n                InlineKeyboardButton(text=\"üîÑ Refresh\", callback_data=f\"cm_refresh_{channel_id}\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üîô Back to List\", callback_data=\"cm_list_channels\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    async def handle_refresh_all(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Refresh all user channels\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user channels\n            channels = await self.db.get_user_channels(user_id, active_only=True)\n            \n            if not channels:\n                await callback.answer(\"üì≠ No channels to refresh\", show_alert=True)\n                return\n            \n            # Show progress message\n            await callback.message.edit_text(\n                f\"üîÑ <b>Refreshing {len(channels)} channels...</b>\\n\\n\"\n                \"This may take a few minutes. Please wait...\",\n                reply_markup=None\n            )\n            \n            # Queue refresh tasks (if channel processor is available)\n            try:\n                from ..core.channel_processor import ChannelProcessor\n                processor = ChannelProcessor(self.config, self.db, self.bot_core)\n                await processor.queue_batch_refresh(user_id)\n                \n                message = f\"‚úÖ Refresh queued for {len(channels)} channels. Updates will appear shortly.\"\n            except:\n                # Fallback: simple refresh\n                updated_count = 0\n                for channel in channels[:5]:  # Limit to 5 for manual refresh\n                    try:\n                        # Simple database update\n                        await self.db.execute_query(\n                            \"UPDATE channels SET updated_at = NOW() WHERE id = $1\",\n                            channel['id']\n                        )\n                        updated_count += 1\n                    except:\n                        continue\n                \n                message = f\"‚úÖ Refreshed {updated_count} channels successfully.\"\n            \n            # Show completion message\n            from ..keyboards import ChannelManagementKeyboards\n            keyboards = ChannelManagementKeyboards()\n            \n            await callback.message.edit_text(\n                message,\n                reply_markup=keyboards.get_back_to_menu_keyboard()\n            )\n            \n            await callback.answer(\"‚úÖ Refresh completed\")\n            \n        except Exception as e:\n            logger.error(f\"Error refreshing all channels: {e}\")\n            await callback.answer(\"‚ùå Refresh failed\", show_alert=True)\n    \n    async def handle_export_data(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Export channel data\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get comprehensive user data\n            channels = await self.universal_db.get_user_channels_with_stats(user_id)\n            \n            if not channels:\n                await callback.answer(\"üì≠ No data to export\", show_alert=True)\n                return\n            \n            # Create export text\n            export_text = f\"üìä <b>Channel Data Export</b>\\n\"\n            export_text += f\"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\"\n            export_text += f\"üë§ User ID: {user_id}\\n\\n\"\n            \n            for i, channel in enumerate(channels, 1):\n                export_text += f\"<b>{i}. {channel['title']}</b>\\n\"\n                export_text += f\"   üÜî ID: {channel['channel_id']}\\n\"\n                export_text += f\"   üë• Members: {channel.get('member_count', 0):,}\\n\"\n                export_text += f\"   üìà Campaigns: {channel.get('campaign_stats', {}).get('total', 0)}\\n\"\n                export_text += f\"   üìÖ Added: {channel['created_at'].strftime('%Y-%m-%d')}\\n\"\n                export_text += f\"   üîÑ Status: {'Active' if channel['is_active'] else 'Inactive'}\\n\\n\"\n            \n            # Summary\n            total_channels = len(channels)\n            active_channels = len([c for c in channels if c['is_active']])\n            total_campaigns = sum(c.get('campaign_stats', {}).get('total', 0) for c in channels)\n            \n            export_text += f\"üìã <b>Summary:</b>\\n\"\n            export_text += f\"‚Ä¢ Total Channels: {total_channels}\\n\"\n            export_text += f\"‚Ä¢ Active Channels: {active_channels}\\n\"\n            export_text += f\"‚Ä¢ Total Campaigns: {total_campaigns}\\n\"\n            \n            # Create keyboard\n            from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"üìã View Channels\", callback_data=\"cm_list_channels\")],\n                [InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"refresh_main\")]\n            ])\n            \n            await callback.message.edit_text(export_text, reply_markup=keyboard)\n            await callback.answer(\"üìä Data exported successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Error exporting data: {e}\")\n            await callback.answer(\"‚ùå Export failed\", show_alert=True)\n    \n    async def get_channel_list_summary(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get summary of user's channel list\"\"\"\n        try:\n            channels = await self.universal_db.get_user_channels_with_stats(user_id)\n            \n            total = len(channels)\n            active = len([c for c in channels if c['is_active']])\n            total_members = sum(c.get('member_count', 0) for c in channels)\n            total_campaigns = sum(c.get('campaign_stats', {}).get('total', 0) for c in channels)\n            \n            return {\n                'total_channels': total,\n                'active_channels': active,\n                'total_members': total_members,\n                'total_campaigns': total_campaigns,\n                'channels': channels[:5]  # Return first 5 for preview\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting channel list summary: {e}\")\n            return {\n                'total_channels': 0,\n                'active_channels': 0,\n                'total_members': 0,\n                'total_campaigns': 0,\n                'channels': []\n            }\n    \n    async def shutdown(self):\n        \"\"\"Shutdown list channels handler\"\"\"\n        logger.info(\"‚úÖ List channels handler shut down\")\n","size_bytes":20637},"features/view_manager/handlers/__init__.py":{"content":"\"\"\"\nView Manager Sub-handlers\n\"\"\"\n\nfrom .auto_boost import AutoBoostHandler\nfrom .manual_boost import ManualBoostHandler\n\n__all__ = ['AutoBoostHandler', 'ManualBoostHandler']\n","size_bytes":175},"features/view_manager/handlers/auto_boost.py":{"content":"\"\"\"\nAuto Boost Handler\nHandles automatic view boosting operations\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, Any, List\nfrom datetime import datetime, timedelta\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import CallbackQuery, Message\nfrom aiogram.fsm.context import FSMContext\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\nfrom core.bot.telegram_bot import TelegramBotCore\nfrom telethon.tl import functions\n\nlogger = logging.getLogger(__name__)\n\n\nclass AutoBoostHandler:\n    \"\"\"Handler for automatic view boosting\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config, bot_core=None):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.bot_core = bot_core if bot_core else TelegramBotCore(config, db_manager)\n        self._monitoring_tasks = {}\n        self._boost_workers = []\n        self._running = False\n        \n    async def initialize(self):\n        \"\"\"Initialize auto boost handler\"\"\"\n        try:\n            await self.bot_core.initialize()\n            # Wait for database schema to be ready before starting monitoring\n            await asyncio.sleep(10)\n            await self._start_monitoring()\n            self._running = True\n            logger.info(\"‚úÖ Auto boost handler initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize auto boost handler: {e}\")\n            raise\n    \n    def register_handlers(self, dp: Dispatcher):\n        \"\"\"Register handlers with dispatcher\"\"\"\n        # Auto boost specific callbacks\n        dp.callback_query.register(\n            self.handle_auto_boost_callback,\n            lambda c: c.data.startswith('ab_')\n        )\n        \n        logger.info(\"‚úÖ Auto boost handlers registered\")\n    \n    async def handle_auto_boost_callback(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle auto boost callbacks\"\"\"\n        try:\n            callback_data = callback.data\n            user_id = callback.from_user.id\n            \n            if callback_data == \"ab_setup\":\n                await self._handle_setup_auto_boost(callback, state)\n            elif callback_data == \"ab_campaigns\":\n                await self._handle_view_campaigns(callback, state)\n            elif callback_data == \"ab_pause_all\":\n                await self._handle_pause_all(callback, state)\n            elif callback_data == \"ab_resume_all\":\n                await self._handle_resume_all(callback, state)\n            elif callback_data == \"ab_settings\":\n                await self._handle_auto_settings(callback, state)\n            else:\n                await callback.answer(\"‚ùå Unknown auto boost action\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error in auto boost callback: {e}\")\n            await callback.answer(\"‚ùå An error occurred\", show_alert=True)\n    \n    async def _handle_setup_auto_boost(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle auto boost setup\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user channels\n            channels = await self.db.get_user_channels(user_id)\n            if not channels:\n                await callback.message.edit_text(\n                    \"üì≠ <b>No Channels Available</b>\\n\\n\"\n                    \"Please add channels first before setting up auto boosting.\",\n                    reply_markup=self._get_no_channels_keyboard()\n                )\n                return\n            \n            # Get user accounts\n            accounts = await self.db.get_user_accounts(user_id, active_only=True)\n            if not accounts:\n                await callback.message.edit_text(\n                    \"üì± <b>No Accounts Available</b>\\n\\n\"\n                    \"Please add Telegram accounts first before setting up auto boosting.\",\n                    reply_markup=self._get_no_accounts_keyboard()\n                )\n                return\n            \n            text = f\"\"\"\n‚öôÔ∏è <b>Setup Auto Boost</b>\n\nConfigure automatic view boosting for your channels.\n\n<b>üìä Available Resources:</b>\n‚Ä¢ Channels: {len(channels)}\n‚Ä¢ Accounts: {len(accounts)}\n\n<b>ü§ñ Auto Boost Features:</b>\n‚Ä¢ Monitor channels for new posts\n‚Ä¢ Automatically boost views within minutes\n‚Ä¢ Configurable boost amounts and timing\n‚Ä¢ Smart account rotation\n‚Ä¢ Natural-looking patterns\n\nSelect channels to enable auto boosting:\n            \"\"\"\n            \n            keyboard = self._get_setup_channels_keyboard(channels)\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚öôÔ∏è Auto boost setup loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in setup auto boost: {e}\")\n            await callback.answer(\"‚ùå Failed to load setup\", show_alert=True)\n    \n    async def _handle_view_campaigns(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle view auto campaigns\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get auto campaigns\n            campaigns = await self.db.fetch_all(\n                \"\"\"\n                SELECT vbc.*, c.title as channel_title, c.username as channel_username\n                FROM view_boost_campaigns vbc\n                JOIN telegram_channels c ON vbc.channel_id = c.id\n                WHERE vbc.user_id = $1 AND vbc.campaign_type = 'auto'\n                ORDER BY vbc.created_at DESC\n                LIMIT 10\n                \"\"\",\n                user_id\n            )\n            \n            if not campaigns:\n                await callback.message.edit_text(\n                    \"üì≠ <b>No Auto Campaigns</b>\\n\\n\"\n                    \"You haven't set up any auto boost campaigns yet.\",\n                    reply_markup=self._get_no_campaigns_keyboard()\n                )\n                return\n            \n            text = f\"ü§ñ <b>Auto Boost Campaigns ({len(campaigns)})</b>\\n\\n\"\n            \n            for campaign in campaigns:\n                status_emoji = {\n                    'active': 'üü¢',\n                    'paused': '‚è∏Ô∏è', \n                    'completed': '‚úÖ',\n                    'failed': '‚ùå'\n                }.get(campaign['status'], '‚ö™')\n                \n                progress = 0\n                if campaign['target_views'] > 0:\n                    progress = (campaign['current_views'] / campaign['target_views']) * 100\n                \n                text += (\n                    f\"{status_emoji} <b>{campaign['channel_title']}</b>\\n\"\n                    f\"   üéØ Progress: {campaign['current_views']:,}/{campaign['target_views']:,} ({progress:.1f}%)\\n\"\n                    f\"   üìÖ Created: {campaign['created_at'].strftime('%m/%d %H:%M')}\\n\\n\"\n                )\n            \n            keyboard = self._get_campaigns_keyboard(campaigns[:5])  # Show first 5 in keyboard\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(f\"ü§ñ {len(campaigns)} auto campaigns loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error viewing campaigns: {e}\")\n            await callback.answer(\"‚ùå Failed to load campaigns\", show_alert=True)\n    \n    async def _handle_pause_all(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle pause all campaigns\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Pause all active auto campaigns\n            updated = await self.db.execute_query(\n                \"\"\"\n                UPDATE view_boost_campaigns \n                SET status = 'paused', updated_at = NOW()\n                WHERE user_id = $1 AND campaign_type = 'auto' AND status = 'active'\n                \"\"\",\n                user_id\n            )\n            \n            await callback.answer(\"‚è∏Ô∏è All auto campaigns paused\")\n            await self._handle_view_campaigns(callback, state)\n            \n        except Exception as e:\n            logger.error(f\"Error pausing all campaigns: {e}\")\n            await callback.answer(\"‚ùå Failed to pause campaigns\", show_alert=True)\n    \n    async def _handle_resume_all(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle resume all campaigns\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Resume all paused auto campaigns\n            updated = await self.db.execute_query(\n                \"\"\"\n                UPDATE view_boost_campaigns \n                SET status = 'active', updated_at = NOW()\n                WHERE user_id = $1 AND campaign_type = 'auto' AND status = 'paused'\n                \"\"\",\n                user_id\n            )\n            \n            await callback.answer(\"‚ñ∂Ô∏è All auto campaigns resumed\")\n            await self._handle_view_campaigns(callback, state)\n            \n        except Exception as e:\n            logger.error(f\"Error resuming all campaigns: {e}\")\n            await callback.answer(\"‚ùå Failed to resume campaigns\", show_alert=True)\n    \n    async def _handle_auto_settings(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle auto boost settings\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get current settings\n            user = await self.db.get_user(user_id)\n            settings = user.get('settings', {}) if user else {}\n            auto_settings = settings.get('auto_boost', {})\n            \n            text = f\"\"\"\n‚öôÔ∏è <b>Auto Boost Settings</b>\n\n<b>üéØ Current Configuration:</b>\n‚Ä¢ Default Views per Post: {auto_settings.get('default_views', 500):,}\n‚Ä¢ Boost Delay: {auto_settings.get('delay_min', 2)}-{auto_settings.get('delay_max', 8)} seconds\n‚Ä¢ Max Posts per Hour: {auto_settings.get('max_posts_per_hour', 10)}\n‚Ä¢ Detection Delay: {auto_settings.get('detection_delay', 300)} seconds\n\n<b>ü§ñ Monitoring Settings:</b>\n‚Ä¢ Check Interval: {auto_settings.get('check_interval', 60)} seconds\n‚Ä¢ Account Rotation: {'Enabled' if auto_settings.get('rotate_accounts', True) else 'Disabled'}\n‚Ä¢ Smart Timing: {'Enabled' if auto_settings.get('smart_timing', True) else 'Disabled'}\n\n<b>üîß Advanced Options:</b>\n‚Ä¢ Retry Failed Boosts: {'Enabled' if auto_settings.get('retry_failed', True) else 'Disabled'}\n‚Ä¢ Weekend Mode: {'Enabled' if auto_settings.get('weekend_mode', False) else 'Disabled'}\n‚Ä¢ Quiet Hours: {auto_settings.get('quiet_start', '00:00')}-{auto_settings.get('quiet_end', '06:00')}\n            \"\"\"\n            \n            keyboard = self._get_settings_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(\"‚öôÔ∏è Auto boost settings loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in auto settings: {e}\")\n            await callback.answer(\"‚ùå Failed to load settings\", show_alert=True)\n    \n    async def _start_monitoring(self):\n        \"\"\"Start monitoring for new posts\"\"\"\n        try:\n            # Start monitoring workers\n            worker_count = min(3, self.config.MAX_ACTIVE_CLIENTS // 20)\n            \n            for i in range(worker_count):\n                worker = asyncio.create_task(self._monitoring_worker(f\"monitor-{i}\"))\n                self._boost_workers.append(worker)\n            \n            logger.info(f\"‚úÖ Started {worker_count} auto boost monitoring workers\")\n            \n        except Exception as e:\n            logger.error(f\"Error starting monitoring: {e}\")\n            raise\n    \n    async def _monitoring_worker(self, worker_name: str):\n        \"\"\"Background worker for monitoring channels\"\"\"\n        logger.info(f\"üîß Started auto boost monitoring worker: {worker_name}\")\n        \n        while self._running:\n            try:\n                # Get active auto campaigns\n                active_campaigns = await self.db.fetch_all(\n                    \"\"\"\n                    SELECT vbc.*, vbc.channel_id as telegram_channel_id, vbc.user_id\n                    FROM view_boost_campaigns vbc\n                    JOIN telegram_channels c ON vbc.channel_id = c.id\n                    WHERE vbc.campaign_type = 'auto' AND vbc.status = 'active'\n                    AND vbc.updated_at < NOW() - INTERVAL '5 minutes'\n                    LIMIT 10\n                    \"\"\"\n                )\n                \n                # Process each campaign\n                for campaign in active_campaigns:\n                    try:\n                        await self._process_auto_campaign(campaign)\n                    except Exception as e:\n                        logger.error(f\"Error processing campaign {campaign['id']}: {e}\")\n                \n                # Wait before next check\n                await asyncio.sleep(60)  # Check every minute\n                \n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Error in monitoring worker {worker_name}: {e}\")\n                await asyncio.sleep(30)  # Brief pause before continuing\n    \n    async def _process_auto_campaign(self, campaign: Dict[str, Any]):\n        \"\"\"Process individual auto campaign\"\"\"\n        try:\n            user_id = campaign['user_id']\n            channel_id = campaign['channel_id']\n            \n            # Get user accounts\n            accounts = await self.db.get_user_accounts(user_id, active_only=True)\n            if not accounts:\n                return\n            \n            # Check for new posts in the channel\n            new_posts = await self._check_for_new_posts(channel_id, accounts[0])\n            \n            if new_posts:\n                for post in new_posts:\n                    # Create boost campaign for new post\n                    await self._create_auto_boost_for_post(campaign, post)\n            \n            # Update campaign last check time\n            await self.db.execute_query(\n                \"UPDATE view_boost_campaigns SET updated_at = NOW() WHERE id = $1\",\n                campaign['id']\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error processing auto campaign: {e}\")\n    \n    async def _check_for_new_posts(self, channel_id: int, account: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Check channel for new posts\"\"\"\n        try:\n            client = await self.bot_core.get_client(account['id'])\n            if not client:\n                return []\n            \n            # Check rate limits\n            if not await self.bot_core.check_rate_limit(account['id']):\n                return []\n            \n            # Get recent messages\n            messages = await client.get_messages(channel_id, limit=5)\n            \n            # Update rate limiter\n            await self.bot_core.increment_rate_limit(account['id'])\n            \n            # Filter for new posts (within last hour)\n            new_posts = []\n            cutoff_time = datetime.now() - timedelta(hours=1)\n            \n            for message in messages:\n                if message.date and message.date.replace(tzinfo=None) > cutoff_time:\n                    # Check if we already have a campaign for this message\n                    existing = await self.db.fetch_one(\n                        \"SELECT id FROM view_boost_campaigns WHERE message_id = $1\",\n                        message.id\n                    )\n                    \n                    if not existing:\n                        new_posts.append({\n                            'message_id': message.id,\n                            'date': message.date,\n                            'text': message.text or '',\n                            'views': getattr(message, 'views', 0)\n                        })\n            \n            return new_posts\n            \n        except Exception as e:\n            logger.error(f\"Error checking for new posts: {e}\")\n            return []\n    \n    async def _create_auto_boost_for_post(self, campaign: Dict[str, Any], post: Dict[str, Any]):\n        \"\"\"Create auto boost campaign for new post\"\"\"\n        try:\n            # Get user settings\n            user = await self.db.get_user(campaign['user_id'])\n            settings = user.get('settings', {}) if user else {}\n            auto_settings = settings.get('auto_boost', {})\n            \n            # Calculate boost parameters\n            target_views = auto_settings.get('default_views', 500)\n            \n            # Create new campaign\n            new_campaign_id = await self.db.create_view_boost_campaign(\n                campaign['user_id'],\n                campaign['channel_id'],\n                post['message_id'],\n                target_views,\n                'auto'\n            )\n            \n            if new_campaign_id:\n                # Start boosting process\n                await self._start_boost_process(new_campaign_id)\n                \n                logger.info(f\"Created auto boost campaign {new_campaign_id} for post {post['message_id']}\")\n                \n        except Exception as e:\n            logger.error(f\"Error creating auto boost for post: {e}\")\n    \n    async def _start_boost_process(self, campaign_id: int):\n        \"\"\"Start the boost process for a campaign\"\"\"\n        try:\n            # Create boost task\n            boost_task = asyncio.create_task(self._execute_boost_campaign(campaign_id))\n            \n            # Store task reference (optional, for tracking)\n            logger.info(f\"Started boost process for campaign {campaign_id}\")\n            \n        except Exception as e:\n            logger.error(f\"Error starting boost process: {e}\")\n    \n    async def _execute_boost_campaign(self, campaign_id: int):\n        \"\"\"Execute boost campaign\"\"\"\n        try:\n            # Get campaign details\n            campaign_progress = await self.universal_db.get_campaign_progress(campaign_id)\n            if 'error' in campaign_progress:\n                return\n            \n            campaign = campaign_progress['campaign']\n            \n            # Get user accounts\n            accounts = await self.db.get_user_accounts(campaign['user_id'], active_only=True)\n            if not accounts:\n                await self.db.update_campaign_progress(campaign_id, 0, 'failed')\n                return\n            \n            # Execute boost in batches\n            target_views = campaign['target_views']\n            current_views = campaign['current_views']\n            remaining_views = target_views - current_views\n            \n            batch_size = min(50, remaining_views)  # Boost in batches of 50\n            \n            while remaining_views > 0 and campaign['status'] == 'active':\n                # Select accounts for this batch\n                batch_accounts = accounts[:min(len(accounts), batch_size)]\n                \n                # Execute boost batch\n                batch_success = 0\n                for account in batch_accounts:\n                    try:\n                        success = await self._boost_single_view(campaign, account)\n                        if success:\n                            batch_success += 1\n                            \n                        # Random delay between boosts\n                        delay = self.config.VIEW_BOOST_DELAY_MIN + (\n                            self.config.VIEW_BOOST_DELAY_MAX - self.config.VIEW_BOOST_DELAY_MIN\n                        ) * 0.5  # Use average delay\n                        await asyncio.sleep(delay)\n                        \n                    except Exception as e:\n                        logger.error(f\"Error in single boost: {e}\")\n                \n                # Update campaign progress\n                new_views = current_views + batch_success\n                await self.db.update_campaign_progress(campaign_id, new_views)\n                \n                current_views = new_views\n                remaining_views = target_views - current_views\n                \n                # Check if campaign is completed\n                if remaining_views <= 0:\n                    await self.db.update_campaign_progress(campaign_id, current_views, 'completed')\n                    break\n                \n                # Wait before next batch\n                await asyncio.sleep(30)\n                \n                # Refresh campaign status\n                updated_campaign = await self.db.fetch_one(\n                    \"SELECT status FROM view_boost_campaigns WHERE id = $1\",\n                    campaign_id\n                )\n                if updated_campaign and updated_campaign['status'] != 'active':\n                    break\n            \n        except Exception as e:\n            logger.error(f\"Error executing boost campaign: {e}\")\n            await self.db.update_campaign_progress(campaign_id, None, 'failed')\n    \n    async def _boost_single_view(self, campaign: Dict[str, Any], account: Dict[str, Any]) -> bool:\n        \"\"\"Boost single view using account\"\"\"\n        try:\n            client = await self.bot_core.get_client(account['id'])\n            if not client:\n                return False\n            \n            # Check rate limits\n            if not await self.bot_core.check_rate_limit(account['id']):\n                return False\n            \n            # Get channel and message\n            channel_entity = await client.get_entity(campaign['channel_id'])\n            \n            # Use GetMessagesViewsRequest to boost views\n            result = await client(functions.messages.GetMessagesViewsRequest(\n                peer=channel_entity,\n                id=[campaign['message_id']],\n                increment=True\n            ))\n            \n            # Update rate limiter\n            await self.bot_core.increment_rate_limit(account['id'])\n            \n            # Log the boost\n            await self.db.log_view_boost(\n                campaign['id'],\n                account['id'],\n                1,  # One view added\n                True,\n                None\n            )\n            \n            return True\n            \n        except Exception as e:\n            # Log failed boost\n            await self.db.log_view_boost(\n                campaign['id'],\n                account['id'],\n                0,\n                False,\n                str(e)\n            )\n            logger.error(f\"Error boosting single view: {e}\")\n            return False\n    \n    def _get_setup_channels_keyboard(self, channels: List[Dict[str, Any]]):\n        \"\"\"Get setup channels keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = []\n        \n        # Add channels (max 8)\n        for channel in channels[:8]:\n            status = \"üü¢\" if channel['is_active'] else \"üî¥\"\n            buttons.append([\n                InlineKeyboardButton(\n                    text=f\"{status} {channel['title'][:30]}\",\n                    callback_data=f\"ab_enable_{channel['id']}\"\n                )\n            ])\n        \n        # Control buttons\n        buttons.extend([\n            [InlineKeyboardButton(text=\"‚úÖ Enable All\", callback_data=\"ab_enable_all\")],\n            [InlineKeyboardButton(text=\"‚öôÔ∏è Configure Settings\", callback_data=\"ab_configure\")],\n            [InlineKeyboardButton(text=\"üîô Back to Auto Boost\", callback_data=\"vm_auto_boost\")]\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_campaigns_keyboard(self, campaigns: List[Dict[str, Any]]):\n        \"\"\"Get campaigns keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = []\n        \n        # Add campaigns (max 5)\n        for campaign in campaigns[:5]:\n            status_emoji = {\n                'active': 'üü¢',\n                'paused': '‚è∏Ô∏è',\n                'completed': '‚úÖ',\n                'failed': '‚ùå'\n            }.get(campaign['status'], '‚ö™')\n            \n            buttons.append([\n                InlineKeyboardButton(\n                    text=f\"{status_emoji} {campaign['channel_title'][:25]}\",\n                    callback_data=f\"vm_campaign_view_{campaign['id']}\"\n                )\n            ])\n        \n        # Control buttons\n        buttons.extend([\n            [\n                InlineKeyboardButton(text=\"‚è∏Ô∏è Pause All\", callback_data=\"ab_pause_all\"),\n                InlineKeyboardButton(text=\"‚ñ∂Ô∏è Resume All\", callback_data=\"ab_resume_all\")\n            ],\n            [InlineKeyboardButton(text=\"‚ûï Setup New\", callback_data=\"ab_setup\")],\n            [InlineKeyboardButton(text=\"üîô Back to Auto Boost\", callback_data=\"vm_auto_boost\")]\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_settings_keyboard(self):\n        \"\"\"Get settings keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [\n                InlineKeyboardButton(text=\"üéØ Default Views\", callback_data=\"ab_set_views\"),\n                InlineKeyboardButton(text=\"‚è±Ô∏è Timing Settings\", callback_data=\"ab_set_timing\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üì± Account Settings\", callback_data=\"ab_set_accounts\"),\n                InlineKeyboardButton(text=\"üîç Detection Settings\", callback_data=\"ab_set_detection\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üåô Quiet Hours\", callback_data=\"ab_set_quiet\"),\n                InlineKeyboardButton(text=\"üìä Monitoring\", callback_data=\"ab_set_monitoring\")\n            ],\n            [\n                InlineKeyboardButton(text=\"üíæ Save Settings\", callback_data=\"ab_save_settings\"),\n                InlineKeyboardButton(text=\"üîÑ Reset to Default\", callback_data=\"ab_reset_settings\")\n            ],\n            [InlineKeyboardButton(text=\"üîô Back to Auto Boost\", callback_data=\"vm_auto_boost\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_no_channels_keyboard(self):\n        \"\"\"Get no channels keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [InlineKeyboardButton(text=\"‚ûï Add Channel\", callback_data=\"channel_management\")],\n            [InlineKeyboardButton(text=\"üîô Back to View Manager\", callback_data=\"view_manager\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_no_accounts_keyboard(self):\n        \"\"\"Get no accounts keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [InlineKeyboardButton(text=\"üì± Add Account\", callback_data=\"account_management\")],\n            [InlineKeyboardButton(text=\"üîô Back to View Manager\", callback_data=\"view_manager\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_no_campaigns_keyboard(self):\n        \"\"\"Get no campaigns keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [InlineKeyboardButton(text=\"‚öôÔ∏è Setup Auto Boost\", callback_data=\"ab_setup\")],\n            [InlineKeyboardButton(text=\"üîô Back to Auto Boost\", callback_data=\"vm_auto_boost\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    async def shutdown(self):\n        \"\"\"Shutdown auto boost handler\"\"\"\n        try:\n            logger.info(\"‚èπÔ∏è Shutting down auto boost handler...\")\n            \n            self._running = False\n            \n            # Cancel all workers\n            for worker in self._boost_workers:\n                worker.cancel()\n            \n            # Wait for workers to finish\n            if self._boost_workers:\n                await asyncio.gather(*self._boost_workers, return_exceptions=True)\n            \n            logger.info(\"‚úÖ Auto boost handler shut down\")\n            \n        except Exception as e:\n            logger.error(f\"Error shutting down auto boost handler: {e}\")\n","size_bytes":28167},"features/view_manager/handlers/manual_boost.py":{"content":"\"\"\"\nManual Boost Handler\nHandles manual view boosting operations\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import CallbackQuery, Message\nfrom aiogram.fsm.context import FSMContext\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\nfrom core.bot.telegram_bot import TelegramBotCore\nfrom ..states.states import ViewBoostStates\nfrom telethon.tl import functions\n\nlogger = logging.getLogger(__name__)\n\n\nclass ManualBoostHandler:\n    \"\"\"Handler for manual view boosting\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config, bot_core=None):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.bot_core = bot_core if bot_core else TelegramBotCore(config, db_manager)\n        self._active_boosts = {}\n        \n    async def initialize(self):\n        \"\"\"Initialize manual boost handler\"\"\"\n        try:\n            await self.bot_core.initialize()\n            logger.info(\"‚úÖ Manual boost handler initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize manual boost handler: {e}\")\n            raise\n    \n    def register_handlers(self, dp: Dispatcher):\n        \"\"\"Register handlers with dispatcher\"\"\"\n        # Manual boost specific callbacks\n        dp.callback_query.register(\n            self.handle_manual_boost_callback,\n            lambda c: c.data.startswith('mb_')\n        )\n        \n        logger.info(\"‚úÖ Manual boost handlers registered\")\n    \n    async def handle_manual_boost_callback(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle manual boost callbacks\"\"\"\n        try:\n            if not callback.data:\n                await callback.answer(\"‚ùå Invalid callback data\", show_alert=True)\n                return\n                \n            callback_data = callback.data\n            user_id = callback.from_user.id\n            \n            if callback_data == \"mb_by_link\":\n                await self._handle_boost_by_link(callback, state)\n            elif callback_data == \"mb_select_channel\":\n                await self._handle_select_channel(callback, state)\n            elif callback_data == \"mb_quick_boost\":\n                await self._handle_quick_boost(callback, state)\n            elif callback_data == \"mb_campaigns\":\n                await self._handle_view_campaigns(callback, state)\n            elif callback_data == \"mb_confirm_start\":\n                await self._handle_confirm_start(callback, state)\n            elif callback_data == \"mb_help_format\":\n                await self._handle_help_format(callback, state)\n            elif callback_data == \"mb_help_link\":\n                await self._handle_help_link(callback, state)\n            elif callback_data.startswith(\"mb_channel_\"):\n                await self._handle_channel_selected(callback, state)\n            elif callback_data.startswith(\"mb_quick_\"):\n                await self._handle_quick_channel(callback, state)\n            else:\n                await callback.answer(\"‚ùå Unknown manual boost action\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error in manual boost callback: {e}\")\n            try:\n                await callback.answer(\"‚ùå An error occurred\", show_alert=True)\n            except Exception:\n                logger.error(\"Failed to send error callback answer\")\n    \n    async def _handle_boost_by_link(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle boost by message link\"\"\"\n        try:\n            text = \"\"\"\nüîó <b>Boost by Message Link</b>\n\nSend me the Telegram message link you want to boost views for.\n\n<b>üìù Supported Link Formats:</b>\n‚Ä¢ https://t.me/channelname/123\n‚Ä¢ https://telegram.me/channelname/123\n‚Ä¢ @channelname/123\n‚Ä¢ channelname/123\n\n<b>üìã Requirements:</b>\n‚Ä¢ You must have access to the channel\n‚Ä¢ Message must be from one of your channels\n‚Ä¢ Link must be valid and accessible\n\nPlease send the message link:\n            \"\"\"\n            \n            keyboard = self._get_boost_by_link_keyboard()\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await state.set_state(ViewBoostStates.waiting_for_message_link)\n            await callback.answer(\"üîó Please send message link\")\n            \n        except Exception as e:\n            logger.error(f\"Error in boost by link: {e}\")\n            await callback.answer(\"‚ùå Failed to start boost by link\", show_alert=True)\n    \n    async def _handle_select_channel(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle select channel for boosting\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user channels\n            channels = await self.db.get_user_channels(user_id)\n            if not channels:\n                await callback.message.edit_text(\n                    \"üì≠ <b>No Channels Available</b>\\n\\n\"\n                    \"Please add channels first before manual boosting.\",\n                    reply_markup=self._get_no_channels_keyboard()\n                )\n                return\n            \n            text = f\"\"\"\nüìã <b>Select Channel to Boost</b>\n\nChoose a channel to boost views for its recent posts.\n\n<b>üìä Available Channels:</b> {len(channels)}\n\nSelect a channel below to see its recent posts:\n            \"\"\"\n            \n            keyboard = self._get_channel_selection_keyboard(channels)\n            \n            if callback.message:\n                await callback.message.edit_text(text, reply_markup=keyboard)\n                await callback.answer(\"üìã Select channel to boost\")\n            else:\n                await callback.answer(\"‚ùå Unable to update message\", show_alert=True)\n            \n        except Exception as e:\n            logger.error(f\"Error in select channel: {e}\")\n            await callback.answer(\"‚ùå Failed to load channels\", show_alert=True)\n    \n    async def _handle_quick_boost(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle quick boost setup\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user channels\n            channels = await self.db.get_user_channels(user_id)\n            if not channels:\n                if callback.message:\n                    await callback.message.edit_text(\n                        \"üì≠ <b>No Channels Available</b>\\n\\n\"\n                        \"Please add channels first before quick boosting.\",\n                        reply_markup=self._get_no_channels_keyboard()\n                    )\n                else:\n                    await callback.answer(\"‚ùå No channels available\", show_alert=True)\n                return\n            \n            text = f\"\"\"\nüöÄ <b>Quick Boost</b>\n\nInstantly boost the latest post from your channels with default settings.\n\n<b>‚ö° Quick Boost Features:</b>\n‚Ä¢ Boost latest post immediately\n‚Ä¢ Use default boost amount (500 views)\n‚Ä¢ Smart account selection\n‚Ä¢ Natural timing patterns\n‚Ä¢ Instant execution\n\n<b>üìä Available Channels:</b> {len(channels)}\n\nSelect a channel for quick boost:\n            \"\"\"\n            \n            keyboard = self._get_quick_boost_keyboard(channels)\n            \n            if callback.message:\n                await callback.message.edit_text(text, reply_markup=keyboard)\n                await callback.answer(\"üöÄ Quick boost options loaded\")\n            else:\n                await callback.answer(\"‚ùå Unable to update message\", show_alert=True)\n            \n        except Exception as e:\n            logger.error(f\"Error in quick boost: {e}\")\n            await callback.answer(\"‚ùå Failed to load quick boost\", show_alert=True)\n    \n    async def _handle_view_campaigns(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle view manual campaigns\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get manual campaigns\n            campaigns = await self.db.fetch_all(\n                \"\"\"\n                SELECT vbc.*, c.title as channel_title, c.username as channel_username\n                FROM view_boost_campaigns vbc\n                JOIN telegram_channels c ON vbc.channel_id = c.id\n                WHERE vbc.user_id = $1 AND vbc.campaign_type = 'manual'\n                ORDER BY vbc.created_at DESC\n                LIMIT 15\n                \"\"\",\n                user_id\n            )\n            \n            if not campaigns:\n                await callback.message.edit_text(\n                    \"üì≠ <b>No Manual Campaigns</b>\\n\\n\"\n                    \"You haven't created any manual boost campaigns yet.\",\n                    reply_markup=self._get_no_campaigns_keyboard()\n                )\n                return\n            \n            text = f\"üëÜ <b>Manual Boost Campaigns ({len(campaigns)})</b>\\n\\n\"\n            \n            # Show campaigns grouped by status\n            active_campaigns = [c for c in campaigns if c['status'] == 'active']\n            completed_campaigns = [c for c in campaigns if c['status'] == 'completed']\n            \n            if active_campaigns:\n                text += f\"üü¢ <b>Active Campaigns ({len(active_campaigns)}):</b>\\n\"\n                for campaign in active_campaigns[:3]:\n                    progress = 0\n                    if campaign['target_views'] > 0:\n                        progress = (campaign['current_views'] / campaign['target_views']) * 100\n                    \n                    text += (\n                        f\"‚Ä¢ {campaign['channel_title']}: \"\n                        f\"{campaign['current_views']:,}/{campaign['target_views']:,} ({progress:.1f}%)\\n\"\n                    )\n                text += \"\\n\"\n            \n            if completed_campaigns:\n                text += f\"‚úÖ <b>Recent Completed ({len(completed_campaigns[:3])}):</b>\\n\"\n                for campaign in completed_campaigns[:3]:\n                    text += (\n                        f\"‚Ä¢ {campaign['channel_title']}: \"\n                        f\"{campaign['current_views']:,} views completed\\n\"\n                    )\n            \n            keyboard = self._get_campaigns_keyboard(campaigns[:5])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(f\"üëÜ {len(campaigns)} manual campaigns loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error viewing campaigns: {e}\")\n            await callback.answer(\"‚ùå Failed to load campaigns\", show_alert=True)\n    \n    async def _handle_confirm_start(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle confirm start boost\"\"\"\n        try:\n            user_data = await state.get_data()\n            boost_params = user_data.get('boost_params')\n            message_link = user_data.get('message_link')\n            \n            if not boost_params:\n                await callback.answer(\"‚ùå Boost parameters not found\", show_alert=True)\n                return\n            \n            # Start the boost campaign\n            result = await self._create_and_start_campaign(callback.from_user.id, boost_params, message_link)\n            \n            if result['success']:\n                await callback.message.edit_text(\n                    f\"‚úÖ <b>Boost Campaign Started!</b>\\n\\n\"\n                    f\"üìä <b>Campaign Details:</b>\\n\"\n                    f\"‚Ä¢ Campaign ID: {result['campaign_id']}\\n\"\n                    f\"‚Ä¢ Target Views: {boost_params['views']:,}\\n\"\n                    f\"‚Ä¢ Estimated Duration: {self._estimate_duration(boost_params['views'])} minutes\\n\"\n                    f\"‚Ä¢ Accounts Used: {result['accounts_count']}\\n\\n\"\n                    f\"üöÄ Your boost is now running! Check progress in campaign stats.\",\n                    reply_markup=self._get_campaign_started_keyboard(result['campaign_id'])\n                )\n                \n                await callback.answer(\"‚úÖ Boost campaign started!\")\n            else:\n                await callback.message.edit_text(\n                    f\"‚ùå <b>Failed to Start Campaign</b>\\n\\n\"\n                    f\"Error: {result['error']}\\n\\n\"\n                    f\"Please check your settings and try again.\",\n                    reply_markup=self._get_retry_campaign_keyboard()\n                )\n                \n                await callback.answer(\"‚ùå Failed to start campaign\", show_alert=True)\n            \n            # Clear state\n            await state.clear()\n            \n        except Exception as e:\n            logger.error(f\"Error confirming start: {e}\")\n            await callback.answer(\"‚ùå Failed to start campaign\", show_alert=True)\n            await state.clear()\n    \n    async def _handle_channel_selected(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle channel selection for manual boost\"\"\"\n        try:\n            if not callback.data:\n                await callback.answer(\"‚ùå Invalid callback data\", show_alert=True)\n                return\n                \n            # Extract channel ID\n            channel_id = int(callback.data.split(\"_\")[-1])\n            \n            # Get channel info and recent posts\n            channel = await self.db.get_channel_by_id(channel_id)\n            if not channel:\n                await callback.answer(\"‚ùå Channel not found\", show_alert=True)\n                return\n            \n            # Get recent posts from the channel\n            recent_posts = await self._get_recent_posts(channel, callback.from_user.id)\n            \n            if not recent_posts:\n                await callback.message.edit_text(\n                    f\"üì≠ <b>No Recent Posts</b>\\n\\n\"\n                    f\"Channel: <b>{channel['title']}</b>\\n\\n\"\n                    f\"No recent posts found or unable to access channel messages.\\n\"\n                    f\"Please check channel permissions and try again.\",\n                    reply_markup=self._get_back_to_selection_keyboard()\n                )\n                return\n            \n            text = f\"\"\"\nüìã <b>{channel['title']}</b>\n\nRecent posts available for boosting:\n\n\"\"\"\n            \n            for i, post in enumerate(recent_posts[:5], 1):\n                post_text = post['text'][:50] + \"...\" if len(post['text']) > 50 else post['text']\n                text += (\n                    f\"<b>{i}.</b> {post_text}\\n\"\n                    f\"   üìÖ {post['date'].strftime('%m/%d %H:%M')} ‚Ä¢ \"\n                    f\"üëÅÔ∏è {post.get('views', 0):,} views\\n\\n\"\n                )\n            \n            text += \"Select a post to boost or set custom parameters:\"\n            \n            keyboard = self._get_posts_keyboard(channel_id, recent_posts[:3])\n            \n            await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer(f\"üìã {len(recent_posts)} posts loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error in channel selected: {e}\")\n            await callback.answer(\"‚ùå Failed to load channel posts\", show_alert=True)\n    \n    async def _handle_quick_channel(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle quick boost for specific channel\"\"\"\n        try:\n            if not callback.data:\n                await callback.answer(\"‚ùå Invalid callback data\", show_alert=True)\n                return\n                \n            # Extract channel ID\n            channel_id = int(callback.data.split(\"_\")[-1])\n            \n            # Get channel info\n            channel = await self.db.get_channel_by_id(channel_id)\n            if not channel:\n                await callback.answer(\"‚ùå Channel not found\", show_alert=True)\n                return\n            \n            # Show progress message\n            await callback.message.edit_text(\n                f\"üöÄ <b>Starting Quick Boost</b>\\n\\n\"\n                f\"Channel: <b>{channel['title']}</b>\\n\"\n                f\"Finding latest post and starting boost...\\n\\n\"\n                f\"‚è≥ Please wait...\",\n                reply_markup=None\n            )\n            \n            # Execute quick boost\n            result = await self._execute_quick_boost(channel, callback.from_user.id)\n            \n            if result['success']:\n                await callback.message.edit_text(\n                    f\"‚úÖ <b>Quick Boost Started!</b>\\n\\n\"\n                    f\"üìã <b>Details:</b>\\n\"\n                    f\"‚Ä¢ Channel: {channel['title']}\\n\"\n                    f\"‚Ä¢ Message ID: {result['message_id']}\\n\"\n                    f\"‚Ä¢ Target Views: {result['target_views']:,}\\n\"\n                    f\"‚Ä¢ Campaign ID: {result['campaign_id']}\\n\\n\"\n                    f\"üöÄ Your quick boost is now running!\",\n                    reply_markup=self._get_campaign_started_keyboard(result['campaign_id'])\n                )\n                \n                await callback.answer(\"‚úÖ Quick boost started!\")\n            else:\n                await callback.message.edit_text(\n                    f\"‚ùå <b>Quick Boost Failed</b>\\n\\n\"\n                    f\"Error: {result['error']}\\n\\n\"\n                    f\"Please try manual boost instead.\",\n                    reply_markup=self._get_retry_quick_keyboard()\n                )\n                \n                await callback.answer(\"‚ùå Quick boost failed\", show_alert=True)\n            \n        except Exception as e:\n            logger.error(f\"Error in quick channel boost: {e}\")\n            await callback.answer(\"‚ùå Failed to execute quick boost\", show_alert=True)\n    \n    async def _handle_help_format(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Show help for boost parameter format\"\"\"\n        try:\n            help_text = \"\"\"\n‚ùì <b>Boost Parameters Help</b>\n\n<b>üìù Parameter Format:</b>\n<code>views=1000 delay=5-10 accounts=all</code>\n\n<b>üéØ Available Parameters:</b>\n\n<b>views</b> (required)\n‚Ä¢ Number of views to boost\n‚Ä¢ Range: 1 to 100,000\n‚Ä¢ Example: <code>views=500</code>\n\n<b>delay</b> (optional)\n‚Ä¢ Delay between boosts in seconds\n‚Ä¢ Format: min-max or single value\n‚Ä¢ Default: 2-8 seconds\n‚Ä¢ Example: <code>delay=3-7</code>\n\n<b>accounts</b> (optional)\n‚Ä¢ Which accounts to use\n‚Ä¢ Options: all, random, count\n‚Ä¢ Default: all\n‚Ä¢ Example: <code>accounts=5</code>\n\n<b>üìã Complete Examples:</b>\n‚Ä¢ <code>views=1000</code>\n‚Ä¢ <code>views=500 delay=10</code>\n‚Ä¢ <code>views=2000 delay=5-15 accounts=10</code>\n‚Ä¢ <code>views=750 delay=3</code>\n            \"\"\"\n            \n            keyboard = self._get_help_back_keyboard()\n            \n            await callback.message.edit_text(help_text, reply_markup=keyboard)\n            await callback.answer(\"üìö Parameter format help loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error showing format help: {e}\")\n            await callback.answer(\"‚ùå Failed to load help\", show_alert=True)\n    \n    async def _handle_help_link(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Show help for message link format\"\"\"\n        try:\n            help_text = \"\"\"\n‚ùì <b>Message Link Help</b>\n\n<b>üìù How to Get Message Links:</b>\n\n<b>1. From Telegram App:</b>\n‚Ä¢ Open the message you want to boost\n‚Ä¢ Tap and hold the message\n‚Ä¢ Select \"Copy Link\"\n‚Ä¢ Paste the link in this bot\n\n<b>2. From Telegram Web:</b>\n‚Ä¢ Right-click the message\n‚Ä¢ Select \"Copy Message Link\"\n‚Ä¢ Paste the link here\n\n<b>üîó Supported Link Formats:</b>\n‚Ä¢ <code>https://t.me/channelname/123</code>\n‚Ä¢ <code>https://telegram.me/channelname/123</code>\n‚Ä¢ <code>@channelname/123</code>\n‚Ä¢ <code>channelname/123</code>\n\n<b>üìã Requirements:</b>\n‚Ä¢ Channel must be in your channel list\n‚Ä¢ Message must be accessible\n‚Ä¢ You need appropriate permissions\n\n<b>üí° Tips:</b>\n‚Ä¢ Use public channel links when possible\n‚Ä¢ Ensure the message ID is correct\n‚Ä¢ Check that the channel is active\n            \"\"\"\n            \n            keyboard = self._get_help_back_keyboard()\n            \n            await callback.message.edit_text(help_text, reply_markup=keyboard)\n            await callback.answer(\"üìö Message link help loaded\")\n            \n        except Exception as e:\n            logger.error(f\"Error showing link help: {e}\")\n            await callback.answer(\"‚ùå Failed to load help\", show_alert=True)\n    \n    async def _get_recent_posts(self, channel: Dict[str, Any], user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get recent posts from channel\"\"\"\n        try:\n            # Get user accounts\n            accounts = await self.db.get_user_accounts(user_id, active_only=True)\n            if not accounts:\n                return []\n            \n            # Try with first available account\n            client = await self.bot_core.get_client(accounts[0]['id'])\n            if not client:\n                return []\n            \n            # Check rate limits\n            if not await self.bot_core.check_rate_limit(accounts[0]['id']):\n                return []\n            \n            # Get recent messages\n            messages = await client.get_messages(channel['channel_id'], limit=10)\n            \n            # Update rate limiter\n            await self.bot_core.increment_rate_limit(accounts[0]['id'])\n            \n            # Format posts\n            posts = []\n            if messages:\n                for message in messages:\n                    if message and message.date:\n                        posts.append({\n                            'message_id': message.id,\n                            'text': message.text or '[Media]',\n                            'date': message.date.replace(tzinfo=None),\n                            'views': getattr(message, 'views', 0)\n                        })\n            \n            return posts\n            \n        except Exception as e:\n            logger.error(f\"Error getting recent posts: {e}\")\n            return []\n    \n    async def _create_and_start_campaign(self, user_id: int, boost_params: Dict[str, Any], \n                                       message_link: Dict[str, Any] = None) -> Dict[str, Any]:\n        \"\"\"Create and start boost campaign\"\"\"\n        try:\n            # Determine channel and message\n            if message_link:\n                # Find channel by name\n                channel = await self.db.fetch_one(\n                    \"SELECT * FROM telegram_channels WHERE user_id = $1 AND username = $2\",\n                    user_id, message_link['channel_name']\n                )\n                if not channel:\n                    return {'success': False, 'error': 'Channel not found in your channel list'}\n                \n                message_id = message_link['message_id']\n            else:\n                return {'success': False, 'error': 'Message information required'}\n            \n            # Create campaign (temporary placeholder - need to implement this method)\n            # campaign_id = await self.db.create_view_boost_campaign(\n            #     user_id, channel['id'], message_id, boost_params['views'], 'manual'\n            # )\n            campaign_id = None\n            \n            if not campaign_id:\n                return {'success': False, 'error': 'Failed to create campaign'}\n            \n            # Get available accounts\n            accounts = await self.db.get_user_accounts(user_id, active_only=True)\n            if not accounts:\n                return {'success': False, 'error': 'No active accounts available'}\n            \n            # Start boost process\n            boost_task = asyncio.create_task(\n                self._execute_manual_boost(campaign_id, boost_params, accounts)\n            )\n            \n            # Store task reference\n            self._active_boosts[campaign_id] = boost_task\n            \n            return {\n                'success': True,\n                'campaign_id': campaign_id,\n                'accounts_count': len(accounts)\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error creating and starting campaign: {e}\")\n            return {'success': False, 'error': str(e)}\n    \n    async def _execute_quick_boost(self, channel: Dict[str, Any], user_id: int) -> Dict[str, Any]:\n        \"\"\"Execute quick boost for channel\"\"\"\n        try:\n            # Get latest post\n            recent_posts = await self._get_recent_posts(channel, user_id)\n            if not recent_posts:\n                return {'success': False, 'error': 'No recent posts found'}\n            \n            latest_post = recent_posts[0]\n            \n            # Default quick boost parameters\n            boost_params = {\n                'views': 500,\n                'delay_min': 3,\n                'delay_max': 8,\n                'accounts': 'all'\n            }\n            \n            # Create campaign\n            campaign_id = await self.db.create_view_boost_campaign(\n                user_id, channel['id'], latest_post['message_id'], boost_params['views'], 'manual'\n            )\n            \n            if not campaign_id:\n                return {'success': False, 'error': 'Failed to create campaign'}\n            \n            # Get accounts\n            accounts = await self.db.get_user_accounts(user_id, active_only=True)\n            if not accounts:\n                return {'success': False, 'error': 'No active accounts available'}\n            \n            # Start boost\n            boost_task = asyncio.create_task(\n                self._execute_manual_boost(campaign_id, boost_params, accounts)\n            )\n            \n            self._active_boosts[campaign_id] = boost_task\n            \n            return {\n                'success': True,\n                'campaign_id': campaign_id,\n                'message_id': latest_post['message_id'],\n                'target_views': boost_params['views']\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error executing quick boost: {e}\")\n            return {'success': False, 'error': str(e)}\n    \n    async def _execute_manual_boost(self, campaign_id: int, boost_params: Dict[str, Any], \n                                  accounts: List[Dict[str, Any]]):\n        \"\"\"Execute manual boost campaign\"\"\"\n        try:\n            target_views = boost_params['views']\n            delay_min = boost_params['delay_min']\n            delay_max = boost_params['delay_max']\n            \n            # Get campaign details\n            campaign = await self.db.fetch_one(\n                \"SELECT * FROM view_boost_campaigns WHERE id = $1\",\n                campaign_id\n            )\n            \n            if not campaign:\n                return\n            \n            current_views = 0\n            \n            # Execute boost in batches\n            batch_size = min(20, len(accounts))\n            \n            while current_views < target_views:\n                # Select accounts for this batch\n                batch_accounts = accounts[:batch_size]\n                \n                # Execute batch\n                batch_success = 0\n                for account in batch_accounts:\n                    if current_views >= target_views:\n                        break\n                    \n                    try:\n                        success = await self._boost_single_view_manual(campaign, account)\n                        if success:\n                            batch_success += 1\n                            current_views += 1\n                        \n                        # Delay between boosts\n                        import random\n                        delay = random.uniform(delay_min, delay_max)\n                        await asyncio.sleep(delay)\n                        \n                    except Exception as e:\n                        logger.error(f\"Error in manual boost: {e}\")\n                \n                # Update campaign progress\n                await self.db.update_campaign_progress(campaign_id, current_views)\n                \n                # Check if we should continue\n                if current_views >= target_views:\n                    await self.db.update_campaign_progress(campaign_id, current_views, 'completed')\n                    break\n                \n                # Wait before next batch\n                await asyncio.sleep(10)\n            \n            # Clean up task reference\n            if campaign_id in self._active_boosts:\n                del self._active_boosts[campaign_id]\n            \n        except Exception as e:\n            logger.error(f\"Error executing manual boost: {e}\")\n            await self.db.update_campaign_progress(campaign_id, None, 'failed')\n    \n    async def _boost_single_view_manual(self, campaign: Dict[str, Any], account: Dict[str, Any]) -> bool:\n        \"\"\"Boost single view manually\"\"\"\n        try:\n            client = await self.bot_core.get_client(account['id'])\n            if not client:\n                return False\n            \n            # Check rate limits\n            if not await self.bot_core.check_rate_limit(account['id']):\n                return False\n            \n            # Get channel entity\n            channel_entity = await client.get_entity(campaign['channel_id'])\n            \n            # Boost view\n            result = await client(functions.messages.GetMessagesViewsRequest(\n                peer=channel_entity,\n                id=[campaign['message_id']],\n                increment=True\n            ))\n            \n            # Update rate limiter\n            await self.bot_core.increment_rate_limit(account['id'])\n            \n            # Log success\n            await self.db.log_view_boost(\n                campaign['id'],\n                account['id'],\n                1,\n                True,\n                None\n            )\n            \n            return True\n            \n        except Exception as e:\n            # Log failure (temporary placeholder - need to implement this method)\n            # await self.db.log_view_boost(\n            #     campaign['id'],\n            #     account['id'],\n            #     0,\n            #     False,\n            #     str(e)\n            # )\n            pass\n            logger.error(f\"Error boosting single view manually: {e}\")\n            return False\n    \n    def _estimate_duration(self, views: int) -> int:\n        \"\"\"Estimate boost duration in minutes\"\"\"\n        # Rough estimate: 1 view per 5 seconds average\n        return max(1, views * 5 // 60)\n    \n    def _get_boost_by_link_keyboard(self):\n        \"\"\"Get boost by link keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [InlineKeyboardButton(text=\"‚ùì Link Format Help\", callback_data=\"mb_help_link\")],\n            [InlineKeyboardButton(text=\"üîô Back to Manual Boost\", callback_data=\"vm_manual_boost\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_channel_selection_keyboard(self, channels: List[Dict[str, Any]]):\n        \"\"\"Get channel selection keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = []\n        \n        # Add channels (max 8)\n        for channel in channels[:8]:\n            status = \"üü¢\" if channel['is_active'] else \"üî¥\"\n            buttons.append([\n                InlineKeyboardButton(\n                    text=f\"{status} {channel['title'][:30]}\",\n                    callback_data=f\"mb_channel_{channel['id']}\"\n                )\n            ])\n        \n        # Control buttons\n        buttons.extend([\n            [InlineKeyboardButton(text=\"üîô Back to Manual Boost\", callback_data=\"vm_manual_boost\")]\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_quick_boost_keyboard(self, channels: List[Dict[str, Any]]):\n        \"\"\"Get quick boost keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = []\n        \n        # Add channels (max 6)\n        for channel in channels[:6]:\n            status = \"üü¢\" if channel['is_active'] else \"üî¥\"\n            buttons.append([\n                InlineKeyboardButton(\n                    text=f\"{status} üöÄ {channel['title'][:25]}\",\n                    callback_data=f\"mb_quick_{channel['id']}\"\n                )\n            ])\n        \n        # Control buttons\n        buttons.extend([\n            [InlineKeyboardButton(text=\"üîô Back to Manual Boost\", callback_data=\"vm_manual_boost\")]\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_posts_keyboard(self, channel_id: int, posts: List[Dict[str, Any]]):\n        \"\"\"Get posts keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = []\n        \n        # Add posts (max 3)\n        for i, post in enumerate(posts, 1):\n            post_text = post['text'][:20] + \"...\" if len(post['text']) > 20 else post['text']\n            buttons.append([\n                InlineKeyboardButton(\n                    text=f\"{i}. {post_text}\",\n                    callback_data=f\"mb_post_{channel_id}_{post['message_id']}\"\n                )\n            ])\n        \n        # Control buttons\n        buttons.extend([\n            [InlineKeyboardButton(text=\"‚öôÔ∏è Custom Parameters\", callback_data=f\"mb_custom_{channel_id}\")],\n            [InlineKeyboardButton(text=\"üîô Back to Channels\", callback_data=\"mb_select_channel\")]\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_campaigns_keyboard(self, campaigns: List[Dict[str, Any]]):\n        \"\"\"Get campaigns keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = []\n        \n        # Add campaigns (max 5)\n        for campaign in campaigns[:5]:\n            status_emoji = {\n                'active': 'üü¢',\n                'paused': '‚è∏Ô∏è',\n                'completed': '‚úÖ',\n                'failed': '‚ùå'\n            }.get(campaign['status'], '‚ö™')\n            \n            buttons.append([\n                InlineKeyboardButton(\n                    text=f\"{status_emoji} {campaign['channel_title'][:25]}\",\n                    callback_data=f\"vm_campaign_view_{campaign['id']}\"\n                )\n            ])\n        \n        # Control buttons\n        buttons.extend([\n            [InlineKeyboardButton(text=\"‚ûï New Manual Boost\", callback_data=\"vm_manual_boost\")],\n            [InlineKeyboardButton(text=\"üîô Back to Manual Boost\", callback_data=\"vm_manual_boost\")]\n        ])\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_campaign_started_keyboard(self, campaign_id: int):\n        \"\"\"Get campaign started keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [InlineKeyboardButton(text=\"üìä View Progress\", callback_data=f\"vm_campaign_view_{campaign_id}\")],\n            [InlineKeyboardButton(text=\"üëÜ New Manual Boost\", callback_data=\"vm_manual_boost\")],\n            [InlineKeyboardButton(text=\"üîô Back to View Manager\", callback_data=\"view_manager\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_help_back_keyboard(self):\n        \"\"\"Get help back keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [InlineKeyboardButton(text=\"üîô Back to Manual Boost\", callback_data=\"vm_manual_boost\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_no_channels_keyboard(self):\n        \"\"\"Get no channels keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [InlineKeyboardButton(text=\"‚ûï Add Channel\", callback_data=\"channel_management\")],\n            [InlineKeyboardButton(text=\"üîô Back to View Manager\", callback_data=\"view_manager\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_no_campaigns_keyboard(self):\n        \"\"\"Get no campaigns keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [InlineKeyboardButton(text=\"üöÄ Start First Boost\", callback_data=\"mb_quick_boost\")],\n            [InlineKeyboardButton(text=\"üîô Back to Manual Boost\", callback_data=\"vm_manual_boost\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_retry_campaign_keyboard(self):\n        \"\"\"Get retry campaign keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [InlineKeyboardButton(text=\"üîÑ Try Again\", callback_data=\"vm_manual_boost\")],\n            [InlineKeyboardButton(text=\"üîô Back to View Manager\", callback_data=\"view_manager\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_retry_quick_keyboard(self):\n        \"\"\"Get retry quick keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [InlineKeyboardButton(text=\"üîÑ Try Quick Boost Again\", callback_data=\"mb_quick_boost\")],\n            [InlineKeyboardButton(text=\"üëÜ Try Manual Boost\", callback_data=\"mb_select_channel\")],\n            [InlineKeyboardButton(text=\"üîô Back to View Manager\", callback_data=\"view_manager\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    def _get_back_to_selection_keyboard(self):\n        \"\"\"Get back to selection keyboard\"\"\"\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        \n        buttons = [\n            [InlineKeyboardButton(text=\"üîô Back to Channel Selection\", callback_data=\"mb_select_channel\")]\n        ]\n        \n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    async def shutdown(self):\n        \"\"\"Shutdown manual boost handler\"\"\"\n        try:\n            logger.info(\"‚èπÔ∏è Shutting down manual boost handler...\")\n            \n            # Cancel all active boosts\n            for campaign_id, task in self._active_boosts.items():\n                task.cancel()\n            \n            # Wait for tasks to finish\n            if self._active_boosts:\n                await asyncio.gather(*self._active_boosts.values(), return_exceptions=True)\n            \n            self._active_boosts.clear()\n            \n            logger.info(\"‚úÖ Manual boost handler shut down\")\n            \n        except Exception as e:\n            logger.error(f\"Error shutting down manual boost handler: {e}\")\n","size_bytes":38813},"features/view_manager/states/__init__.py":{"content":"\"\"\"\nView Manager States\n\"\"\"\n\nfrom .states import ViewBoostStates\n\n__all__ = ['ViewBoostStates']\n","size_bytes":96},"features/view_manager/states/states.py":{"content":"\"\"\"\nView Manager FSM States\nFinite State Machine states for view boosting operations\n\"\"\"\n\nfrom aiogram.fsm.state import State, StatesGroup\n\n\nclass ViewBoostStates(StatesGroup):\n    \"\"\"FSM states for view boosting operations\"\"\"\n    \n    # Manual boost states\n    waiting_for_message_link = State()\n    waiting_for_boost_params = State()\n    confirming_boost_start = State()\n    selecting_boost_accounts = State()\n    \n    # Auto boost setup states\n    configuring_auto_boost = State()\n    setting_auto_channels = State()\n    setting_auto_parameters = State()\n    confirming_auto_setup = State()\n    \n    # Scheduling states\n    setting_schedule_time = State()\n    setting_schedule_repeat = State()\n    configuring_schedule_params = State()\n    confirming_schedule = State()\n    \n    # Campaign management states\n    viewing_campaign_details = State()\n    editing_campaign_params = State()\n    confirming_campaign_changes = State()\n    \n    # Batch operations states\n    selecting_multiple_channels = State()\n    setting_batch_parameters = State()\n    confirming_batch_boost = State()\n    \n    # Settings configuration states\n    configuring_boost_settings = State()\n    setting_timing_preferences = State()\n    configuring_account_preferences = State()\n    setting_notification_preferences = State()\n\n\nclass AutoBoostStates(StatesGroup):\n    \"\"\"FSM states specific to auto boosting\"\"\"\n    \n    # Channel selection and configuration\n    selecting_auto_channels = State()\n    configuring_channel_settings = State()\n    setting_channel_boost_params = State()\n    \n    # Detection and monitoring settings\n    setting_detection_interval = State()\n    configuring_post_filters = State()\n    setting_boost_triggers = State()\n    \n    # Advanced auto boost settings\n    configuring_smart_timing = State()\n    setting_account_rotation = State()\n    configuring_rate_limits = State()\n    setting_retry_behavior = State()\n    \n    # Auto boost monitoring\n    reviewing_auto_performance = State()\n    adjusting_auto_parameters = State()\n\n\nclass ScheduleStates(StatesGroup):\n    \"\"\"FSM states for boost scheduling\"\"\"\n    \n    # Time and date settings\n    setting_start_time = State()\n    setting_end_time = State()\n    selecting_timezone = State()\n    setting_repeat_pattern = State()\n    \n    # Schedule configuration\n    configuring_schedule_params = State()\n    setting_schedule_channels = State()\n    setting_schedule_accounts = State()\n    \n    # Schedule management\n    viewing_schedule_calendar = State()\n    editing_scheduled_boost = State()\n    confirming_schedule_changes = State()\n    \n    # Advanced scheduling\n    setting_conditional_triggers = State()\n    configuring_peak_time_optimization = State()\n    setting_holiday_exceptions = State()\n\n\nclass CampaignStates(StatesGroup):\n    \"\"\"FSM states for campaign management\"\"\"\n    \n    # Campaign creation\n    creating_campaign = State()\n    setting_campaign_name = State()\n    configuring_campaign_targets = State()\n    setting_campaign_duration = State()\n    \n    # Campaign monitoring\n    viewing_campaign_analytics = State()\n    adjusting_campaign_parameters = State()\n    setting_campaign_alerts = State()\n    \n    # Campaign collaboration\n    sharing_campaign_access = State()\n    setting_campaign_permissions = State()\n    configuring_team_notifications = State()\n","size_bytes":3318},"features/view_manager/utils/__init__.py":{"content":"\"\"\"\nView Manager Utilities\n\"\"\"\n\nfrom .scheduler import BoostScheduler\nfrom .time_parse import TimeParser\n\n__all__ = ['BoostScheduler', 'TimeParser']\n","size_bytes":149},"features/view_manager/utils/scheduler.py":{"content":"\"\"\"\nBoost Scheduler\nHandles scheduling and timing for view boost campaigns\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime, timedelta\nimport pytz\n\nfrom core.config.config import Config\nfrom core.database.unified_database import DatabaseManager\n\nlogger = logging.getLogger(__name__)\n\n\nclass BoostScheduler:\n    \"\"\"Handles scheduling of boost campaigns\"\"\"\n    \n    def __init__(self, db_manager: DatabaseManager, config: Config):\n        self.db = db_manager\n        self.config = config\n        self._scheduler_task: Optional[asyncio.Task] = None\n        self._running = False\n        self._scheduled_campaigns: Dict[int, Dict[str, Any]] = {}\n        \n    async def initialize(self):\n        \"\"\"Initialize boost scheduler\"\"\"\n        try:\n            # Wait for database schema to be ready\n            await asyncio.sleep(12)\n            \n            # Load existing scheduled campaigns\n            await self._load_scheduled_campaigns()\n            \n            # Start scheduler task\n            self._scheduler_task = asyncio.create_task(self._scheduler_loop())\n            self._running = True\n            \n            logger.info(\"‚úÖ Boost scheduler initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize boost scheduler: {e}\")\n            raise\n    \n    async def _load_scheduled_campaigns(self):\n        \"\"\"Load scheduled campaigns from database\"\"\"\n        try:\n            scheduled = await self.db.fetch_all(\n                \"\"\"\n                SELECT id, start_time, settings\n                FROM view_boost_campaigns\n                WHERE start_time > NOW() AND status = 'scheduled'\n                ORDER BY start_time ASC\n                \"\"\"\n            )\n            \n            for campaign in scheduled:\n                self._scheduled_campaigns[campaign['id']] = {\n                    'start_time': campaign['start_time'],\n                    'settings': campaign.get('settings', {})\n                }\n            \n            logger.info(f\"‚úÖ Loaded {len(scheduled)} scheduled campaigns\")\n            \n        except Exception as e:\n            logger.error(f\"Error loading scheduled campaigns: {e}\")\n    \n    async def _scheduler_loop(self):\n        \"\"\"Main scheduler loop\"\"\"\n        while self._running:\n            try:\n                current_time = datetime.now()\n                \n                # Check for campaigns to start\n                campaigns_to_start = []\n                for campaign_id, campaign_data in self._scheduled_campaigns.items():\n                    if campaign_data['start_time'] <= current_time:\n                        campaigns_to_start.append(campaign_id)\n                \n                # Start campaigns\n                for campaign_id in campaigns_to_start:\n                    try:\n                        await self._start_scheduled_campaign(campaign_id)\n                        del self._scheduled_campaigns[campaign_id]\n                    except Exception as e:\n                        logger.error(f\"Error starting scheduled campaign {campaign_id}: {e}\")\n                \n                # Sleep for a minute before next check\n                await asyncio.sleep(60)\n                \n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Error in scheduler loop: {e}\")\n                await asyncio.sleep(30)\n    \n    async def _start_scheduled_campaign(self, campaign_id: int):\n        \"\"\"Start a scheduled campaign\"\"\"\n        try:\n            # Update campaign status to active\n            await self.db.update_campaign_progress(campaign_id, None, 'active')\n            \n            # Log the start\n            await self.db.log_system_event(\n                'INFO', 'boost_scheduler',\n                f'Started scheduled campaign: {campaign_id}',\n                {'campaign_id': campaign_id}\n            )\n            \n            logger.info(f\"‚úÖ Started scheduled campaign {campaign_id}\")\n            \n        except Exception as e:\n            logger.error(f\"Error starting scheduled campaign {campaign_id}: {e}\")\n            await self.db.update_campaign_progress(campaign_id, None, 'failed')\n    \n    async def schedule_campaign(self, campaign_id: int, start_time: datetime,\n                              settings: Dict[str, Any] = None) -> bool:\n        \"\"\"Schedule a campaign for future execution\"\"\"\n        try:\n            # Update database\n            await self.db.execute_query(\n                \"UPDATE view_boost_campaigns SET start_time = $2, status = 'scheduled', settings = $3 WHERE id = $1\",\n                campaign_id, start_time, settings or {}\n            )\n            \n            # Add to internal scheduler\n            self._scheduled_campaigns[campaign_id] = {\n                'start_time': start_time,\n                'settings': settings or {}\n            }\n            \n            logger.info(f\"‚úÖ Scheduled campaign {campaign_id} for {start_time}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error scheduling campaign {campaign_id}: {e}\")\n            return False\n    \n    async def cancel_scheduled_campaign(self, campaign_id: int) -> bool:\n        \"\"\"Cancel a scheduled campaign\"\"\"\n        try:\n            # Update database\n            await self.db.update_campaign_progress(campaign_id, None, 'cancelled')\n            \n            # Remove from scheduler\n            if campaign_id in self._scheduled_campaigns:\n                del self._scheduled_campaigns[campaign_id]\n            \n            logger.info(f\"‚úÖ Cancelled scheduled campaign {campaign_id}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error cancelling scheduled campaign {campaign_id}: {e}\")\n            return False\n    \n    async def reschedule_campaign(self, campaign_id: int, new_start_time: datetime) -> bool:\n        \"\"\"Reschedule a campaign\"\"\"\n        try:\n            # Update database\n            await self.db.execute_query(\n                \"UPDATE view_boost_campaigns SET start_time = $2 WHERE id = $1\",\n                campaign_id, new_start_time\n            )\n            \n            # Update scheduler\n            if campaign_id in self._scheduled_campaigns:\n                self._scheduled_campaigns[campaign_id]['start_time'] = new_start_time\n            \n            logger.info(f\"‚úÖ Rescheduled campaign {campaign_id} to {new_start_time}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error rescheduling campaign {campaign_id}: {e}\")\n            return False\n    \n    async def get_scheduled_campaigns(self, user_id: int = None) -> List[Dict[str, Any]]:\n        \"\"\"Get scheduled campaigns\"\"\"\n        try:\n            if user_id:\n                campaigns = await self.db.fetch_all(\n                    \"\"\"\n                    SELECT vbc.*, c.title as channel_title\n                    FROM view_boost_campaigns vbc\n                    JOIN telegram_channels c ON vbc.channel_id = c.id\n                    WHERE vbc.user_id = $1 AND vbc.status = 'scheduled'\n                    ORDER BY vbc.start_time ASC\n                    \"\"\",\n                    user_id\n                )\n            else:\n                campaigns = await self.db.fetch_all(\n                    \"\"\"\n                    SELECT vbc.*, c.title as channel_title\n                    FROM view_boost_campaigns vbc\n                    JOIN telegram_channels c ON vbc.channel_id = c.id\n                    WHERE vbc.status = 'scheduled'\n                    ORDER BY vbc.start_time ASC\n                    \"\"\"\n                )\n            \n            return campaigns\n            \n        except Exception as e:\n            logger.error(f\"Error getting scheduled campaigns: {e}\")\n            return []\n    \n    async def get_optimal_boost_times(self, channel_id: int, days: int = 7) -> List[Dict[str, Any]]:\n        \"\"\"Get optimal boost times based on historical data\"\"\"\n        try:\n            # Get historical boost performance data\n            performance_data = await self.db.fetch_all(\n                \"\"\"\n                SELECT \n                    EXTRACT(hour FROM vbl.timestamp) as hour,\n                    EXTRACT(dow FROM vbl.timestamp) as day_of_week,\n                    AVG(vbl.views_added) as avg_views,\n                    COUNT(*) as total_boosts,\n                    SUM(CASE WHEN vbl.success THEN 1 ELSE 0 END) as successful_boosts\n                FROM view_boost_logs vbl\n                JOIN view_boost_campaigns vbc ON vbl.campaign_id = vbc.id\n                WHERE vbc.channel_id = $1 \n                AND vbl.timestamp >= NOW() - INTERVAL '%s days'\n                GROUP BY hour, day_of_week\n                HAVING COUNT(*) >= 5\n                ORDER BY avg_views DESC, successful_boosts DESC\n                LIMIT 10\n                \"\"\",\n                channel_id, days\n            )\n            \n            optimal_times = []\n            for data in performance_data:\n                optimal_times.append({\n                    'hour': int(data['hour']),\n                    'day_of_week': int(data['day_of_week']),\n                    'avg_views': float(data['avg_views']),\n                    'success_rate': (data['successful_boosts'] / data['total_boosts']) * 100\n                })\n            \n            return optimal_times\n            \n        except Exception as e:\n            logger.error(f\"Error getting optimal boost times: {e}\")\n            return []\n    \n    async def suggest_next_boost_time(self, timezone: str = 'UTC') -> datetime:\n        \"\"\"Suggest optimal time for next boost\"\"\"\n        try:\n            tz = pytz.timezone(timezone)\n            now = datetime.now(tz)\n            \n            # Peak hours: typically 6-9 PM local time\n            peak_hour = 19  # 7 PM\n            \n            # Calculate next peak time\n            next_boost = now.replace(hour=peak_hour, minute=0, second=0, microsecond=0)\n            \n            # If past peak time today, schedule for tomorrow\n            if now.hour >= peak_hour:\n                next_boost += timedelta(days=1)\n            \n            return next_boost.replace(tzinfo=None)  # Remove timezone for database\n            \n        except Exception as e:\n            logger.error(f\"Error suggesting next boost time: {e}\")\n            # Fallback: next hour\n            return datetime.now() + timedelta(hours=1)\n    \n    def parse_time_expression(self, time_expr: str) -> Optional[datetime]:\n        \"\"\"Parse human-readable time expressions\"\"\"\n        try:\n            time_expr = time_expr.lower().strip()\n            now = datetime.now()\n            \n            # Handle common expressions\n            if time_expr in ['now', 'immediately']:\n                return now\n            elif time_expr in ['in 1 hour', '1 hour', '+1h']:\n                return now + timedelta(hours=1)\n            elif time_expr in ['in 2 hours', '2 hours', '+2h']:\n                return now + timedelta(hours=2)\n            elif time_expr in ['tomorrow', 'next day']:\n                return now.replace(hour=12, minute=0, second=0) + timedelta(days=1)\n            elif time_expr.startswith('in ') and time_expr.endswith(' minutes'):\n                minutes = int(time_expr.replace('in ', '').replace(' minutes', ''))\n                return now + timedelta(minutes=minutes)\n            elif time_expr.startswith('at '):\n                # Handle \"at 15:30\" format\n                time_part = time_expr.replace('at ', '')\n                if ':' in time_part:\n                    hour, minute = map(int, time_part.split(':'))\n                    target_time = now.replace(hour=hour, minute=minute, second=0)\n                    if target_time <= now:\n                        target_time += timedelta(days=1)\n                    return target_time\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error parsing time expression: {e}\")\n            return None\n    \n    async def get_scheduler_status(self) -> Dict[str, Any]:\n        \"\"\"Get scheduler status and statistics\"\"\"\n        try:\n            return {\n                'running': self._running,\n                'scheduled_campaigns': len(self._scheduled_campaigns),\n                'next_scheduled': min(\n                    (data['start_time'] for data in self._scheduled_campaigns.values()),\n                    default=None\n                )\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting scheduler status: {e}\")\n            return {'running': False, 'scheduled_campaigns': 0, 'next_scheduled': None}\n    \n    async def shutdown(self):\n        \"\"\"Shutdown scheduler\"\"\"\n        try:\n            logger.info(\"‚èπÔ∏è Shutting down boost scheduler...\")\n            \n            self._running = False\n            \n            if self._scheduler_task:\n                self._scheduler_task.cancel()\n                try:\n                    await self._scheduler_task\n                except asyncio.CancelledError:\n                    pass\n            \n            logger.info(\"‚úÖ Boost scheduler shut down\")\n            \n        except Exception as e:\n            logger.error(f\"Error shutting down scheduler: {e}\")\n","size_bytes":13346},"features/view_manager/utils/time_parse.py":{"content":"\"\"\"\nTime Parser Utility\nHandles parsing and formatting of time expressions for boost scheduling\n\"\"\"\n\nimport re\nimport logging\nfrom typing import Optional, Dict, Any, List\nfrom datetime import datetime, timedelta\nimport pytz\n\nlogger = logging.getLogger(__name__)\n\n\nclass TimeParser:\n    \"\"\"Utility for parsing time expressions and scheduling\"\"\"\n    \n    def __init__(self):\n        self.timezone_map = {\n            'utc': 'UTC',\n            'est': 'America/New_York',\n            'pst': 'America/Los_Angeles',\n            'cet': 'Europe/Berlin',\n            'gmt': 'GMT',\n            'msk': 'Europe/Moscow'\n        }\n        \n        self.time_units = {\n            'seconds': 1,\n            'minutes': 60,\n            'hours': 3600,\n            'days': 86400,\n            'weeks': 604800\n        }\n    \n    def parse_time_expression(self, expression: str, user_timezone: str = 'UTC') -> Optional[datetime]:\n        \"\"\"Parse various time expressions into datetime objects\"\"\"\n        try:\n            expr = expression.lower().strip()\n            now = datetime.now()\n            \n            # Immediate execution\n            if expr in ['now', 'immediately', 'asap']:\n                return now\n            \n            # Relative time expressions\n            if expr.startswith('in '):\n                return self._parse_relative_time(expr, now)\n            \n            # Specific time today\n            if expr.startswith('at '):\n                return self._parse_specific_time(expr, now)\n            \n            # Named times\n            if expr in ['tomorrow', 'next day']:\n                return now.replace(hour=12, minute=0, second=0, microsecond=0) + timedelta(days=1)\n            \n            if expr in ['tonight', 'this evening']:\n                return now.replace(hour=20, minute=0, second=0, microsecond=0)\n            \n            if expr in ['morning', 'tomorrow morning']:\n                days_add = 1 if 'tomorrow' in expr or now.hour > 10 else 0\n                return now.replace(hour=9, minute=0, second=0, microsecond=0) + timedelta(days=days_add)\n            \n            # Day of week\n            weekday_result = self._parse_weekday(expr, now)\n            if weekday_result:\n                return weekday_result\n            \n            # Date formats\n            date_result = self._parse_date_format(expr, user_timezone)\n            if date_result:\n                return date_result\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error parsing time expression '{expression}': {e}\")\n            return None\n    \n    def _parse_relative_time(self, expr: str, base_time: datetime) -> Optional[datetime]:\n        \"\"\"Parse relative time expressions like 'in 2 hours'\"\"\"\n        try:\n            # Remove 'in ' prefix\n            time_part = expr[3:].strip()\n            \n            # Match patterns like \"2 hours\", \"30 minutes\", \"1 day\"\n            pattern = r'(\\d+)\\s*(second|minute|hour|day|week)s?'\n            match = re.match(pattern, time_part)\n            \n            if match:\n                amount = int(match.group(1))\n                unit = match.group(2) + 's'  # Normalize to plural\n                \n                if unit in self.time_units:\n                    seconds_to_add = amount * self.time_units[unit]\n                    return base_time + timedelta(seconds=seconds_to_add)\n            \n            # Handle compound expressions like \"1 hour 30 minutes\"\n            compound_pattern = r'(\\d+)\\s*hours?\\s*(\\d+)\\s*minutes?'\n            compound_match = re.match(compound_pattern, time_part)\n            \n            if compound_match:\n                hours = int(compound_match.group(1))\n                minutes = int(compound_match.group(2))\n                return base_time + timedelta(hours=hours, minutes=minutes)\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error parsing relative time '{expr}': {e}\")\n            return None\n    \n    def _parse_specific_time(self, expr: str, base_time: datetime) -> Optional[datetime]:\n        \"\"\"Parse specific time expressions like 'at 15:30'\"\"\"\n        try:\n            # Remove 'at ' prefix\n            time_part = expr[3:].strip()\n            \n            # Match HH:MM format\n            time_pattern = r'(\\d{1,2}):(\\d{2})'\n            match = re.match(time_pattern, time_part)\n            \n            if match:\n                hour = int(match.group(1))\n                minute = int(match.group(2))\n                \n                if 0 <= hour <= 23 and 0 <= minute <= 59:\n                    target_time = base_time.replace(hour=hour, minute=minute, second=0, microsecond=0)\n                    \n                    # If the time has passed today, schedule for tomorrow\n                    if target_time <= base_time:\n                        target_time += timedelta(days=1)\n                    \n                    return target_time\n            \n            # Match 12-hour format with AM/PM\n            ampm_pattern = r'(\\d{1,2}):?(\\d{2})?\\s*(am|pm)'\n            ampm_match = re.match(ampm_pattern, time_part)\n            \n            if ampm_match:\n                hour = int(ampm_match.group(1))\n                minute = int(ampm_match.group(2)) if ampm_match.group(2) else 0\n                ampm = ampm_match.group(3)\n                \n                # Convert to 24-hour format\n                if ampm == 'pm' and hour != 12:\n                    hour += 12\n                elif ampm == 'am' and hour == 12:\n                    hour = 0\n                \n                if 0 <= hour <= 23 and 0 <= minute <= 59:\n                    target_time = base_time.replace(hour=hour, minute=minute, second=0, microsecond=0)\n                    \n                    if target_time <= base_time:\n                        target_time += timedelta(days=1)\n                    \n                    return target_time\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error parsing specific time '{expr}': {e}\")\n            return None\n    \n    def _parse_weekday(self, expr: str, base_time: datetime) -> Optional[datetime]:\n        \"\"\"Parse weekday expressions like 'monday', 'next friday'\"\"\"\n        try:\n            weekdays = {\n                'monday': 0, 'tuesday': 1, 'wednesday': 2, 'thursday': 3,\n                'friday': 4, 'saturday': 5, 'sunday': 6\n            }\n            \n            # Handle \"next [weekday]\" or just \"[weekday]\"\n            next_prefix = expr.startswith('next ')\n            weekday_name = expr.replace('next ', '').strip()\n            \n            if weekday_name in weekdays:\n                target_weekday = weekdays[weekday_name]\n                current_weekday = base_time.weekday()\n                \n                days_ahead = target_weekday - current_weekday\n                \n                # If it's the same day but later in the day, or \"next\" is specified\n                if days_ahead <= 0 or next_prefix:\n                    days_ahead += 7\n                \n                target_date = base_time + timedelta(days=days_ahead)\n                return target_date.replace(hour=12, minute=0, second=0, microsecond=0)\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error parsing weekday '{expr}': {e}\")\n            return None\n    \n    def _parse_date_format(self, expr: str, user_timezone: str) -> Optional[datetime]:\n        \"\"\"Parse date formats like '2024-01-15 14:30'\"\"\"\n        try:\n            # ISO format: YYYY-MM-DD HH:MM\n            iso_pattern = r'(\\d{4})-(\\d{2})-(\\d{2})\\s+(\\d{1,2}):(\\d{2})'\n            iso_match = re.match(iso_pattern, expr)\n            \n            if iso_match:\n                year = int(iso_match.group(1))\n                month = int(iso_match.group(2))\n                day = int(iso_match.group(3))\n                hour = int(iso_match.group(4))\n                minute = int(iso_match.group(5))\n                \n                return datetime(year, month, day, hour, minute)\n            \n            # Date only: YYYY-MM-DD (default to noon)\n            date_pattern = r'(\\d{4})-(\\d{2})-(\\d{2})$'\n            date_match = re.match(date_pattern, expr)\n            \n            if date_match:\n                year = int(date_match.group(1))\n                month = int(date_match.group(2))\n                day = int(date_match.group(3))\n                \n                return datetime(year, month, day, 12, 0)\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error parsing date format '{expr}': {e}\")\n            return None\n    \n    def format_duration(self, start_time: datetime, end_time: datetime) -> str:\n        \"\"\"Format duration between two times in human-readable format\"\"\"\n        try:\n            delta = end_time - start_time\n            \n            if delta.days > 0:\n                return f\"{delta.days} day{'s' if delta.days != 1 else ''}\"\n            \n            hours = delta.seconds // 3600\n            minutes = (delta.seconds % 3600) // 60\n            \n            if hours > 0:\n                if minutes > 0:\n                    return f\"{hours}h {minutes}m\"\n                else:\n                    return f\"{hours} hour{'s' if hours != 1 else ''}\"\n            elif minutes > 0:\n                return f\"{minutes} minute{'s' if minutes != 1 else ''}\"\n            else:\n                return \"less than a minute\"\n                \n        except Exception as e:\n            logger.error(f\"Error formatting duration: {e}\")\n            return \"unknown duration\"\n    \n    def format_time_until(self, target_time: datetime) -> str:\n        \"\"\"Format time remaining until target time\"\"\"\n        try:\n            now = datetime.now()\n            \n            if target_time <= now:\n                return \"now\"\n            \n            return self.format_duration(now, target_time)\n            \n        except Exception as e:\n            logger.error(f\"Error formatting time until: {e}\")\n            return \"unknown\"\n    \n    def get_timezone_offset(self, timezone_name: str) -> str:\n        \"\"\"Get timezone offset string\"\"\"\n        try:\n            # Map common abbreviations\n            tz_name = self.timezone_map.get(timezone_name.lower(), timezone_name)\n            \n            tz = pytz.timezone(tz_name)\n            now = datetime.now(tz)\n            offset = now.strftime('%z')\n            \n            # Format as +HH:MM\n            if len(offset) == 5:\n                return f\"{offset[:3]}:{offset[3:]}\"\n            \n            return offset\n            \n        except Exception as e:\n            logger.error(f\"Error getting timezone offset for '{timezone_name}': {e}\")\n            return \"+00:00\"\n    \n    def validate_time_expression(self, expression: str) -> Dict[str, Any]:\n        \"\"\"Validate a time expression and return parsed result with validation info\"\"\"\n        try:\n            parsed_time = self.parse_time_expression(expression)\n            \n            if parsed_time is None:\n                return {\n                    'valid': False,\n                    'error': 'Unable to parse time expression',\n                    'suggestions': self._get_format_suggestions()\n                }\n            \n            # Check if time is in the past\n            if parsed_time <= datetime.now():\n                return {\n                    'valid': False,\n                    'error': 'Time must be in the future',\n                    'parsed_time': parsed_time\n                }\n            \n            # Check if time is too far in the future (e.g., more than 1 year)\n            if parsed_time > datetime.now() + timedelta(days=365):\n                return {\n                    'valid': False,\n                    'error': 'Time cannot be more than 1 year in the future',\n                    'parsed_time': parsed_time\n                }\n            \n            return {\n                'valid': True,\n                'parsed_time': parsed_time,\n                'formatted': parsed_time.strftime('%Y-%m-%d %H:%M:%S'),\n                'time_until': self.format_time_until(parsed_time)\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error validating time expression '{expression}': {e}\")\n            return {\n                'valid': False,\n                'error': f'Validation error: {str(e)}',\n                'suggestions': self._get_format_suggestions()\n            }\n    \n    def _get_format_suggestions(self) -> List[str]:\n        \"\"\"Get list of supported time format suggestions\"\"\"\n        return [\n            \"now, immediately\",\n            \"in 30 minutes, in 2 hours, in 1 day\",\n            \"at 15:30, at 9:00 pm\",\n            \"tomorrow, tonight, tomorrow morning\",\n            \"monday, next friday\",\n            \"2024-01-15 14:30\"\n        ]\n    \n    def get_peak_hours(self, timezone: str = 'UTC') -> List[Dict[str, Any]]:\n        \"\"\"Get typical peak hours for content engagement\"\"\"\n        try:\n            # General peak hours for different regions\n            peak_periods = [\n                {'start': 8, 'end': 10, 'description': 'Morning commute'},\n                {'start': 12, 'end': 14, 'description': 'Lunch break'},\n                {'start': 17, 'end': 21, 'description': 'Evening prime time'}\n            ]\n            \n            return peak_periods\n            \n        except Exception as e:\n            logger.error(f\"Error getting peak hours: {e}\")\n            return []\n    \n    def suggest_optimal_times(self, count: int = 3) -> List[Dict[str, Any]]:\n        \"\"\"Suggest optimal times for boosting based on general best practices\"\"\"\n        try:\n            now = datetime.now()\n            suggestions = []\n            \n            # Next peak hour today or tomorrow\n            peak_hours = [9, 13, 19]  # 9 AM, 1 PM, 7 PM\n            \n            for hour in peak_hours:\n                target_time = now.replace(hour=hour, minute=0, second=0, microsecond=0)\n                \n                # If past this hour today, schedule for tomorrow\n                if target_time <= now:\n                    target_time += timedelta(days=1)\n                \n                suggestions.append({\n                    'time': target_time,\n                    'formatted': target_time.strftime('%Y-%m-%d %H:%M'),\n                    'description': f\"Peak hour ({hour}:00)\",\n                    'time_until': self.format_time_until(target_time)\n                })\n                \n                if len(suggestions) >= count:\n                    break\n            \n            return suggestions\n            \n        except Exception as e:\n            logger.error(f\"Error suggesting optimal times: {e}\")\n            return []\n","size_bytes":14812},"core/utils/__init__.py":{"content":"\"\"\"\nHigh-Performance Utility Modules\nComprehensive performance optimization suite\n\"\"\"\n\nfrom .http_client import http_client, OptimizedHTTPClient\nfrom .cache_manager import cache, CacheManager, cached\nfrom .request_batcher import request_batcher, RequestBatcher, Priority, BatchRequest\nfrom .circuit_breaker import CircuitBreaker, telegram_api_breaker, database_breaker, external_api_breaker\nfrom .performance_monitor import performance_monitor, PerformanceMonitor\n\n__all__ = [\n    'http_client',\n    'OptimizedHTTPClient', \n    'cache',\n    'CacheManager',\n    'cached',\n    'request_batcher',\n    'RequestBatcher',\n    'Priority',\n    'BatchRequest',\n    'CircuitBreaker',\n    'telegram_api_breaker',\n    'database_breaker', \n    'external_api_breaker',\n    'performance_monitor',\n    'PerformanceMonitor'\n]","size_bytes":808},"core/utils/cache_manager.py":{"content":"\"\"\"\nSmart Caching Layer for Faster API Responses\nReduces redundant API calls and speeds up operations\n\"\"\"\n\nimport asyncio\nimport time\nimport json\nimport logging\nfrom typing import Dict, Any, Optional, Callable\nfrom functools import wraps\nfrom datetime import datetime, timedelta\n\nlogger = logging.getLogger(__name__)\n\n\nclass CacheManager:\n    \"\"\"High-performance caching system for API responses\"\"\"\n    \n    def __init__(self):\n        self._cache: Dict[str, Dict[str, Any]] = {}\n        self._ttl_cache: Dict[str, float] = {}\n        self._hit_count = 0\n        self._miss_count = 0\n        \n    def _is_expired(self, key: str) -> bool:\n        \"\"\"Check if cache entry is expired\"\"\"\n        if key not in self._ttl_cache:\n            return True\n        return time.time() > self._ttl_cache[key]\n    \n    def get(self, key: str) -> Optional[Any]:\n        \"\"\"Get value from cache\"\"\"\n        if key in self._cache and not self._is_expired(key):\n            self._hit_count += 1\n            return self._cache[key]['data']\n        self._miss_count += 1\n        return None\n    \n    def set(self, key: str, value: Any, ttl: int = 300) -> None:\n        \"\"\"Set value in cache with TTL (seconds)\"\"\"\n        self._cache[key] = {\n            'data': value,\n            'created_at': time.time()\n        }\n        self._ttl_cache[key] = time.time() + ttl\n    \n    def delete(self, key: str) -> None:\n        \"\"\"Delete key from cache\"\"\"\n        self._cache.pop(key, None)\n        self._ttl_cache.pop(key, None)\n    \n    def clear(self) -> None:\n        \"\"\"Clear all cache\"\"\"\n        self._cache.clear()\n        self._ttl_cache.clear()\n    \n    def cleanup_expired(self) -> int:\n        \"\"\"Remove expired entries\"\"\"\n        current_time = time.time()\n        expired_keys = [\n            key for key, expiry in self._ttl_cache.items()\n            if current_time > expiry\n        ]\n        \n        for key in expired_keys:\n            self.delete(key)\n        \n        return len(expired_keys)\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get cache statistics\"\"\"\n        total_requests = self._hit_count + self._miss_count\n        hit_rate = (self._hit_count / total_requests * 100) if total_requests > 0 else 0\n        \n        return {\n            'total_entries': len(self._cache),\n            'hit_count': self._hit_count,\n            'miss_count': self._miss_count,\n            'hit_rate': f\"{hit_rate:.1f}%\",\n            'memory_usage': len(str(self._cache))\n        }\n\n\ndef cached(ttl: int = 300, key_prefix: str = \"\"):\n    \"\"\"Decorator for caching function results\"\"\"\n    def decorator(func: Callable):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            # Generate cache key\n            cache_key = f\"{key_prefix}:{func.__name__}:{hash(str(args) + str(kwargs))}\"\n            \n            # Try to get from cache\n            cached_result = cache.get(cache_key)\n            if cached_result is not None:\n                return cached_result\n            \n            # Execute function and cache result\n            result = await func(*args, **kwargs)\n            cache.set(cache_key, result, ttl)\n            return result\n        return wrapper\n    return decorator\n\n\n# Global cache instance\ncache = CacheManager()\n\n\n# Pre-configured cache decorators for common use cases\n@cached(ttl=600, key_prefix=\"channel\")\nasync def cache_channel_info():\n    \"\"\"Cache channel information for 10 minutes\"\"\"\n    pass\n\n@cached(ttl=300, key_prefix=\"account\")  \nasync def cache_account_info():\n    \"\"\"Cache account information for 5 minutes\"\"\"\n    pass\n\n@cached(ttl=120, key_prefix=\"api\")\nasync def cache_api_response():\n    \"\"\"Cache API responses for 2 minutes\"\"\"\n    pass","size_bytes":3694},"core/utils/circuit_breaker.py":{"content":"\"\"\"\nCircuit Breaker Pattern for API Reliability\nPrevents cascade failures and improves overall system performance\n\"\"\"\n\nimport asyncio\nimport time\nimport logging\nfrom typing import Callable, Any, Dict\nfrom enum import Enum\nfrom dataclasses import dataclass\n\nlogger = logging.getLogger(__name__)\n\n\nclass CircuitState(Enum):\n    \"\"\"Circuit breaker states\"\"\"\n    CLOSED = \"closed\"        # Normal operation\n    OPEN = \"open\"           # Failing, reject calls\n    HALF_OPEN = \"half_open\" # Testing if service recovered\n\n\n@dataclass\nclass CircuitBreakerConfig:\n    \"\"\"Circuit breaker configuration\"\"\"\n    failure_threshold: int = 5        # Failures before opening\n    recovery_timeout: int = 60        # Seconds before trying again\n    expected_exception: type = Exception\n    \n\nclass CircuitBreaker:\n    \"\"\"High-performance circuit breaker for API calls\"\"\"\n    \n    def __init__(self, config: CircuitBreakerConfig):\n        self.config = config\n        self.state = CircuitState.CLOSED\n        self.failure_count = 0\n        self.last_failure_time = None\n        self.success_count = 0\n        \n    async def call(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"Execute function with circuit breaker protection\"\"\"\n        \n        # Check if circuit should be closed\n        if self.state == CircuitState.OPEN:\n            if self._should_attempt_reset():\n                self.state = CircuitState.HALF_OPEN\n                logger.info(\"Circuit breaker: Attempting reset (HALF_OPEN)\")\n            else:\n                raise Exception(f\"Circuit breaker OPEN - Service unavailable\")\n        \n        try:\n            # Execute the function\n            result = await func(*args, **kwargs)\n            \n            # Success - reset failure count\n            self._on_success()\n            return result\n            \n        except self.config.expected_exception as e:\n            # Failure - increment counter\n            self._on_failure()\n            raise e\n    \n    def _should_attempt_reset(self) -> bool:\n        \"\"\"Check if enough time has passed to attempt reset\"\"\"\n        if self.last_failure_time is None:\n            return True\n        return time.time() - self.last_failure_time >= self.config.recovery_timeout\n    \n    def _on_success(self):\n        \"\"\"Handle successful call\"\"\"\n        if self.state == CircuitState.HALF_OPEN:\n            # Reset to normal operation\n            self.state = CircuitState.CLOSED\n            self.failure_count = 0\n            logger.info(\"Circuit breaker: Service recovered (CLOSED)\")\n        self.success_count += 1\n    \n    def _on_failure(self):\n        \"\"\"Handle failed call\"\"\"\n        self.failure_count += 1\n        self.last_failure_time = time.time()\n        \n        if (self.state == CircuitState.CLOSED and \n            self.failure_count >= self.config.failure_threshold):\n            self.state = CircuitState.OPEN\n            logger.warning(f\"Circuit breaker: Too many failures, opening circuit (OPEN)\")\n        \n        elif self.state == CircuitState.HALF_OPEN:\n            self.state = CircuitState.OPEN\n            logger.warning(\"Circuit breaker: Half-open test failed, reopening circuit\")\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get circuit breaker statistics\"\"\"\n        return {\n            'state': self.state.value,\n            'failure_count': self.failure_count,\n            'success_count': self.success_count,\n            'last_failure_time': self.last_failure_time,\n            'is_available': self.state != CircuitState.OPEN\n        }\n\n\n# Pre-configured circuit breakers for common services\ntelegram_api_breaker = CircuitBreaker(CircuitBreakerConfig(\n    failure_threshold=3,\n    recovery_timeout=30,\n    expected_exception=Exception\n))\n\ndatabase_breaker = CircuitBreaker(CircuitBreakerConfig(\n    failure_threshold=5,\n    recovery_timeout=60,\n    expected_exception=Exception\n))\n\nexternal_api_breaker = CircuitBreaker(CircuitBreakerConfig(\n    failure_threshold=2,\n    recovery_timeout=45,\n    expected_exception=Exception\n))","size_bytes":4028},"core/utils/http_client.py":{"content":"\"\"\"\nOptimized HTTP Client with Connection Pooling\nHigh-performance HTTP client for faster API requests\n\"\"\"\n\nimport asyncio\nimport httpx\nimport logging\nfrom typing import Dict, Any, Optional, List\nfrom contextlib import asynccontextmanager\n\nlogger = logging.getLogger(__name__)\n\n\nclass OptimizedHTTPClient:\n    \"\"\"High-performance HTTP client with connection pooling and optimizations\"\"\"\n    \n    def __init__(self):\n        self.client: Optional[httpx.AsyncClient] = None\n        self._session_cache: Dict[str, httpx.AsyncClient] = {}\n        \n    async def initialize(self):\n        \"\"\"Initialize optimized HTTP client\"\"\"\n        # Connection limits for optimal performance\n        limits = httpx.Limits(\n            max_keepalive_connections=100,  # Keep connections alive\n            max_connections=200,            # Total connection pool\n            keepalive_expiry=300           # 5 minutes keep-alive\n        )\n        \n        # Timeout configuration\n        timeout = httpx.Timeout(\n            connect=10.0,    # Connection timeout\n            read=30.0,       # Read timeout  \n            write=10.0,      # Write timeout\n            pool=10.0        # Pool acquisition timeout\n        )\n        \n        # Create optimized client\n        self.client = httpx.AsyncClient(\n            limits=limits,\n            timeout=timeout,\n            http2=True,                    # Enable HTTP/2 for speed\n            follow_redirects=True,         # Handle redirects automatically\n            verify=True                    # SSL verification\n        )\n        \n        logger.info(\"‚úÖ Optimized HTTP client initialized\")\n    \n    async def get(self, url: str, **kwargs) -> httpx.Response:\n        \"\"\"Optimized GET request\"\"\"\n        if not self.client:\n            await self.initialize()\n        return await self.client.get(url, **kwargs)\n    \n    async def post(self, url: str, **kwargs) -> httpx.Response:\n        \"\"\"Optimized POST request\"\"\"\n        if not self.client:\n            await self.initialize()\n        return await self.client.post(url, **kwargs)\n    \n    async def batch_requests(self, requests: List[Dict[str, Any]]) -> List[httpx.Response]:\n        \"\"\"Execute multiple HTTP requests concurrently\"\"\"\n        if not self.client:\n            await self.initialize()\n            \n        async def make_request(req):\n            method = req.get('method', 'GET').upper()\n            if method == 'GET':\n                return await self.client.get(req['url'], **req.get('kwargs', {}))\n            elif method == 'POST':\n                return await self.client.post(req['url'], **req.get('kwargs', {}))\n            \n        # Execute all requests concurrently\n        tasks = [make_request(req) for req in requests]\n        return await asyncio.gather(*tasks, return_exceptions=True)\n    \n    async def close(self):\n        \"\"\"Close HTTP client and cleanup connections\"\"\"\n        if self.client:\n            await self.client.aclose()\n        for client in self._session_cache.values():\n            await client.aclose()\n\n\n# Global optimized HTTP client instance\nhttp_client = OptimizedHTTPClient()","size_bytes":3120},"core/utils/performance_monitor.py":{"content":"\"\"\"\nReal-time Performance Monitoring\nTracks and optimizes bot performance metrics\n\"\"\"\n\nimport asyncio\nimport psutil\nimport time\nimport logging\nfrom typing import Dict, Any, List\nfrom datetime import datetime, timedelta\nfrom dataclasses import dataclass\nfrom collections import deque\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass PerformanceMetric:\n    \"\"\"Performance metric data point\"\"\"\n    timestamp: datetime\n    value: float\n    metric_type: str\n\n\nclass PerformanceMonitor:\n    \"\"\"Real-time performance monitoring and optimization\"\"\"\n    \n    def __init__(self, history_size: int = 1000):\n        self.history_size = history_size\n        self._metrics: Dict[str, deque] = {}\n        self._start_time = time.time()\n        self._request_times: deque = deque(maxlen=1000)\n        self._active_requests = 0\n        self._total_requests = 0\n        self._failed_requests = 0\n        \n    def record_metric(self, metric_type: str, value: float):\n        \"\"\"Record a performance metric\"\"\"\n        if metric_type not in self._metrics:\n            self._metrics[metric_type] = deque(maxlen=self.history_size)\n        \n        metric = PerformanceMetric(\n            timestamp=datetime.now(),\n            value=value,\n            metric_type=metric_type\n        )\n        self._metrics[metric_type].append(metric)\n    \n    def start_request(self) -> float:\n        \"\"\"Start timing a request\"\"\"\n        self._active_requests += 1\n        self._total_requests += 1\n        return time.time()\n    \n    def end_request(self, start_time: float, success: bool = True):\n        \"\"\"End timing a request\"\"\"\n        duration = time.time() - start_time\n        self._request_times.append(duration)\n        self._active_requests = max(0, self._active_requests - 1)\n        \n        if not success:\n            self._failed_requests += 1\n        \n        # Record response time metric\n        self.record_metric('response_time', duration)\n    \n    def get_system_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get current system performance metrics\"\"\"\n        # CPU and Memory\n        cpu_percent = psutil.cpu_percent(interval=0.1)\n        memory = psutil.virtual_memory()\n        \n        # Network I/O\n        network = psutil.net_io_counters()\n        \n        # Disk I/O\n        disk = psutil.disk_io_counters()\n        \n        return {\n            'cpu_percent': cpu_percent,\n            'memory_percent': memory.percent,\n            'memory_used_mb': memory.used / (1024 * 1024),\n            'memory_available_mb': memory.available / (1024 * 1024),\n            'network_bytes_sent': network.bytes_sent,\n            'network_bytes_recv': network.bytes_recv,\n            'disk_read_bytes': disk.read_bytes if disk else 0,\n            'disk_write_bytes': disk.write_bytes if disk else 0,\n        }\n    \n    def get_request_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get request performance metrics\"\"\"\n        if not self._request_times:\n            return {\n                'avg_response_time': 0,\n                'min_response_time': 0,\n                'max_response_time': 0,\n                'p95_response_time': 0,\n                'requests_per_second': 0,\n                'active_requests': self._active_requests,\n                'total_requests': self._total_requests,\n                'failed_requests': self._failed_requests,\n                'success_rate': 100.0\n            }\n        \n        # Calculate statistics\n        times = list(self._request_times)\n        times.sort()\n        \n        avg_time = sum(times) / len(times)\n        min_time = min(times)\n        max_time = max(times)\n        p95_time = times[int(len(times) * 0.95)] if times else 0\n        \n        # Calculate RPS\n        uptime = time.time() - self._start_time\n        rps = self._total_requests / uptime if uptime > 0 else 0\n        \n        # Calculate success rate\n        success_rate = ((self._total_requests - self._failed_requests) / \n                       self._total_requests * 100) if self._total_requests > 0 else 100\n        \n        return {\n            'avg_response_time': avg_time,\n            'min_response_time': min_time,\n            'max_response_time': max_time,\n            'p95_response_time': p95_time,\n            'requests_per_second': rps,\n            'active_requests': self._active_requests,\n            'total_requests': self._total_requests,\n            'failed_requests': self._failed_requests,\n            'success_rate': success_rate\n        }\n    \n    def get_optimization_suggestions(self) -> List[str]:\n        \"\"\"Get performance optimization suggestions\"\"\"\n        suggestions = []\n        \n        system_metrics = self.get_system_metrics()\n        request_metrics = self.get_request_metrics()\n        \n        # CPU suggestions\n        if system_metrics['cpu_percent'] > 80:\n            suggestions.append(\"üî• High CPU usage - Consider reducing concurrent operations\")\n        \n        # Memory suggestions  \n        if system_metrics['memory_percent'] > 85:\n            suggestions.append(\"üíæ High memory usage - Consider implementing cache cleanup\")\n        \n        # Response time suggestions\n        if request_metrics['avg_response_time'] > 2.0:\n            suggestions.append(\"‚è±Ô∏è Slow response times - Enable HTTP connection pooling\")\n        \n        # Request rate suggestions\n        if request_metrics['requests_per_second'] < 5:\n            suggestions.append(\"‚ö° Low request rate - Increase batch sizes\")\n        \n        # Success rate suggestions\n        if request_metrics['success_rate'] < 95:\n            suggestions.append(\"‚ùå High failure rate - Implement circuit breakers\")\n        \n        # Active requests suggestions\n        if request_metrics['active_requests'] > 50:\n            suggestions.append(\"üîÑ Too many concurrent requests - Add request queuing\")\n        \n        return suggestions\n    \n    def get_comprehensive_report(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive performance report\"\"\"\n        return {\n            'system_metrics': self.get_system_metrics(),\n            'request_metrics': self.get_request_metrics(),\n            'optimization_suggestions': self.get_optimization_suggestions(),\n            'uptime_seconds': time.time() - self._start_time,\n            'monitoring_active': True\n        }\n\n\n# Global performance monitor instance\nperformance_monitor = PerformanceMonitor()","size_bytes":6366},"core/utils/request_batcher.py":{"content":"\"\"\"\nRequest Batching System for Optimal API Performance\nCombines multiple API requests for maximum efficiency\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, List, Any, Callable, Optional\nfrom datetime import datetime\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nlogger = logging.getLogger(__name__)\n\n\nclass Priority(Enum):\n    \"\"\"Request priority levels\"\"\"\n    LOW = 1\n    NORMAL = 2\n    HIGH = 3\n    URGENT = 4\n\n\n@dataclass\nclass BatchRequest:\n    \"\"\"Represents a batched request\"\"\"\n    id: str\n    operation: str\n    params: Dict[str, Any]\n    priority: Priority\n    callback: Optional[Callable] = None\n    created_at: datetime = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n\n\nclass RequestBatcher:\n    \"\"\"High-performance request batching system\"\"\"\n    \n    def __init__(self, batch_size: int = 20, flush_interval: float = 2.0):\n        self.batch_size = batch_size\n        self.flush_interval = flush_interval\n        self._queues: Dict[Priority, List[BatchRequest]] = {\n            Priority.URGENT: [],\n            Priority.HIGH: [],\n            Priority.NORMAL: [],\n            Priority.LOW: []\n        }\n        self._processors: Dict[str, Callable] = {}\n        self._running = False\n        self._batch_task: Optional[asyncio.Task] = None\n        \n    async def start(self):\n        \"\"\"Start the batching system\"\"\"\n        self._running = True\n        self._batch_task = asyncio.create_task(self._batch_processor())\n        logger.info(\"‚úÖ Request batcher started\")\n    \n    async def stop(self):\n        \"\"\"Stop the batching system\"\"\"\n        self._running = False\n        if self._batch_task:\n            self._batch_task.cancel()\n            try:\n                await self._batch_task\n            except asyncio.CancelledError:\n                pass\n        logger.info(\"‚úÖ Request batcher stopped\")\n    \n    def register_processor(self, operation: str, processor: Callable):\n        \"\"\"Register a processor for an operation type\"\"\"\n        self._processors[operation] = processor\n        logger.info(f\"‚úÖ Registered processor for operation: {operation}\")\n    \n    async def add_request(self, request: BatchRequest) -> str:\n        \"\"\"Add a request to the batch queue\"\"\"\n        self._queues[request.priority].append(request)\n        \n        # Force flush if urgent or high priority batch is full\n        if (request.priority in [Priority.URGENT, Priority.HIGH] and \n            len(self._queues[request.priority]) >= self.batch_size // 2):\n            await self._flush_priority_queue(request.priority)\n        \n        return request.id\n    \n    async def _batch_processor(self):\n        \"\"\"Main batch processing loop\"\"\"\n        while self._running:\n            try:\n                # Process all priority queues\n                for priority in [Priority.URGENT, Priority.HIGH, Priority.NORMAL, Priority.LOW]:\n                    if self._queues[priority]:\n                        await self._flush_priority_queue(priority)\n                \n                await asyncio.sleep(self.flush_interval)\n                \n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Error in batch processor: {e}\")\n                await asyncio.sleep(1)\n    \n    async def _flush_priority_queue(self, priority: Priority):\n        \"\"\"Flush a specific priority queue\"\"\"\n        queue = self._queues[priority]\n        if not queue:\n            return\n        \n        # Group requests by operation type\n        operation_groups = {}\n        for request in queue:\n            if request.operation not in operation_groups:\n                operation_groups[request.operation] = []\n            operation_groups[request.operation].append(request)\n        \n        # Process each operation group in parallel\n        tasks = []\n        for operation, requests in operation_groups.items():\n            if operation in self._processors:\n                # Split into smaller batches\n                for i in range(0, len(requests), self.batch_size):\n                    batch = requests[i:i + self.batch_size]\n                    task = asyncio.create_task(\n                        self._process_batch(operation, batch)\n                    )\n                    tasks.append(task)\n        \n        # Execute all batches in parallel\n        if tasks:\n            await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Clear the queue\n        queue.clear()\n    \n    async def _process_batch(self, operation: str, requests: List[BatchRequest]):\n        \"\"\"Process a batch of requests\"\"\"\n        try:\n            processor = self._processors[operation]\n            \n            # Extract parameters for batch processing\n            batch_params = [req.params for req in requests]\n            \n            # Execute batch operation\n            results = await processor(batch_params)\n            \n            # Execute callbacks if provided\n            for i, request in enumerate(requests):\n                if request.callback and i < len(results):\n                    try:\n                        await request.callback(results[i])\n                    except Exception as e:\n                        logger.error(f\"Error in callback for request {request.id}: {e}\")\n            \n            logger.debug(f\"‚úÖ Processed batch of {len(requests)} {operation} requests\")\n            \n        except Exception as e:\n            logger.error(f\"Error processing {operation} batch: {e}\")\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get batching statistics\"\"\"\n        total_queued = sum(len(queue) for queue in self._queues.values())\n        \n        return {\n            'total_queued': total_queued,\n            'urgent_queue': len(self._queues[Priority.URGENT]),\n            'high_queue': len(self._queues[Priority.HIGH]),\n            'normal_queue': len(self._queues[Priority.NORMAL]),\n            'low_queue': len(self._queues[Priority.LOW]),\n            'registered_processors': len(self._processors),\n            'running': self._running\n        }\n\n\n# Global batcher instance\nrequest_batcher = RequestBatcher()","size_bytes":6204},"features/poll_manager/__init__.py":{"content":"\"\"\"Poll Manager feature module\"\"\"\n\nfrom .handler import PollManagerHandler\n\n__all__ = ['PollManagerHandler']\n","size_bytes":109},"features/poll_manager/handler.py":{"content":"\"\"\"\nPoll Manager Handler - Simplified Version\nAutomated poll voting with multiple Telegram accounts\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, Any, Optional\nfrom datetime import datetime\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton\nfrom aiogram.fsm.context import FSMContext\n\nfrom core.database.unified_database import DatabaseManager\nfrom core.config.config import Config\n\nlogger = logging.getLogger(__name__)\n\nclass PollManagerHandler:\n    \"\"\"Simplified Poll Manager Handler\"\"\"\n    \n    def __init__(self, bot: Bot, db_manager: DatabaseManager, config: Config, bot_core=None):\n        self.bot = bot\n        self.db = db_manager\n        self.config = config\n        self.bot_core = bot_core\n        \n    async def initialize(self):\n        \"\"\"Initialize poll manager handler\"\"\"\n        try:\n            logger.info(\"‚úÖ Poll manager handler initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize poll manager handler: {e}\")\n            raise\n    \n    async def shutdown(self):\n        \"\"\"Shutdown poll manager handler\"\"\"\n        try:\n            logger.info(\"‚úÖ Poll manager handler shut down\")\n        except Exception as e:\n            logger.error(f\"Error during poll manager shutdown: {e}\")\n    \n    def register_handlers(self, dp: Dispatcher):\n        \"\"\"Register handlers with dispatcher\"\"\"\n        logger.info(\"‚úÖ Poll manager handlers registered\")\n    \n    async def handle_callback(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle poll manager callbacks\"\"\"\n        try:\n            callback_data = callback.data\n            user_id = callback.from_user.id\n            \n            if callback_data == \"pm_vote_poll\":\n                await self._handle_vote_poll(callback, state)\n            elif callback_data == \"pm_stats\":\n                await self._handle_poll_stats(callback, state)\n            elif callback_data == \"pm_campaigns\":\n                await self._handle_view_campaigns(callback, state)\n            elif callback_data == \"pm_help\":\n                await self._handle_help(callback, state)\n            else:\n                await callback.answer(\"‚ùå Unknown poll action\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error in poll manager callback: {e}\")\n            await callback.answer(\"‚ùå An error occurred\", show_alert=True)\n    \n    async def _handle_vote_poll(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Handle poll voting (placeholder)\"\"\"\n        try:\n            text = (\n                \"üó≥Ô∏è <b>Poll Voting</b>\\n\\n\"\n                \"üöß <b>Coming Soon!</b>\\n\\n\"\n                \"Poll voting functionality is being developed.\\n\\n\"\n                \"Features will include:\\n\"\n                \"‚Ä¢ Automated poll voting\\n\"\n                \"‚Ä¢ Multiple account support\\n\"\n                \"‚Ä¢ Smart voting patterns\\n\"\n                \"‚Ä¢ Results tracking\"\n            )\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"üìä View Stats\", callback_data=\"pm_stats\")],\n                [InlineKeyboardButton(text=\"‚ùì Help\", callback_data=\"pm_help\")],\n                [InlineKeyboardButton(text=\"üîô Back\", callback_data=\"poll_manager\")]\n            ])\n            \n            if callback.message:\n                await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error in vote poll: {e}\")\n            await callback.answer(\"‚ùå Failed to load poll voting\", show_alert=True)\n    \n    async def _handle_poll_stats(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Show poll statistics\"\"\"\n        try:\n            user_id = callback.from_user.id\n            \n            # Get user accounts\n            accounts = await self.db.get_user_accounts(user_id, active_only=True)\n            \n            text = (\n                f\"üìä <b>Poll Statistics</b>\\n\\n\"\n                f\"üó≥Ô∏è <b>Total Polls Voted:</b> 0\\n\"\n                f\"‚úÖ <b>Successful Votes:</b> 0\\n\"\n                f\"‚ùå <b>Failed Votes:</b> 0\\n\"\n                f\"üìà <b>Success Rate:</b> 0%\\n\\n\"\n                f\"üë• <b>Active Accounts:</b> {len(accounts)}\\n\\n\"\n                f\"üöß <b>Note:</b> Poll voting feature is in development.\"\n            )\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"üó≥Ô∏è Vote in Poll\", callback_data=\"pm_vote_poll\")],\n                [InlineKeyboardButton(text=\"üîÑ Refresh\", callback_data=\"pm_stats\")],\n                [InlineKeyboardButton(text=\"üîô Back\", callback_data=\"poll_manager\")]\n            ])\n            \n            if callback.message:\n                await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing poll stats: {e}\")\n            await callback.answer(\"‚ùå Failed to load statistics\", show_alert=True)\n    \n    async def _handle_view_campaigns(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Show poll campaigns\"\"\"\n        try:\n            text = (\n                \"üìã <b>Poll Campaigns</b>\\n\\n\"\n                \"üöß <b>Feature in Development</b>\\n\\n\"\n                \"Poll campaign management is coming soon.\\n\\n\"\n                \"This will include:\\n\"\n                \"‚Ä¢ Scheduled poll voting\\n\"\n                \"‚Ä¢ Campaign tracking\\n\"\n                \"‚Ä¢ Automation settings\"\n            )\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"üó≥Ô∏è Vote in Poll\", callback_data=\"pm_vote_poll\")],\n                [InlineKeyboardButton(text=\"üîô Back\", callback_data=\"poll_manager\")]\n            ])\n            \n            if callback.message:\n                await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing campaigns: {e}\")\n            await callback.answer(\"‚ùå Failed to load campaigns\", show_alert=True)\n    \n    async def _handle_help(self, callback: CallbackQuery, state: FSMContext):\n        \"\"\"Show help information\"\"\"\n        try:\n            text = (\n                \"‚ùì <b>Poll Manager Help</b>\\n\\n\"\n                \"üìã <b>What is Poll Manager?</b>\\n\"\n                \"Automated poll voting with multiple Telegram accounts.\\n\\n\"\n                \"üöÄ <b>Coming Features:</b>\\n\"\n                \"‚Ä¢ Vote in polls automatically\\n\"\n                \"‚Ä¢ Use multiple accounts\\n\"\n                \"‚Ä¢ Smart voting patterns\\n\"\n                \"‚Ä¢ Campaign scheduling\\n\"\n                \"‚Ä¢ Results analytics\\n\\n\"\n                \"üöß <b>Status:</b> In Development\\n\\n\"\n                \"Stay tuned for updates!\"\n            )\n            \n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"üìä View Stats\", callback_data=\"pm_stats\")],\n                [InlineKeyboardButton(text=\"üîô Back\", callback_data=\"poll_manager\")]\n            ])\n            \n            if callback.message:\n                await callback.message.edit_text(text, reply_markup=keyboard)\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing help: {e}\")\n            await callback.answer(\"‚ùå Failed to load help\", show_alert=True)\n    \n    async def get_main_menu_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get poll manager main menu keyboard\"\"\"\n        return InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üó≥Ô∏è Vote in Poll\", callback_data=\"pm_vote_poll\")],\n            [InlineKeyboardButton(text=\"üìä View Statistics\", callback_data=\"pm_stats\")],\n            [InlineKeyboardButton(text=\"üìã View Campaigns\", callback_data=\"pm_campaigns\")],\n            [InlineKeyboardButton(text=\"‚ùì Help\", callback_data=\"pm_help\")],\n            [InlineKeyboardButton(text=\"üîô Back to Main Menu\", callback_data=\"refresh_main\")]\n        ])\n","size_bytes":8298}},"version":1}